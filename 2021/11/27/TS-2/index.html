<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta charset="UTF-8"><title>TypeScript 基礎介紹 (2)</title><meta name="description" content="Front-end Engineer"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="
要熟悉 TypeScript 的型別訂定，並不容易，而且撰寫時也會花費較多的時間，但好處是減少程式碼的錯誤，也讓協作者更容易解讀對方撰寫的程式碼。萬事起頭難，不同的地方就是多讀幾次，或是尋找相關的範例來相呼應！
Class傳統方法中，JavaScript 透過建構函式實現類別的概念，透過原型鏈實現繼承。而在 ES6 中，我們終於迎來了 class。

定義一切事務的抽象特點

object  ：class 的實例  new Class 生成

物件導向 OOP(Object Oriented Programming) ：三大特性 封裝、繼承、多型

封裝（Encapsulation）：將對資料的操作細節隱藏起來，只暴露對外的介面。外界呼叫端不需要（也不可能）知道細節，就能透過對外提供的介面來訪問該物件，同.."><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Let's Code" type="application/atom+xml">
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Eva's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">TypeScript 基礎介紹 (2)</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Class"><span class="toc-text">Class</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#複習下-ES6-撰寫方式"><span class="toc-text">複習下 ES6 撰寫方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TypeScript-中的-class"><span class="toc-text">TypeScript 中的 class</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#類別-class-的型別"><span class="toc-text">類別 class 的型別</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#class-與-interface"><span class="toc-text">class 與 interface</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#範例一："><span class="toc-text">範例一：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#可以將兩個共有的抽取為一個-interface"><span class="toc-text">可以將兩個共有的抽取為一個 interface</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#範例二"><span class="toc-text">範例二</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#此外-interface-之間有繼承關係"><span class="toc-text">此外 interface 之間有繼承關係</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#enum-列舉"><span class="toc-text">enum 列舉</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#範例一"><span class="toc-text">範例一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#範例二-1"><span class="toc-text">範例二</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#範例三"><span class="toc-text">範例三</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#泛型-Generics"><span class="toc-text">泛型 Generics</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#範例一-1"><span class="toc-text">範例一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#範例二-傳入多個"><span class="toc-text">範例二 傳入多個</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#泛型第二部分-约束泛型"><span class="toc-text">泛型第二部分 - 约束泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#泛型第三部分-泛型在-class-和-interface-中的使用"><span class="toc-text">泛型第三部分 - 泛型在 class 和 interface 中的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Type-Aliases"><span class="toc-text">Type Aliases</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Intersection-Types"><span class="toc-text">Intersection Types</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#內建物件"><span class="toc-text">內建物件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM-和-BOM-的內建物件"><span class="toc-text">DOM 和 BOM 的內建物件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ECMAScript-的內建物件"><span class="toc-text">ECMAScript 的內建物件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Utility-Types"><span class="toc-text">Utility Types</span></a></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/TypeScript"><i class="tag post-item-tag">TypeScript</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">TypeScript 基礎介紹 (2)</h1><time class="has-text-grey" datetime="2021-11-27T01:44:33.000Z">2021-11-27</time><article class="mt-2 post-content"><p><img src="https://i.imgur.com/xGK5aDO.png" alt=""></p>
<p>要熟悉 TypeScript 的型別訂定，並不容易，而且撰寫時也會花費較多的時間，但好處是減少程式碼的錯誤，也讓協作者更容易解讀對方撰寫的程式碼。<br>萬事起頭難，不同的地方就是多讀幾次，或是尋找相關的範例來相呼應！</p>
<h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><p>傳統方法中，JavaScript 透過建構函式實現類別的概念，透過原型鏈實現繼承。而在 ES6 中，我們終於迎來了 class。</p>
<ul>
<li><p>定義一切事務的抽象特點</p>
</li>
<li><p>object  ：class 的實例  new Class 生成</p>
</li>
<li><p>物件導向 OOP(Object Oriented Programming) ：三大特性 封裝、繼承、多型</p>
<ul>
<li>封裝（Encapsulation）：將對資料的操作細節隱藏起來，只暴露對外的介面。外界呼叫端不需要（也不可能）知道細節，就能透過對外提供的介面來訪問該物件，同時也保證了外界無法任意更改物件內部的資料</li>
<li>繼承（Inheritance）：子類別繼承父類別，子類別除了擁有父類別的所有特性外，還有一些更具體的特性</li>
<li>多型（Polymorphism）：由繼承而產生了相關的不同的類別，對同一個方法可以有不同的響應<h3 id="複習下-ES6-撰寫方式"><a href="#複習下-ES6-撰寫方式" class="headerlink" title="複習下 ES6 撰寫方式"></a>複習下 ES6 撰寫方式</h3></li>
</ul>
</li>
<li><p>使用 class 定義類別，使用 constructor 定義建構函式。</p>
</li>
</ul>
<pre><code class="javascript">class Animal{
    constructor(name){
        this.name = name;
    } 
    run () {
       return `${this.name} is running` 
    }
}
const snake = new Animal(&#39;lily&#39;)
console.log(snake.run()); // lily is running

// 繼承的特性（繼承父類的屬性及方法）， 繼承 run 的方法
class Dog extends Animal {
  bark() {
    return `${this.name} is barking`
  }
}

const bao = new Dog(&#39;bao&#39;)
console.log(bao.run()) // bao is running
console.log(bao.bark()) // bao is  barking</code></pre>
<ul>
<li>使用 extends 關鍵字實現繼承</li>
<li>这里我们重寫構造函式，注意在子類的構造函式中，必須使用 super 調用父類的方法，否則會報錯。</li>
</ul>
<pre><code class="typescript">// 
class Cat extends Animal {
  constructor(name) {
    super(name)
    console.log(this.name) //maomao
  }
  run() {
      // run 方法重寫
    return &#39;Meow, &#39; + super.run()
  }
}
const maomao = new Cat(&#39;maomao&#39;)
console.log(maomao.run()) //Meow, maomao is runing</code></pre>
<h4 id="TypeScript-中的-class"><a href="#TypeScript-中的-class" class="headerlink" title="TypeScript 中的 class"></a>TypeScript 中的 class</h4><p>TypeScript 可以使用三種訪問修飾符（Access Modifiers）</p>
<ul>
<li>public 修飾的屬性或方法是公有的，可以在任何地方被調用到，預設所有的屬性和方法都是 public 的</li>
<li>private 修飾的屬性或方法是私有的，不能在声明它的类的外部調用</li>
<li>protected 修飾的屬性或方法是受保护的，它和 private 類似，區别是它在子類中也是允许被訪問的<br>例子說明：</li>
<li>name 被設定為了 public，所以直接訪問實例的 name 屬性是允許的。</li>
</ul>
<pre><code class="typescript">class Animal {
    public name;
    public constructor(name) {
        this.name = name;
    }
}

let a = new Animal(&#39;Jack&#39;);
console.log(a.name); // Jack
a.name = &#39;Tom&#39;;
console.log(a.name); // Tom</code></pre>
<ul>
<li>希望有的屬性是無法直接存取的，這時候就可以用 private 了：</li>
<li>name 設為 private</li>
</ul>
<pre><code class="typescript">class Animal {
    private name;
    public constructor(name) {
        this.name = name;
    }
}

let a = new Animal(&#39;Jack&#39;);
console.log(a.name); // Jack
a.name = &#39;Tom&#39;;

// index.ts(9,13): error TS2341: Property &#39;name&#39; is private and only accessible within class &#39;Animal&#39;.
// index.ts(10,1): error TS2341: Property &#39;name&#39; is private and only accessible within class &#39;Animal&#39;.</code></pre>
<ul>
<li>使用 private 修飾的屬性或方法，在子類別中也是不允許訪問的：</li>
</ul>
<pre><code class="typescript">class Animal {
    private name;
    public constructor(name) {
        this.name = name;
    }
}

class Cat extends Animal {
    constructor(name) {
        super(name);
        console.log(this.name); 
    }
}

// index.ts(11,17): error TS2341: Property &#39;name&#39; is private and only accessible within class &#39;Animal&#39;.</code></pre>
<ul>
<li>而如果是用 protected 修飾，則允許在子類別中訪問：</li>
<li>將上述程式碼修改一下</li>
</ul>
<pre><code class="typescript">class Animal {
    protected name;
    public constructor(name) {
        this.name = name;
    }
}</code></pre>
<h3 id="類別-class-的型別"><a href="#類別-class-的型別" class="headerlink" title="類別 class 的型別"></a>類別 class 的型別</h3><p>給類別加上 TypeScript 的型別很簡單，與介面類似：</p>
<pre><code class="typescript">class Animal {
    name: string;
    constructor(name: string) {
        this.name = name;
    }
    sayHi(): string {
      return `My name is ${this.name}`;
    }
}

let a: Animal = new Animal(&#39;Jack&#39;);
console.log(a.sayHi()); // My name is Jack</code></pre>
<p><a href="https://willh.gitbook.io/typescript-tutorial/advanced/class" target="_blank" rel="noopener">類別</a></p>
<h3 id="class-與-interface"><a href="#class-與-interface" class="headerlink" title="class 與 interface"></a>class 與 interface</h3><ul>
<li>介面（Interfaces）：不同類別之間公有的屬性或方法，可以抽象成一個介面。介面可以被類別實現（implements）。一個類別只能繼承自另一個類別，但是可以實現多個介面</li>
<li>在 物件導向 世界中，一個 class 只能繼承自另外一個class</li>
<li>有時候不同 class 之前，可以有共同的特性，使用子類繼承父類的方法很難來完成</li>
<li>class 可以使用 implements 來實現 interface （提高 OOP 的靈活性）</li>
</ul>
<h4 id="範例一："><a href="#範例一：" class="headerlink" title="範例一："></a>範例一：</h4><ul>
<li>有 車子和手機，都有打開radio的功能</li>
<li>可以將兩個共有的抽取為一個 interface</li>
</ul>
<pre><code class="typescript">class Car  {
  switchRadio(trigger: boolean) {

  }
}

class Cellphone {
  switchRadio(trigger: boolean) {

  }
}</code></pre>
<h4 id="可以將兩個共有的抽取為一個-interface"><a href="#可以將兩個共有的抽取為一個-interface" class="headerlink" title="可以將兩個共有的抽取為一個 interface"></a>可以將兩個共有的抽取為一個 interface</h4><ul>
<li>void =&gt; 代表什麼都不返回</li>
<li>在class 後面放入  implements 讓類去實現它</li>
</ul>
<pre><code class="typescript">interface Radio {
  switchRadio(trigger: boolean): void;
}

class Car implements Radio {
  switchRadio(trigger) {
    return 123
  }
}
class Cellphone implements Radio {
  switchRadio() {
  }
}</code></pre>
<h4 id="範例二"><a href="#範例二" class="headerlink" title="範例二"></a>範例二</h4><ul>
<li>新特性為 檢查電池的容量</li>
<li>是手機有，但汽車沒有的</li>
<li>所以新建立一個 interface （檢查battery）<ul>
<li>此功能只有手機有，所以放在手機的class</li>
</ul>
</li>
</ul>
<pre><code class="typescript">interface Battery {
  checkBatteryStatus(): void;
}
// 要實現多个介面，我们只需要中間用 都好 隔开即可。
class Cellphone implements Radio, Battery {
  switchRadio() {
  }
  checkBatteryStatus() {

  }
}</code></pre>
<h4 id="此外-interface-之間有繼承關係"><a href="#此外-interface-之間有繼承關係" class="headerlink" title="此外 interface 之間有繼承關係"></a>此外 interface 之間有繼承關係</h4><ul>
<li>建立 radioWithBattery 繼承 Radio ，裡面再放入檢查電量的設定</li>
</ul>
<pre><code class="typescript">interface radioWithBattery extends Radio {
  checkBatteryStatus(): void;
}


class Cellphone implements radioWithBattery {
  switchRadio() {
  }
  checkBatteryStatus() {

  }
}</code></pre>
<p><a href="https://willh.gitbook.io/typescript-tutorial/advanced/class-and-interfaces" target="_blank" rel="noopener">類別與介面</a></p>
<h2 id="enum-列舉"><a href="#enum-列舉" class="headerlink" title="enum 列舉"></a>enum 列舉</h2><ul>
<li>常數指執行程序中不會被改變的值，在 JS 中我們一般會用 const 來宣告</li>
<li>但有些取值是在一定範圍內的一系列常數。<ul>
<li>如：一周內七天、三原色(紅、黃、藍)、方向(上、下、左、右)<h3 id="範例一"><a href="#範例一" class="headerlink" title="範例一"></a>範例一</h3></li>
</ul>
</li>
<li>數字列舉</li>
<li>列舉成員會被賦值為從0，開始遞增</li>
</ul>
<pre><code class="typescript">// 數字列舉，一个數字列舉可以用 enum 这个關鍵詞來定義，我们定義一系列的方向，然后这里面的值，列舉成员会被赋值为從 0 开始遞增的數字,
enum Direction {
  Up,
  Down,
  Left,
  Right,
}
console.log(Direction.Up) //0
// 還有一个神奇的點是這個列舉还做了反向映射
console.log(Direction[0]) //up
</code></pre>
<p><img src="https://i.imgur.com/VMRV8oM.png" alt=""></p>
<ul>
<li>可以手動賦予值</li>
<li>未手動賦值的列舉項會接著上一個列舉項遞增。</li>
</ul>
<pre><code class="typescript">
  Up = 10,
  Down,
  Left,
  Right,
}
console.log(Direction.Down) // 11 ，後面的項目數值會遞增

console.log(Direction[0]) //up
</code></pre>
<h3 id="範例二-1"><a href="#範例二-1" class="headerlink" title="範例二"></a>範例二</h3><pre><code class="typescript">// 字符串列舉
enum Direction {
  Up = &#39;UP&#39;,
  Down = &#39;DOWN&#39;,
  Left = &#39;LEFT&#39;,
  Right = &#39;RIGHT&#39;,
}
const value = &#39;UP&#39;
if (value === Direction.Up) {
  console.log(&#39;go up!&#39;)
}</code></pre>
<h3 id="範例三"><a href="#範例三" class="headerlink" title="範例三"></a>範例三</h3><ul>
<li>常數列舉<ul>
<li>編譯後的邏輯變少了</li>
<li>使用常數列舉會內連列舉的用法並且不會將設定的列舉編譯成 JS 程式碼</li>
</ul>
</li>
</ul>
<pre><code class="typescript">const  enum Direction {
  Up = &#39;UP&#39;,
  Down = &#39;DOWN&#39;,
  Left = &#39;LEFT&#39;,
  Right = &#39;RIGHT&#39;,
}
const value = &#39;UP&#39;
if (value === Direction.Up) {
  console.log(&#39;go up!&#39;)
}</code></pre>
<p><img src="https://i.imgur.com/Fp2XF0y.png" alt=""></p>
<hr>
<h2 id="泛型-Generics"><a href="#泛型-Generics" class="headerlink" title="泛型 Generics"></a>泛型 Generics</h2><ul>
<li>要解決什麼問題<ul>
<li>建立函式 echo 參數為 arg ，接著宣告變數傳入參數</li>
<li>但其中的型別沒有設定</li>
<li>傳入和返回的型別無法統一</li>
</ul>
</li>
</ul>
<pre><code class="typescript">function echo(arg) {
  return arg
}
const result = echo(123)
// 這時候我們發現了一個問題，我们傳入了數字，但是返回了 any</code></pre>
<p><img src="https://i.imgur.com/lo6XFH8.png" alt=""></p>
<ul>
<li>當在建構 function、internet及Class 時，你會希望這些component都能被重複運用的 Generic(泛型)提供了一個彈性的作法。</li>
<li>語法是: <code>&lt;T&gt;</code></li>
</ul>
<h3 id="範例一-1"><a href="#範例一-1" class="headerlink" title="範例一"></a>範例一</h3><ul>
<li>泛型（Generics）是指在定義function、internet及Class的时候，不预先指定具體的型別，而在使用的时候再指定型別的一種特性。</li>
</ul>
<pre><code class="typescript">function echo&lt;T&gt;(arg: T): T {
  return arg
}

const result = echo(123)</code></pre>
<p><img src="https://i.imgur.com/X4quRIj.png" alt=""></p>
<h3 id="範例二-傳入多個"><a href="#範例二-傳入多個" class="headerlink" title="範例二 傳入多個"></a>範例二 傳入多個</h3><pre><code class="typescript">function swap&lt;T, U&gt;(tuple: [T, U]): [U, T] {
  return [tuple[1], tuple[0]]
}

const result = swap([&#39;string&#39;, 123])
</code></pre>
<p><img src="https://i.imgur.com/hJ5IqSY.png" alt=""></p>
<h3 id="泛型第二部分-约束泛型"><a href="#泛型第二部分-约束泛型" class="headerlink" title="泛型第二部分 - 约束泛型"></a>泛型第二部分 - 约束泛型</h3><ul>
<li>帶有「限制」的泛型</li>
</ul>
<pre><code class="typescript">function echoWithArr&lt;T&gt;(arg: T): T {
  console.log(arg.length)
  return arg
}

// 上例中，泛型 T 不一定包含属性 length，我们可以给他傳入任意型別，當然有些不包括 length 属性，那样就會報錯

// 我們使用了 extends 約束了泛型 T 必須符合介面 IWithLength 的形狀，也就是必須包含 length 屬性。
interface IWithLength {
  length: number;
}
function echoWithLength&lt;T extends IWithLength&gt;(arg: T): T {
  console.log(arg.length)
  return arg
}

echoWithLength(&#39;str&#39;)
const result3 = echoWithLength({length: 10})
const result4 = echoWithLength([1, 2, 3])

//此時如果呼叫 loggingIdentity 的時候，傳入的 arg 不包含 length，那麼在編譯階段就會報錯了
echoWithLength(7);
// index.ts(10,17): error TS2345: Argument of type &#39;7&#39; is not assignable to parameter of type &#39;Lengthwise&#39;

</code></pre>
<h3 id="泛型第三部分-泛型在-class-和-interface-中的使用"><a href="#泛型第三部分-泛型在-class-和-interface-中的使用" class="headerlink" title="泛型第三部分 - 泛型在 class 和 interface 中的使用"></a>泛型第三部分 - 泛型在 class 和 interface 中的使用</h3><ol>
<li>泛型在 class 的使用</li>
</ol>
<ul>
<li>在第一個程式中存在一个问题，它允許你向 Queue 中添加任何型別的數據，當然，當數據被彈出隊列时，也可以是任意類型</li>
<li>在下方的範例中，看起来可以向隊列中添加 string 型別的數據，但是那麼在使用的過程中，就會出現無法捕捉的錯誤</li>
</ul>
<pre><code class="typescript">class Queue {
  private data = [];
  push(item) {
    return this.data.push(item)
  }
  pop() {
    return this.data.shift()
  }
}

const queue = new Queue()
queue.push(1)
queue.push(&#39;str&#39;)
console.log(queue.pop().toFixed())
console.log(queue.pop().toFixed())

</code></pre>
<pre><code class="typescript">class Queue&lt;T&gt; {
  private data = [];
  push(item: T) {
    return this.data.push(item)
  }
  pop(): T {
    return this.data.shift()
  }
}
const queue = new Queue&lt;number&gt;()

</code></pre>
<ol start="2">
<li>泛型在  interface 中的使用</li>
</ol>
<ul>
<li>之前提過可以使用介面的方式來定義一個函式需要符合的形狀</li>
<li>當然也可以使用含有泛型的介面來定義函式的形狀：</li>
</ul>
<pre><code class="typescript">//泛型和 interface
interface KeyPair&lt;T, U&gt; {
  key: T;
  value: U;
}

let kp1: KeyPair&lt;number, string&gt; = { key: 1, value: &quot;str&quot;}
let kp2: KeyPair&lt;string, number&gt; = { key: &quot;str&quot;, value: 123}

let arr:number[] = [1,2,3];
let arrTwo:Array&lt;number&gt; = [1,2,3]</code></pre>
<p><img src="https://i.imgur.com/6GXBwCI.png" alt=""></p>
<p>interface 搭配泛型之后，可以靈活的返回不同的型別</p>
<ul>
<li><p>創建一个拥有特定型別的容器，class 和 泛型 仿佛给一个容器貼上標籤一样</p>
</li>
<li><p>泛型就好像一个可變的參數，在用的时候傳入，生成这個不同型別的一个容器，</p>
</li>
<li><p>上個部分的用它来靈活的约束参数的型別，不需要參數是一个特别死板的型別，不希望他是一个特定 string、number 型別，我要傳入的参數必须有某某屬性、某某方法，否則就會報錯。</p>
</li>
<li><p>在函式使用的时候，函式的这个型別推斷，不會進入到函式中，所以使用表達式，没法明確建立型別的绑定，用泛型可以让我们打破這個鴻溝，這個时候就可以返回它傳入的類型。</p>
<h2 id="Type-Aliases"><a href="#Type-Aliases" class="headerlink" title="Type Aliases"></a>Type Aliases</h2></li>
<li><p>就是给型別起一個别名，讓它可以更方便的被重用。</p>
</li>
</ul>
<pre><code class="typescript">let sum: (x: number, y: number) =&gt; number
const result = sum(1,2)
type PlusType = (x: number, y: number) =&gt; number
let sum2: PlusType

// 支持聯合
type StrOrNumber = string | number
let result2: StrOrNumber = &#39;123&#39;
result2 = 123 //沒有錯

// 字符串字面量 ，類似在列舉的常數變量
type Directions = &#39;Up&#39; | &#39;Down&#39; | &#39;Left&#39; | &#39;Right&#39;
// 使toWhere 這個變量為 Direction 類型
let toWhere: Directions = &#39;Up&#39;
</code></pre>
<ul>
<li>我們使用 type 定了一個字串字面量型別 EventNames，它只能取三種字串中的一種。<br>注意，型別別名與字串字面量型別都是使用 type 進行定義。</li>
</ul>
<pre><code class="typescript">type EventNames = &#39;click&#39; | &#39;scroll&#39; | &#39;mousemove&#39;;
function handleEvent(ele: Element, event: EventNames) {
    // do something
}

handleEvent(document.getElementById(&#39;hello&#39;), &#39;scroll&#39;);  // 沒問題
handleEvent(document.getElementById(&#39;world&#39;), &#39;dbclick&#39;); // 報錯，event 不能為 &#39;dbclick&#39;

// index.ts(7,47): error TS2345: Argument of type &#39;&quot;dbclick&quot;&#39; is not assignable to parameter of type &#39;EventNames&#39;.</code></pre>
<h2 id="Intersection-Types"><a href="#Intersection-Types" class="headerlink" title="Intersection Types"></a>Intersection Types</h2><ul>
<li>使用 <code>&amp;</code> 符號</li>
<li>經過上面的 type 使 IName 就有了 name 和 age兩個屬性在裡面<ul>
<li>和interface 的 extends 有點類似，都是為了實現物件形狀組合和擴展</li>
</ul>
</li>
</ul>
<pre><code class="typescript">interface IName  {
  name: string
}
type IPerson = IName &amp; { age: number }
// 經過上面的 type 使 IName 就有了 name 和 age兩個屬性在裡面
let person: IPerson = { name: &#39;hello&#39;, age: 12}</code></pre>
<p>什麼时候用介面，什麼时候用 Type Aliases：</p>
<ul>
<li>interface 是 docker typing 的實現方式，是一種獨特類型，和extends class  implememts 有關的用interface ，</li>
<li>和交叉，聯合型別的有關的用 Type Aliases；</li>
</ul>
<h2 id="內建物件"><a href="#內建物件" class="headerlink" title="內建物件"></a>內建物件</h2><h3 id="DOM-和-BOM-的內建物件"><a href="#DOM-和-BOM-的內建物件" class="headerlink" title="DOM 和 BOM 的內建物件"></a>DOM 和 BOM 的內建物件</h3><p>DOM 和 BOM 提供的內建物件有：<br>Document、HTMLElement、Event、NodeList 等。<br>TypeScript 中會經常用到這些型別：</p>
<pre><code class="typescript">let body: HTMLElement = document.body;
let allDiv: NodeList = document.querySelectorAll(&#39;div&#39;);
document.addEventListener(&#39;click&#39;, function(e: MouseEvent) {
  // Do something
});</code></pre>
<h3 id="ECMAScript-的內建物件"><a href="#ECMAScript-的內建物件" class="headerlink" title="ECMAScript 的內建物件"></a>ECMAScript 的內建物件</h3><ul>
<li>Boolean、Error、Date、RegExp 等。</li>
</ul>
<pre><code class="typescript">let b: Boolean = new Boolean(1);
let e: Error = new Error(&#39;Error occurred&#39;);
let d: Date = new Date();
let r: RegExp = /[a-z]/;</code></pre>
<p><a href="https://github.com/Microsoft/TypeScript/tree/main/src/lib">TypeScript 內置</a></p>
<h2 id="Utility-Types"><a href="#Utility-Types" class="headerlink" title="Utility Types"></a>Utility Types</h2><p><a href="https://www.typescriptlang.org/docs/handbook/utility-types.html" target="_blank" rel="noopener">官方</a><br>Typescript 還提供了一些功能性，帮助性的型別，這些型別，大家在 JS 的世界是看不到的，這些型別叫做 utility types，提供一些簡潔明快而且非常方便的功能。</p>
<ul>
<li>使用  Partial</li>
<li>Omit</li>
</ul>
<pre><code class="typescript">// partial，它可以把傳入的型別都變成可選
interface IPerson {
  name: string
  age: number
}

let viking: IPerson = { name: &#39;viking&#39;, age: 20 }
type IPartial = Partial&lt;IPerson&gt;
let viking2: IPartial = { } //可以都不傳，也不會報錯

// Omit，它返回的型別可以忽略傳入型別的某个屬性
// 以下範例 將 name 忽略掉
type IOmit = Omit&lt;IPerson, &#39;name&#39;&gt;
let viking3: IOmit = { age: 20 }</code></pre>
<p>資料來源：</p>
<ol>
<li>線上課程：實戰 Vue3.0(正式版) + TS </li>
<li><a href="https://willh.gitbook.io/typescript-tutorial/" target="_blank" rel="noopener">TypeScript 新手指南</a></li>
</ol>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2022/01/06/FormData-1/" title="FormData 表單的運用"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">Previous: FormData 表單的運用</span></a><a class="button is-default" href="/2021/11/27/TS-1/" title="TypeScript 基礎介紹 (1)"><span class="has-text-weight-semibold">Next: TypeScript 基礎介紹 (1)</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="Haojen/Claudia-theme-blog" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/https://github.com/Eva813"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> Eva 2022</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>