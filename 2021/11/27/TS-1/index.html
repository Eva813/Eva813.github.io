<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta charset="UTF-8"><title>TypeScript 基礎介紹 (1)</title><meta name="description" content="Front-end Engineer"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="因為工作需求，有需多缺乏的技能需要補齊，TypeScript 就是其中一項。上班看不懂的時候邊查詢，空閒時間再來上課不足不懂的知識點，但還是得透過文章的整理來好好消化一下！既然要開始介紹 TypeScript 就先來說說使用它的原因吧。
為什麼使用 TypeScript
程式語言中，有區分強型別和弱型別兩種類型。

而 JavaScript 是弱型別語言。

在 JavaScript 中，他會自己判斷應該執行的型別。自行做[型別自動轉換]

在快速開發時，很有可能引發一些預期之外的錯誤，相當不利於多人協同開發。

優點：寫法彈性。
缺點：無法在開發時期檢查型別。


依據上述的問題，所以使用 TypeScript



使程式碼更容易理解 （如函式需傳入的參數可以明確設定型別）
減少程式碼撰寫的錯誤
可以完.."><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Let's Code" type="application/atom+xml">
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Eva's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">TypeScript 基礎介紹 (1)</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#為什麼使用-TypeScript"><span class="toc-text">為什麼使用 TypeScript</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#安裝介紹"><span class="toc-text">安裝介紹</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#型別介紹"><span class="toc-text">型別介紹</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#字串-string"><span class="toc-text">字串 string</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Null-和-Undefined"><span class="toc-text">Null 和 Undefined</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#void"><span class="toc-text">void</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#未宣告型別的變數"><span class="toc-text">未宣告型別的變數</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#陣列-Array-與-元組-Tuple"><span class="toc-text">陣列 Array 與 元組 Tuple</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#陣列"><span class="toc-text">陣列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#元組-Tuple"><span class="toc-text">元組 Tuple</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#物件的型別——介面-Interface"><span class="toc-text">物件的型別——介面 (Interface)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#唯讀屬性"><span class="toc-text">唯讀屬性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函式型別"><span class="toc-text">函式型別</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#例子一"><span class="toc-text">例子一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#例子二"><span class="toc-text">例子二</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#例外說明：引數預設值"><span class="toc-text">例外說明：引數預設值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#例子三"><span class="toc-text">例子三</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#例子四"><span class="toc-text">例子四</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#型別推論（Type-Inference）-聯合型別（Union-Types）-型別斷言（Type-Assertion）"><span class="toc-text">型別推論（Type Inference）\ 聯合型別（Union Types） \ 型別斷言（Type Assertion）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#型別推論（Type-Inference）"><span class="toc-text">型別推論（Type Inference）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#聯合型別（Union-Types）"><span class="toc-text">聯合型別（Union Types）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#型別斷言（Type-Assertion）"><span class="toc-text">型別斷言（Type Assertion）</span></a></li></ol></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/TypeScript"><i class="tag post-item-tag">TypeScript</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">TypeScript 基礎介紹 (1)</h1><time class="has-text-grey" datetime="2021-11-27T00:44:33.000Z">2021-11-27</time><article class="mt-2 post-content"><p>因為工作需求，有需多缺乏的技能需要補齊，TypeScript 就是其中一項。<br>上班看不懂的時候邊查詢，空閒時間再來上課不足不懂的知識點，但還是得透過文章的整理來好好消化一下！<br>既然要開始介紹 TypeScript 就先來說說使用它的原因吧。</p>
<h2 id="為什麼使用-TypeScript"><a href="#為什麼使用-TypeScript" class="headerlink" title="為什麼使用 TypeScript"></a>為什麼使用 TypeScript</h2><ul>
<li><p>程式語言中，有區分強型別和弱型別兩種類型。</p>
</li>
<li><p>而 JavaScript 是弱型別語言。</p>
</li>
<li><p>在 JavaScript 中，他會自己判斷應該執行的型別。自行做[型別自動轉換]</p>
</li>
<li><p>在快速開發時，很有可能引發一些預期之外的錯誤，相當不利於多人協同開發。</p>
<ul>
<li>優點：寫法彈性。</li>
<li>缺點：無法在開發時期檢查型別。</li>
</ul>
</li>
<li><p>依據上述的問題，所以使用 TypeScript</p>
</li>
</ul>
<ol>
<li>使程式碼更容易理解 （如函式需傳入的參數可以明確設定型別）</li>
<li>減少程式碼撰寫的錯誤</li>
<li>可以完全兼容JavaScript，此外能與 ES6 完美結合，並提供更多支援寫法。</li>
</ol>
<h2 id="安裝介紹"><a href="#安裝介紹" class="headerlink" title="安裝介紹"></a>安裝介紹</h2><ul>
<li>就是直接到官方網站查看，依需求安裝<br><img src="https://i.imgur.com/wfMqk4w.png" alt=""></li>
</ul>
<p><code>npm install -g typescript</code></p>
<ul>
<li>檢查版本<br><code>tsc -v</code></li>
</ul>
<h2 id="型別介紹"><a href="#型別介紹" class="headerlink" title="型別介紹"></a>型別介紹</h2><p>從 JavaScript 型別分類開始</p>
<h3 id="字串-string"><a href="#字串-string" class="headerlink" title="字串 string"></a>字串 string</h3><ul>
<li>和ES6一樣，可以使用[字串樣板 Template Literals]<pre><code class="TypeScript">let firstName:string = &#39;NaNa&#39;
let message: string = `Hello,${firstName}`
</code></pre>
</li>
</ul>
<pre><code>### 布林值 boolean

布林值是最基礎的資料型別，在 TypeScript 中，使用 boolean 定義布林值型別： 
```typescript
let isDonw:boolean = false </code></pre><p>注意：使用建構函式 Boolean 建立的物件不是布林值：</p>
<ul>
<li>事實上 new Boolean() 返回的是一個 Boolean 物件<pre><code class="JavaScript">let createdByNewBoolean: boolean = new Boolean(1);
</code></pre>
</li>
</ul>
<p>// Type ‘Boolean’ is not assignable to type ‘boolean’.<br>//   ‘boolean’ is a primitive, but ‘Boolean’ is a wrapper object. Prefer using ‘boolean’ when possible.</p>
<pre><code></code></pre><p>在 TypeScript 中，boolean 是 JavaScript 中的基本型別，而 Boolean 是 JavaScript 中的建構函式。</p>
<pre><code>
### 數值 number

```TypeScript
let age:number = 10
let notANumber: number = NaN;
let infinityNumber: number = Infinity;</code></pre><h3 id="Null-和-Undefined"><a href="#Null-和-Undefined" class="headerlink" title="Null 和 Undefined"></a>Null 和 Undefined</h3><ul>
<li>與 void 的區別是，undefined 和 null 是所有型別的子型別<ul>
<li>unfefined 可以賦值給number類型的變數</li>
<li>陣列被赋值為 undefined 或 null 不会报错</li>
<li><code>let num:number = undefined</code></li>
</ul>
</li>
</ul>
<pre><code class="TypeScript">let u: undefined = undefined;
let n: null = null;

// 這樣也不會報錯
let u: undefined;
let num: number = u;</code></pre>
<h3 id="void"><a href="#void" class="headerlink" title="void"></a>void</h3><ul>
<li>通常用在當函式沒有回傳值時。<br><img src="https://i.imgur.com/OOnpUUH.png" alt=""></li>
<li>而 void 型別的變數不能賦值給 number 型別的變數：<pre><code class="JavaScript">let u: void;
let num: number = u;
</code></pre>
</li>
</ul>
<p>// Type ‘void’ is not assignable to type ‘number’.</p>
<pre><code>### any
* 在任意值上任何属性都是允許的
    * 當有明確型別時，應避免使用 any 
    * 因為 any 可以任意調用方法和屬性，很有可能出現錯誤（就喪失類型檢查的意義）
如果是 any 型別，則允許被賦值為任意型別

```TypeScript
let myFavoriteNumber: any = &#39;seven&#39;;
myFavoriteNumber = 7;</code></pre><h4 id="未宣告型別的變數"><a href="#未宣告型別的變數" class="headerlink" title="未宣告型別的變數"></a>未宣告型別的變數</h4><p>變數如果在宣告的時候，未指定其型別，那麼它會被識別為任意值型別：</p>
<pre><code class="JavaScript">let something;
something = &#39;seven&#39;;
something = 7;

something.setName(&#39;Tom&#39;);</code></pre>
<h3 id="陣列-Array-與-元組-Tuple"><a href="#陣列-Array-與-元組-Tuple" class="headerlink" title="陣列 Array 與 元組 Tuple"></a>陣列 Array 與 元組 Tuple</h3><h4 id="陣列"><a href="#陣列" class="headerlink" title="陣列"></a>陣列</h4><ol>
<li>在想宣告的型別後面加上[]，宣告為某個型別的Array<pre><code class="TypeScript">let idList:number[] = [1,2,3]</code></pre>
</li>
<li>使用陣列泛型，Array &lt;元素型別&gt;<pre><code class="TypeScript">let list:Array&lt;number&gt; = [1,2,3]</code></pre>
</li>
</ol>
<ul>
<li>注意，當已經宣告這是個數字陣列<ul>
<li>要 push 字串進去，會出現錯誤<pre><code class="TypeScript">let list:Array&lt;number&gt; = [1,2,3]
list.push(&quot;4&quot;)</code></pre>
<img src="https://i.imgur.com/bzszCFn.png" alt=""><h3 id="元組-Tuple"><a href="#元組-Tuple" class="headerlink" title="元組 Tuple"></a>元組 Tuple</h3></li>
<li>剛剛的陣列將同一類型的數據放在一起，但是，想加入不同型別的數據怎麼辦？</li>
<li>表示方式與陣列相似，將型別寫在<code>[]</code></li>
<li>有固定長度和元素型別的陣列<pre><code class="typescript">// 表示方式和陣列非常相似，只不过它将型別寫在了里面 這時會對每一項產生了限定的作用
let user: [string, number] = [&#39;viking&#39;, 20]
//但是当我们少寫一項 就會報錯，同樣多寫也會報錯
user = [&#39;molly&#39;, 20, true]</code></pre>
<img src="https://i.imgur.com/MfhvOd7.png" alt=""></li>
</ul>
</li>
</ul>
<p><a href="https://willh.gitbook.io/typescript-tutorial/advanced/tuple#can-kao" target="_blank" rel="noopener">元組</a></p>
<h3 id="物件的型別——介面-Interface"><a href="#物件的型別——介面-Interface" class="headerlink" title="物件的型別——介面 (Interface)"></a>物件的型別——介面 (Interface)</h3><ul>
<li>Interface 可以用來定義物件，還有由物件所延伸的型別（例如，陣列、函式）</li>
<li><code>age?: number;</code> 在該屬性後面加上 <code>?</code> 表示為可選屬性 ，也就是在宣告新的物件時，可以彈性加入或不加入age （也不會報錯）</li>
</ul>
<pre><code class="typescript">// 我们定義了一個介面 Person
interface Person {
  name: string;
  age: number;
}
// 接着定义了一个變數 NaNa，它的型別是 Person。
//这样，我们就约束了 NaNa 的形狀必須和介面 Person 一致。
let NaNa: Person ={
  name: &#39;NaNa&#39;,
  age: 20
}

//有时我们希望不要完全匹配一个形狀，那么可以用可選屬性：
interface Person {
    name: string;
    age?: number;
}
let NaNa: Person = {
    name: &#39;NaNa&#39;
}

</code></pre>
<h3 id="唯讀屬性"><a href="#唯讀屬性" class="headerlink" title="唯讀屬性"></a>唯讀屬性</h3><ul>
<li>readonly 是用在屬性上面</li>
<li>希望物件中的一些欄位只能在建立的時候被賦值，那麼可以用 readonly 定義唯讀屬性</li>
</ul>
<pre><code class="typescript">interface Person {
  readonly id: number;
  name: string;
  age?: number;
}
// 建立物件
let Vic: Person ={
  id:1,  
  name: &#39;Vic&#39;,
  age: 20
}
//不能去修改id    
Vic.id = 9527</code></pre>
<h3 id="函式型別"><a href="#函式型別" class="headerlink" title="函式型別"></a>函式型別</h3><ul>
<li>函式可以作為參數、可以存入陣列，可以被另外一個函式返回、可以被賦值另外一個變數</li>
<li>函式是由兩部分構成，一個是輸入(通過不同參數來實現)，二為輸出(就是函數的返回結果)<h4 id="例子一"><a href="#例子一" class="headerlink" title="例子一"></a>例子一</h4></li>
<li>設定參數型別、返回的型別</li>
<li>若參數設定了 x、y兩個，也就只能放入兩個<pre><code class="typescript">// 来到我们的第一个例子，约定输入，约定输出
function add(x: number, y: number): number {
return x + y
}</code></pre>
<img src="https://i.imgur.com/RLOECvw.png" alt=""></li>
</ul>
<h4 id="例子二"><a href="#例子二" class="headerlink" title="例子二"></a>例子二</h4><ul>
<li>也可以設定可選參數</li>
<li>在 z? 表示 z 可有可無</li>
</ul>
<pre><code class="typescript">// 可选参数
function add(x: number, y: number, z?: number): number {
  if (typeof z === &#39;number&#39;) {
    return x + y + z
  } else {
    return x + y
  }
}</code></pre>
<ul>
<li>而在可選參數後面不可以再添加確定參數<br><img src="https://i.imgur.com/qzQRT0r.png" alt=""></li>
</ul>
<h4 id="例外說明：引數預設值"><a href="#例外說明：引數預設值" class="headerlink" title="例外說明：引數預設值"></a>例外說明：引數預設值</h4><ul>
<li>在 ES6 中，我們允許給函式的引數新增預設值，TypeScript 會將添加了預設值的引數識別為可選引數：</li>
</ul>
<pre><code class="typescript">function buildName(firstName: string, lastName: string = &#39;Cat&#39;) {
    return firstName + &#39; &#39; + lastName;
}
let tomcat = buildName(&#39;Tom&#39;, &#39;Cat&#39;);
let tom = buildName(&#39;Tom&#39;); // 因為 lastName 添加了預設值，識別為可選引數</code></pre>
<p>此時就不受「可選引數必須接在必需引數後面」的限制了：</p>
<pre><code class="typescript">function buildName(firstName: string = &#39;Tom&#39;, lastName: string) {
    return firstName + &#39; &#39; + lastName;
}
let tomcat = buildName(&#39;Tom&#39;, &#39;Cat&#39;);
let cat = buildName(undefined, &#39;Cat&#39;);</code></pre>
<h4 id="例子三"><a href="#例子三" class="headerlink" title="例子三"></a>例子三</h4><ul>
<li>函式的表達式</li>
</ul>
<pre><code class="typescript">const add = (x: number, y: number, z?: number): number =&gt; {
  if (typeof z === &#39;number&#39;) {
    return x + y + z
  } else {
    return x + y
  }
}

// 函式本身的类型
const add2: (x: number, y: number, z?:number) =&gt; number = add
</code></pre>
<ul>
<li>函式不只輸入、輸出有類型，本身也有類型<br><img src="https://i.imgur.com/f2Ym2Zb.png" alt=""></li>
<li>將 add2 賦予 string 會出錯誤</li>
<li>所以須聲明一模一樣的 <code>const add2: (x: number, y: number, z?:number) =&gt; number = add</code><br><img src="https://i.imgur.com/FvS1OvL.png" alt=""></li>
</ul>
<h4 id="例子四"><a href="#例子四" class="headerlink" title="例子四"></a>例子四</h4><ul>
<li>使用 interface (單純定義函式的 Interface)</li>
</ul>
<pre><code class="typescript">// interface 描述函数类型
const sum = (x: number, y: number) =&gt; {
  return x + y
}
interface ISum {
  (x: number, y: number): number
}
const sum2: ISum = sum</code></pre>
<ul>
<li>另一個範例</li>
</ul>
<pre><code class="typescript">interface SearchFunc {
    (source: string, subString: string): boolean;
}

let mySearch: SearchFunc;
mySearch = function(source: string, subString: string) {
    return source.search(subString) !== -1;
}</code></pre>
<hr>
<h2 id="型別推論（Type-Inference）-聯合型別（Union-Types）-型別斷言（Type-Assertion）"><a href="#型別推論（Type-Inference）-聯合型別（Union-Types）-型別斷言（Type-Assertion）" class="headerlink" title="型別推論（Type Inference）\ 聯合型別（Union Types） \ 型別斷言（Type Assertion）"></a>型別推論（Type Inference）\ 聯合型別（Union Types） \ 型別斷言（Type Assertion）</h2><h3 id="型別推論（Type-Inference）"><a href="#型別推論（Type-Inference）" class="headerlink" title="型別推論（Type Inference）"></a>型別推論（Type Inference）</h3><ul>
<li>可以推論出我們賦值過程中，這個變數應該是什麼類型的</li>
<li>TS 會在沒有明確指定型別的時候，推測出型別<br><img src="https://i.imgur.com/280zYEs.png" alt=""></li>
</ul>
<h3 id="聯合型別（Union-Types）"><a href="#聯合型別（Union-Types）" class="headerlink" title="聯合型別（Union Types）"></a>聯合型別（Union Types）</h3><ul>
<li>用分隔符號</li>
<li>當 TypeScript 不确定一个聯合型別的變數到底是哪個型別的时候，我们只能使用此聯合型別的所有型別裡共有的屬性或方法</li>
</ul>
<pre><code class="TypeScript">// 允許 numberOrString 的型別是 string 或者 number，但是不能是其他型別。
let numberOrString: number | string 
// 而在使用此聯合型別的所有型別里共有的屬性性或方法：
numberOrString.length  //會報錯 （只有 string 適用）
numberOrString.toString() //string 和 number 的共同屬性是沒問題

//若放在函式定義型別
function getLength(something: string | number): number {
    return something.length;
}

// index.ts(2,22): error TS2339: Property &#39;length&#39; does not exist on type &#39;string | number&#39;.
//   Property &#39;length&#39; does not exist on type &#39;number&#39;.
</code></pre>
<ul>
<li>聯合型別的變數在被賦值的時候，會根據型別推論的規則推斷出一個型別：</li>
</ul>
<pre><code class="TypeScript">let numberOrString: string | number;
numberOrString = &#39;seven&#39;;
console.log(numberOrString.length); // 5
numberOrString = 7;
console.log(numberOrString.length); // 編譯時報錯
// index.ts(5,30): error TS2339: Property &#39;length&#39; does not exist on type &#39;number&#39;.</code></pre>
<p>上例中，第二行的 numberOrString 被推斷成了 string，存取它的 length 屬性不會報錯。<br>而第四行的 numberOrString 被推斷成了 number，存取它的 length 屬性時就報錯了。</p>
<ul>
<li>type guard </li>
<li>當遇到聯合類型，可以使用條件語句，自動幫你縮小型別範圍</li>
</ul>
<pre><code class="javascript">// typescript 在不同的条件分支里面，智能的缩小了范围，这样我们代码出错的几率就大大的降低了。
function getLength2(input: string | number): number {
  if (typeof input === &#39;string&#39;) {
    return input.length
  } else {
    return input.toString().length
  }
}</code></pre>
<h3 id="型別斷言（Type-Assertion）"><a href="#型別斷言（Type-Assertion）" class="headerlink" title="型別斷言（Type Assertion）"></a>型別斷言（Type Assertion）</h3><ul>
<li>開發者比 TS 更了解編寫的程式碼。因此，TS 允許開發者覆蓋它的推論，這樣的機制稱為「型別斷言」。</li>
</ul>
<pre><code class="typescript">// 这里我们可以用 as 關鍵字，告诉typescript 这里我把它看作是一個 string，你可以给他用 string 的方法。
function getLength(input: string | number): number {
  const str = input as string
  if (str.length) {
    return str.length
  } else {
    const number = input as number
    return number.toString().length
  }
}</code></pre>
<ul>
<li>型別斷言不是型別轉換，斷言成一個聯合型別中不存在的型別是不允許的：</li>
</ul>
<pre><code class="TypeScript">function toBoolean(something: string | number): boolean {
    return &lt;boolean&gt;something;
}

// index.ts(2,10): error TS2352: Type &#39;string | number&#39; cannot be converted to type &#39;boolean&#39;.
//   Type &#39;number&#39; is not comparable to type &#39;boolean&#39;.
</code></pre>
<p>基礎型別先介紹到這裡，下篇將介紹一些進階用法～</p>
<p>資料來源：</p>
<ol>
<li>線上課程：實戰 Vue3.0(正式版) + TS </li>
<li><a href="https://willh.gitbook.io/typescript-tutorial/" target="_blank" rel="noopener">TypeScript 新手指南</a></li>
</ol>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2021/11/27/TS-2/" title="TypeScript 基礎介紹 (2)"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">Previous: TypeScript 基礎介紹 (2)</span></a><a class="button is-default" href="/2021/11/10/Nuxt-2/" title="講講幾個 Nuxt.js 重要觀念"><span class="has-text-weight-semibold">Next: 講講幾個 Nuxt.js 重要觀念</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="Haojen/Claudia-theme-blog" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/https://github.com/Eva813"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> Eva 2022</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>