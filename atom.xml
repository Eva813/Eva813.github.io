<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Let&#39;s Code</title>
  
  
  <link href="https://github.com/Eva813/Eva813.github.io.git/atom.xml" rel="self"/>
  
  <link href="https://github.com/Eva813/Eva813.github.io.git/"/>
  <updated>2022-02-28T06:23:29.194Z</updated>
  <id>https://github.com/Eva813/Eva813.github.io.git/</id>
  
  <author>
    <name>Eva Chan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue.js 3 - toRef toRefs</title>
    <link href="https://github.com/Eva813/Eva813.github.io.git/2022/02/28/Vue-toRef/"/>
    <id>https://github.com/Eva813/Eva813.github.io.git/2022/02/28/Vue-toRef/</id>
    <published>2022-02-28T06:16:15.000Z</published>
    <updated>2022-02-28T06:23:29.194Z</updated>
    
    <content type="html"><![CDATA[<h2 id="toRef"><a href="#toRef" class="headerlink" title="toRef"></a>toRef</h2><ul><li>將…變成 ref<br>從 reactive 物件抽出包裝成一個 ref 的值，與原本物件 是連接的，所以修改時，原本的值也會跟著變動。</li><li>只能處理一個屬性，須告知要輸入的屬性\物件</li><li>注意: 更改原始物件內的值，所響應會跟著變動</li></ul><h3 id="在-prop-的應用"><a href="#在-prop-的應用" class="headerlink" title="在 prop 的應用"></a>在 prop 的應用</h3><ul><li>來自的 props 是 物件資料，可以使用toRef<pre><code class="javascript">props: {apiUser: { required: true, type: Object}},setup(props) { const userCopy = toRef(props, &#39;apiUser&#39;)}</code></pre></li><li>範例二</li></ul><pre><code class="html">&lt;template&gt;&lt;h2&gt;姓名: {{person.name}}&lt;/h2&gt;&lt;h2&gt;年齡: {{person.age}}&lt;/h2&gt;&lt;h2&gt;職業描述: {{person.job.front.dec}}&lt;/h2&gt;&lt;button @click=&#39;person.name += ~&#39;&gt;修改姓名&lt;/button&gt;&lt;button @click=&#39;person.age ++ &#39;&gt;增加年齡&lt;/button&gt;&lt;/template&gt;</code></pre><pre><code class="javascript">&lt;script&gt;import {reactive} from &#39;vue&#39;;export default {    name: &#39;Demo&#39;,    setup(){        const person = reactive({            name: &#39;Eva&#39;,            age: 25,            job:{               front:{                   dec:&#39;前端工程師&#39;               }            }        })        return{            person        }    }}&lt;/script&gt;</code></pre><ul><li>要將以上的模板寫的更容易</li></ul><pre><code class="html">&lt;template&gt;&lt;h2&gt;姓名: {{name}}&lt;/h2&gt;&lt;h2&gt;年齡: {{age}}&lt;/h2&gt;&lt;h2&gt;職業描述: {{dec}}&lt;/h2&gt;&lt;button @click=&#39;name += ~&#39;&gt;修改姓名&lt;/button&gt;&lt;button @click=&#39;age ++ &#39;&gt;增加年齡&lt;/button&gt;&lt;/template&gt;</code></pre><pre><code class="javascript">//就是返回普通的物件內容        return{            name: person.name,            age: person.age,            dec: person.job.front.dec        }</code></pre><ul><li><p>但此方式要注意，字串模板會無法響應更新的問題</p></li><li><p>使用 toRef 來達到響應</p></li></ul><pre><code class="javascript">&lt;script&gt;import {reactive,toRef} from &#39;vue&#39;;export default {    name: &#39;Demo&#39;,    setup(){        const person = reactive({            name: &#39;Eva&#39;,            age: 25,            job:{               front:{                   dec:&#39;前端工程師&#39;               }            }        })        //單一轉換        const name2 = toRefs(person,&#39;name&#39;)        return{            name: toRef(person,&#39;name&#39;),            age: toRef(person,&#39;age&#39;),            dec: toRef(person.job.front,&#39;dec&#39;)        }    }}&lt;/script&gt;</code></pre><h2 id="toRefs"><a href="#toRefs" class="headerlink" title="toRefs"></a>toRefs</h2><p>toRefs用來把響應式物件轉換成普通物件，把物件中的每一個屬性，包裹成ref物件<br>    * toRefs就是toRef的升級版，只是toRefs是把響應式物件進行轉換</p><h3 id="延續上方，toRefs"><a href="#延續上方，toRefs" class="headerlink" title="延續上方，toRefs"></a>延續上方，toRefs</h3><ul><li>可以批量處理，一個物件裡的屬性<ul><li>只會將第一層展開，所以以下在 job 的內層 </li></ul></li></ul><pre><code class="html">&lt;template&gt;&lt;h2&gt;姓名: {{name}}&lt;/h2&gt;&lt;h2&gt;年齡: {{age}}&lt;/h2&gt;&lt;h2&gt;職業描述: {{job.front.dec}}&lt;/h2&gt;&lt;button @click=&#39;name += ~&#39;&gt;修改姓名&lt;/button&gt;&lt;button @click=&#39;age ++ &#39;&gt;增加年齡&lt;/button&gt;&lt;/template&gt;</code></pre><pre><code class="javascript">&lt;script&gt;import {reactive,toRefs} from &#39;vue&#39;;export default {    name: &#39;Demo&#39;,    setup(){        const person = reactive({            name: &#39;Eva&#39;,            age: 25,            job:{               front:{                   dec:&#39;前端工程師&#39;               }            }        })        //可以批量處理，所以只需要傳入個物件，        const new = toRefs(person)        console.log(new)        //在物件中再放toRefs(person) ，會變成物件包物件，所以要展開        return{           ...toRefs(person)            // name: toRef(person,&#39;name&#39;),            // age: toRef(person,&#39;age&#39;),            // dec: toRef(person.job.front,&#39;dec&#39;)        }    }}&lt;/script&gt;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;toRef&quot;&gt;&lt;a href=&quot;#toRef&quot; class=&quot;headerlink&quot; title=&quot;toRef&quot;&gt;&lt;/a&gt;toRef&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;將…變成 ref&lt;br&gt;從 reactive 物件抽出包裝成一個 ref 的值，與原本物件 是連接的，所</summary>
      
    
    
    
    
    <category term="Vue" scheme="https://github.com/Eva813/Eva813.github.io.git/tags/Vue/"/>
    
    <category term="v-for" scheme="https://github.com/Eva813/Eva813.github.io.git/tags/v-for/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript - 註記(Annotation) 與斷言(Assertion)</title>
    <link href="https://github.com/Eva813/Eva813.github.io.git/2022/01/14/TS-3/"/>
    <id>https://github.com/Eva813/Eva813.github.io.git/2022/01/14/TS-3/</id>
    <published>2022-01-14T03:08:06.000Z</published>
    <updated>2022-01-16T03:22:36.487Z</updated>
    
    <content type="html"><![CDATA[<p>從開始學習前端之後，大多的學習資源都是來自線上課程、youtube 影片為主，鮮少透過閱讀書籍來學習相關知識，但自從進入公司之後，因為公司內有些程式書籍能夠借閱，先是從 JavaScript 大全開始，一開始閱讀起來真的滿痛苦，不知道該如何消化內容，直接順著讀過去又怕忘記，但目前還是順順的讀到了第8章～後來，找到的方式就是在筆記軟體上做些註記，工作上遇到相關的再回過頭看一次，加入筆記。</p><p>而在此次，發現 TypeScript 即便已經看過介紹型別、基本使用基礎的影片後，仍然覺得不太足夠，所以就開始翻閱書籍 「讓 TypeScript 成為你全端開發的 ACE」，文中介紹滿多之前沒有注意到觀念、也有帶到不少 JavaScript 的觀念來呼應。所以本篇，多是來自於書中資訊，透過整理呈現。</p><h2 id="註記-Annotation-V-S-斷言-Assertion"><a href="#註記-Annotation-V-S-斷言-Assertion" class="headerlink" title="註記 Annotation V.S. 斷言 Assertion"></a>註記 Annotation V.S. 斷言 Assertion</h2><ul><li>型別註記：指在告訴 TS 編譯器：「任何被註記到的變數、函式的參數等，都必須遵照被註記過後的變數型別」。</li><li>所以編譯器會隨時隨地的監測該變數有沒有出現型別衝突的可能—關鍵字為遵照。</li><li>而，斷言型別則是無視 TS 編譯器分析整個程式碼的型別推論過程，果斷的告訴 TS 編譯器：「被斷言過後的表達式之運算結果就是某某型別」—關鍵意象是「覆蓋」該表達式的型別推論結果。</li></ul><h2 id="註記與斷言"><a href="#註記與斷言" class="headerlink" title="註記與斷言"></a>註記與斷言</h2><ul><li>帶有冒號的相關語法</li></ul><pre><code class="typescript">let randomNumber:number = Math.random();const subscribed:boolean = true;</code></pre><ul><li>如果遇到函式，參數(Argument)部分除了可以有類似註記方式標明輸入的參數型別外，在參數宣告結尾也可以註記該函式輸出之型別。</li></ul><pre><code class="javascript">function isPositive(input: number):boolean{    return input &gt; 0}</code></pre><ul><li>但JS裡，宣告函式的方法有很多種，其中一個是將函式最為值指派到變數。</li></ul><pre><code class="javascript">const isPositive:(input:number) =&gt; boolean = function(input){    return input &gt; 0}</code></pre><ul><li>以上，也能把變數指派的函式，改成ES6箭頭函式<ul><li>指派運算子(Assignment Operator ，就是指程式裡的等號)左方是函式的型別註記表示法，右方則是普通函式宣告</li></ul></li></ul><pre><code class="typescript">const isPositive:(input:number) =&gt; boolean = input =&gt; input &gt;0;</code></pre><ul><li>採用邊宣告函式、邊註記型別的方式定義函式</li></ul><pre><code class="typescript">const isPositive = function (input:number):boolean{    return input&gt;0}</code></pre><pre><code class="typescript">const isPositive =  (input:number):boolean =&gt;  input&gt;0</code></pre><h2 id="型別斷言語法"><a href="#型別斷言語法" class="headerlink" title="型別斷言語法"></a>型別斷言語法</h2><ul><li>斷言(Assertion)的語法很簡單，看到有使用關鍵字 as 或者 <code>&lt;T&gt;(...)</code> 的格式就是斷言的用法。</li><li>通常會使用斷言的情境，程式沒辦法推論某表達式的確切運算結果之型別，我們才會用選擇使出斷言來處理這種情境。</li><li>程式沒辦法推論？<ul><li>使用第三方的資源（Third-party resources），如使用外來JSON API 獲得的內容之型別格式、讀取檔案轉成 JSON 物件的結果、使用套件提供的功能、呼叫會回傳未知結果的函式。</li></ul></li></ul><pre><code class="typescript">const aNumber = returnsUnknow() as number;</code></pre><p>或是這樣：</p><pre><code class="typescript">const aNumber = &lt;number&gt;(returnsUnkonw());</code></pre><ul><li>請注意：斷言的語法部分，沒有人斷言在變數的名稱宣告部分—也就是是說，如果你這樣寫是錯的：</li></ul><pre><code class="typescript">const aNumber as number = returnsUnknow(); //這是錯誤的</code></pre><ul><li>概念有點像，決斷地告訴程式，某表達式的運算結果之型別。</li><li>變數本身不是被運算，而是被指派某個東西，而斷言應該是斷在被指派的值或表達式的運算結果上。</li></ul><h4 id="複雜一點"><a href="#複雜一點" class="headerlink" title="複雜一點"></a>複雜一點</h4><ul><li>函式宣告表達式有可以被斷言(畢竟函式作為表達式也會被當成值)</li></ul><pre><code class="typescript">const isPositive =(input =&gt; input &gt; 0) as (input: number) =&gt; boolean</code></pre><p>或者是：</p><pre><code class="javascript">const isPositive = &lt;(input: number) =&gt; boolean&gt;(input =&gt; input &gt;0);</code></pre><ul><li>上面斷言的寫法效果跟之前示範過基礎註記手法：</li></ul><pre><code class="typescript">const isPositive :(input: number) =&gt; boolean = input =&gt; input &gt;0;</code></pre><p>或者是</p><pre><code class="typescript">const isPositive ＝(input: number)：boolean =&gt; input &gt;0;</code></pre><h2 id="說下，敘述式與表達式的定義與差別"><a href="#說下，敘述式與表達式的定義與差別" class="headerlink" title="說下，敘述式與表達式的定義與差別"></a>說下，敘述式與表達式的定義與差別</h2><ol><li>敘述式：程式運行的流程，例如：JS 裡的判斷敘述式(if…else)以及迴圈敘述式(for 或者是 while 迴圈)。</li><li>表達式代表的則是程式碼運算的流程，並且會將運算結果回傳。其中兩者最關鍵差異為：敘述式不會回傳值，表達式則會。</li></ol><ul><li>以下為常見的表達式範例：</li></ul><pre><code class="typescript"> //運算表達式 Arithmetic expression 1+2*3 ; //回傳解果為7//邏輯表達式 Logical Expressiontrue &amp;&amp; (something === null || myAge &lt; 18) //回傳結果為 true 或 false//函式（或方法的呼叫） Function / Method Invocation ExpressionMath.pow(2,10) //回傳結果為 1024//三元運算子 Ternary OperatormyAge &lt; 18 ? &#39;Youngster&#39; : &#39;Adult&#39;; //回傳結果為 &#39;Youngster&#39; 因為 myAge &lt; 18 </code></pre><p>而敘述式：</p><pre><code class="javascript">if(/*expression 1*/){    //若 expression1 為 true 則執行}else if(/*expression 2*/){    //若 expression2 為 true 則執行} else{    //若 expression1、expression2 都不為 true 則執行此}//迴圈敘述式 Looping Statementwhile (/*expression */){    //若 expression 為 true， 則重複執行直到 expression 為 false 時跳脫}</code></pre><ul><li>按照上面敘述式的定義 — 由於敘述式是在敘述運行流程，而不會回傳值，所以你才不會在 JavaScript 裡面看到這樣的寫法：</li></ul><pre><code class="javascript">// JS 並有提供這寫法const status = if(Age &lt;18 ){    return &#39;Young&#39;}else{    return &#39;Adult&#39;}</code></pre><ul><li>注意：敘述式不一定是多行式（或區塊式）地呈現的最佳案例：變數宣告的指派敘述式(Variable Declaration Assignment Statement)<pre><code class="javascript">//變數宣告的 指派敘述式const foo =123;</code></pre></li><li>請問上面指派式會回傳什麼結果 =&gt;數字 123 或 udefined。正解為 udefined<ul><li>指派式的回傳結果為 undefined</li></ul></li><li>所以可以歸納出，javaScript 的變數宣告的指派式屬於敘述式，非表達式。</li></ul><h4 id="表達式什麼時候會以非單行的程式碼，也就是區塊的方式？"><a href="#表達式什麼時候會以非單行的程式碼，也就是區塊的方式？" class="headerlink" title="表達式什麼時候會以非單行的程式碼，也就是區塊的方式？"></a>表達式什麼時候會以非單行的程式碼，也就是區塊的方式？</h4><ul><li>立即呼叫函式表達式(IIFE)</li></ul><pre><code class="javascript">const status = (funcrion(myAge){                                 if (myAge &lt;18){ return &#39;Young&#39;}                                    return &#39;Adult&#39;                                })(16) //假設填入參數為16，呼叫該函式的結果回傳 &#39;Young&#39;</code></pre><ul><li>當可以分清楚表達式與敘述式差別後，回歸型別斷言</li><li>斷言的基礎語法<ul><li>斷言的語法只能用在表達式上，因為表達式具備回傳值，敘述式則沒有</li><li>因此，可以「斷言該表達式所運算結果之代表型別」</li></ul></li></ul><p>寫法如下：</p><pre><code class="javascript">&lt;expression&gt; as T assertion&lt;T assertion &gt;(&lt;expression&gt;)</code></pre><pre><code class="typescript">//運算表達式(foo+bar*baz) as number;// 邏輯表達式(isPositive(num) &amp;&amp; idEven(num)) as boolean;//functionMath.pow(2, 10) as number//(myAge &lt;18 ? &#39;Young&#39; : &#39;Adult&#39;) as string;//IIFE(funcrion(myAge){                     if (myAge &lt;18){ return &#39;Young&#39;}                        return &#39;Adult&#39;                    })(16) as number//只要是表達式，就算在其他敘述式、表達式內也能使用somefunction(foo as number , bar as string) as boolean</code></pre><p>換種寫法：</p><pre><code class="typescript">&lt;number&gt;(foo+bar*baz);// 邏輯表達式&lt;boolean&gt; (isPositive(num) &amp;&amp; idEven(num)) ;//function&lt;number&gt; Math.pow(2, 10) ;//&lt;string&gt;(myAge &lt;18 ? &#39;Young&#39; : &#39;Adult&#39;) ;//IIFE &lt;number&gt;(     funcrion(myAge){                     if (myAge &lt;18){ return &#39;Young&#39;}                        return &#39;Adult&#39;                    })(16)   );//只要是表達式，就算在其他敘述式、表達式內也能使用&lt;boolean&gt;somefunction(foo as number , bar as string) </code></pre><p>以上針對註記 Annotation V.S. 斷言 Assertion 做個簡單整理～</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;從開始學習前端之後，大多的學習資源都是來自線上課程、youtube 影片為主，鮮少透過閱讀書籍來學習相關知識，但自從進入公司之後，因為公司內有些程式書籍能夠借閱，先是從 JavaScript 大全開始，一開始閱讀起來真的滿痛苦，不知道該如何消化內容，直接順著讀過去又怕忘記，</summary>
      
    
    
    
    
    <category term="TypeScript" scheme="https://github.com/Eva813/Eva813.github.io.git/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>FormData 表單的運用</title>
    <link href="https://github.com/Eva813/Eva813.github.io.git/2022/01/06/FormData-1/"/>
    <id>https://github.com/Eva813/Eva813.github.io.git/2022/01/06/FormData-1/</id>
    <published>2022-01-06T02:44:33.000Z</published>
    <updated>2022-01-08T08:44:53.083Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/xf0DAqA.png" alt=""></p><p>最近遇到將表單資料存到後端的方式，過去一直以為是將資料整理為物件方式存取即可，後來發現使用FormData來建立物件傳送檔案即可!</p><ul><li>FormData 是一個表單格式，利用它將資料轉成表單的格式，並且以表單的形式回傳給後端</li></ul><h2 id="建立-FormData-物件"><a href="#建立-FormData-物件" class="headerlink" title="建立 FormData 物件"></a>建立 FormData 物件</h2><ul><li>最直接方式，先取得form的資料</li></ul><pre><code class="javascript">// 根據表單元素取得表單資料var form = document.querySelector(&#39;form&#39;);var formData = new FormData(form);// 可以用 append 把欄位灌進去表單中var formData = new FormData(); // 一開始表單的資料是空的formData.append(&#39;username&#39;, Chris); // 增加欄位formData.append(&#39;image&#39;, file); // 檔案也可以透過 append 放進來</code></pre><h2 id="以下介紹幾個基礎的使用方式："><a href="#以下介紹幾個基礎的使用方式：" class="headerlink" title="以下介紹幾個基礎的使用方式："></a>以下介紹幾個基礎的使用方式：</h2><ul><li><code>formData.append(name, value)</code> : 加入有 name 和 value 的表單資料(name:表單標籤的名稱,value: input 輸入的值)</li><li><code>formData.append(name, blob, fileName)</code> : 加入字段，就像它是 <code>&lt;input type=&quot;file&quot;&gt;</code>，第三個參數 fileName 設置檔案名</li><li><code>formData.delete(name)</code> : 移除帶有 name 的字段，</li><li><code>formData.get(name)</code> : 取得帶有 name 的值，</li><li><code>formData.has(name)</code> : 如果帶有給定 name 的字段，返回 true，否則返回 false。</li></ul><h2 id="使用axios-傳遞資料"><a href="#使用axios-傳遞資料" class="headerlink" title="使用axios 傳遞資料"></a>使用axios 傳遞資料</h2><pre><code class="javascript">var formData = new FormData();//宣告要取得的值var title = form.nameformData.append(&quot;formTitle&quot;, title);axios.post(&#39;upload_file&#39;, formData, {    headers: {      &#39;Content-Type&#39;: &#39;multipart/form-data&#39;    }})</code></pre><h2 id="補充-vue-Typescript-宣告型別"><a href="#補充-vue-Typescript-宣告型別" class="headerlink" title="補充 vue+Typescript 宣告型別"></a>補充 vue+Typescript 宣告型別</h2><ul><li>以 stack overflow 內的資料為例：<ul><li>可以使用 ref來取得DOM元素，並宣告該變數為HTMLFormElement<pre><code class="javascript">&lt;el-form    class=&quot;m-auto&quot;    ref=&quot;formRef&quot;    :model=&quot;form&quot;    :rules=&quot;rules&quot;  &gt;</code></pre><pre><code class="javascript">const formRef = ref&lt;HTMLFormElement&gt;();</code></pre></li></ul></li><li>另是使用 element-UI 的表單，也可以使用<br><code>import {  ElForm } from &quot;element-ui&quot;;</code></li></ul><p><a href="https://www.ucamc.com/articles/332-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8jquery-ajax-submit-%E5%82%B3%E9%80%81form%E8%A1%A8%E5%96%AEserialize-%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">如何使用jQuery AJAX submit 傳送form表單方法</a><br><a href="https://5xruby.tw/courses/javascript" target="_blank" rel="noopener">JavaScript / jQuery 前端開發入門實戰</a><br><a href="https://zh.javascript.info/formdata" target="_blank" rel="noopener">JavaScript Info-formData</a><br><a href="https://stackoverflow.com/questions/67074871/vue-3-typescript-unable-to-access-method-from-ref" target="_blank" rel="noopener">stackoverflow</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/xf0DAqA.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;最近遇到將表單資料存到後端的方式，過去一直以為是將資料整理為物件方式存取即可，後來發現使用FormData來建立物件傳送檔案即可!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://github.com/Eva813/Eva813.github.io.git/tags/JavaScript/"/>
    
    <category term="TypeScript" scheme="https://github.com/Eva813/Eva813.github.io.git/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>Nuxt3-取得資料的方式</title>
    <link href="https://github.com/Eva813/Eva813.github.io.git/2021/12/10/Nuxt3-1/"/>
    <id>https://github.com/Eva813/Eva813.github.io.git/2021/12/10/Nuxt3-1/</id>
    <published>2021-12-10T12:08:43.000Z</published>
    <updated>2022-01-10T12:39:56.519Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/FAgr4vk.png" alt=""></p><h2 id="useAsyncData"><a href="#useAsyncData" class="headerlink" title="useAsyncData"></a>useAsyncData</h2><pre><code class="javascript">const {  data: Ref&lt;DataT&gt;,  pending: Ref&lt;boolean&gt;,  refresh: (force?: boolean) =&gt; Promise&lt;void&gt;,  error?: any} = useAsyncData(  key: string,  fn: () =&gt; Object,  options?: { lazy: boolean, server: boolean })</code></pre><ul><li>頁面、組件中都可以使用useAsyncData 取得資料</li><li>Key ：寫一個唯一的id<br>請求資料的函式</li><li>使用 useAsyncData 會回傳物件<br>data : 返回的資料<br>pedding : 指出資料是否被取得<br>refresh : 是否要刷新資料<h3 id="Option-介紹"><a href="#Option-介紹" class="headerlink" title="Option 介紹"></a>Option 介紹</h3></li><li>Lazy 延遲載入，直到數據獲取時，才顯示於頁面</li><li>默認會是 false</li><li>Server 頁面是在server端要載入，就可以設定為true</li><li>Pick 從回傳的資料中，選擇要使用的key值</li></ul><h3 id="useAsyncData撰寫方式的範例"><a href="#useAsyncData撰寫方式的範例" class="headerlink" title="useAsyncData撰寫方式的範例"></a>useAsyncData撰寫方式的範例</h3><ul><li>本地建立資料夾<ul><li>server/api/count.ts</li></ul></li></ul><pre><code class="javascript">let counter = 0export default () =&gt; {  counter++  return JSON.stringify(counter)}</code></pre><ul><li><code>app.vue</code>，使用 useAsyncData</li></ul><pre><code class="javascript">&lt;script setup&gt;const { data } = await useAsyncData(&#39;count&#39;, () =&gt; $fetch(&#39;/api/count&#39;))&lt;/script&gt;&lt;template&gt;  Page visits: {{ data }}&lt;/template&gt;</code></pre><h2 id="useFetch"><a href="#useFetch" class="headerlink" title="useFetch"></a>useFetch</h2><ul><li>頁面、組件中可以使用useFetch獲取任意URL資源</li><li>useFetch包裝 了useAsyncData 和 $fetch</li><li>會根據 URL 自動生成 Key，也會去推斷API 的類型a<pre><code class="javascript">const {data: Ref&lt;DataT&gt;,pending: Ref&lt;boolean&gt;,refresh: (force?: boolean) =&gt; Promise&lt;void&gt;,error?: any} = useFetch(url: string, options?)</code></pre></li></ul><pre><code class="javascript">&lt;script setup&gt;const { data } = await useFetch(&#39;/api/count&#39;)&lt;/script&gt;&lt;template&gt;  Page visits: {{ data.count }}&lt;/template&gt;</code></pre><h2 id="補充：其他2個類似方式"><a href="#補充：其他2個類似方式" class="headerlink" title="補充：其他2個類似方式"></a>補充：其他2個類似方式</h2><ul><li>useLazyAsyncData : 方法等於useAsyncData，僅設置了lazy選項為true</li><li>useLazyFetch : 方法等於useFetch，僅設置了lazy選項為true</li></ul><h2 id="實作範例："><a href="#實作範例：" class="headerlink" title="實作範例："></a>實作範例：</h2><ul><li><code>/api/mountains/everest</code><ul><li>API 會產生的物件資料</li></ul></li></ul><pre><code class="javascript">{  &quot;title&quot;: &quot;Mount Everest&quot;,  &quot;description&quot;: &quot;Mount Everest is Earth&#39;s highest mountain above sea level, located in the Mahalangur Himal sub-range of the Himalayas. The China–Nepal border runs across its summit point&quot;,  &quot;height&quot;: &quot;8,848 m&quot;,  &quot;countries&quot;: [    &quot;China&quot;,    &quot;Nepal&quot;  ],  &quot;continent&quot;: &quot;Asia&quot;,  &quot;image&quot;: &quot;https://upload.wikimedia.org/wikipedia/commons/thumb/f/f6/Everest_kalapatthar.jpg/600px-Everest_kalapatthar.jpg&quot;}</code></pre><p>Nuxt 3 為了提高效率會在取得資料後，緩存在當前頁面的payload<br>官方建議：如果只打算在組件中使用到 title 和 description ，你可以使用關鍵的屬性運用即可<br>選項中加入 pick，裡面的值就是取得資料中的key值</p><pre><code class="javascript">&lt;script setup&gt;const { data: mountain } = await useFetch(&#39;/api/mountains/everest&#39;, { pick: [&#39;title&#39;, &#39;description&#39;] })&lt;/script&gt;&lt;template&gt;  &lt;h1&gt;{{ mountain.title }}&lt;/h1&gt;  &lt;p&gt;{{ mountain.description }}&lt;/p&gt;&lt;/template&gt;</code></pre><p><a href="https://v3.nuxtjs.org/docs/usage/data-fetching" target="_blank" rel="noopener">參考資料</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/FAgr4vk.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;useAsyncData&quot;&gt;&lt;a href=&quot;#useAsyncData&quot; class=&quot;headerlink&quot; title=&quot;useAsyncDa</summary>
      
    
    
    
    
    <category term="Nuxt" scheme="https://github.com/Eva813/Eva813.github.io.git/tags/Nuxt/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript 基礎介紹 (2)</title>
    <link href="https://github.com/Eva813/Eva813.github.io.git/2021/11/27/TS-2/"/>
    <id>https://github.com/Eva813/Eva813.github.io.git/2021/11/27/TS-2/</id>
    <published>2021-11-27T01:44:33.000Z</published>
    <updated>2022-01-08T08:41:26.360Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/xGK5aDO.png" alt=""></p><p>要熟悉 TypeScript 的型別訂定，並不容易，而且撰寫時也會花費較多的時間，但好處是減少程式碼的錯誤，也讓協作者更容易解讀對方撰寫的程式碼。<br>萬事起頭難，不同的地方就是多讀幾次，或是尋找相關的範例來相呼應！</p><h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><p>傳統方法中，JavaScript 透過建構函式實現類別的概念，透過原型鏈實現繼承。而在 ES6 中，我們終於迎來了 class。</p><ul><li><p>定義一切事務的抽象特點</p></li><li><p>object  ：class 的實例  new Class 生成</p></li><li><p>物件導向 OOP(Object Oriented Programming) ：三大特性 封裝、繼承、多型</p><ul><li>封裝（Encapsulation）：將對資料的操作細節隱藏起來，只暴露對外的介面。外界呼叫端不需要（也不可能）知道細節，就能透過對外提供的介面來訪問該物件，同時也保證了外界無法任意更改物件內部的資料</li><li>繼承（Inheritance）：子類別繼承父類別，子類別除了擁有父類別的所有特性外，還有一些更具體的特性</li><li>多型（Polymorphism）：由繼承而產生了相關的不同的類別，對同一個方法可以有不同的響應<h3 id="複習下-ES6-撰寫方式"><a href="#複習下-ES6-撰寫方式" class="headerlink" title="複習下 ES6 撰寫方式"></a>複習下 ES6 撰寫方式</h3></li></ul></li><li><p>使用 class 定義類別，使用 constructor 定義建構函式。</p></li></ul><pre><code class="javascript">class Animal{    constructor(name){        this.name = name;    }     run () {       return `${this.name} is running`     }}const snake = new Animal(&#39;lily&#39;)console.log(snake.run()); // lily is running// 繼承的特性（繼承父類的屬性及方法）， 繼承 run 的方法class Dog extends Animal {  bark() {    return `${this.name} is barking`  }}const bao = new Dog(&#39;bao&#39;)console.log(bao.run()) // bao is runningconsole.log(bao.bark()) // bao is  barking</code></pre><ul><li>使用 extends 關鍵字實現繼承</li><li>这里我们重寫構造函式，注意在子類的構造函式中，必須使用 super 調用父類的方法，否則會報錯。</li></ul><pre><code class="typescript">// class Cat extends Animal {  constructor(name) {    super(name)    console.log(this.name) //maomao  }  run() {      // run 方法重寫    return &#39;Meow, &#39; + super.run()  }}const maomao = new Cat(&#39;maomao&#39;)console.log(maomao.run()) //Meow, maomao is runing</code></pre><h4 id="TypeScript-中的-class"><a href="#TypeScript-中的-class" class="headerlink" title="TypeScript 中的 class"></a>TypeScript 中的 class</h4><p>TypeScript 可以使用三種訪問修飾符（Access Modifiers）</p><ul><li>public 修飾的屬性或方法是公有的，可以在任何地方被調用到，預設所有的屬性和方法都是 public 的</li><li>private 修飾的屬性或方法是私有的，不能在声明它的类的外部調用</li><li>protected 修飾的屬性或方法是受保护的，它和 private 類似，區别是它在子類中也是允许被訪問的<br>例子說明：</li><li>name 被設定為了 public，所以直接訪問實例的 name 屬性是允許的。</li></ul><pre><code class="typescript">class Animal {    public name;    public constructor(name) {        this.name = name;    }}let a = new Animal(&#39;Jack&#39;);console.log(a.name); // Jacka.name = &#39;Tom&#39;;console.log(a.name); // Tom</code></pre><ul><li>希望有的屬性是無法直接存取的，這時候就可以用 private 了：</li><li>name 設為 private</li></ul><pre><code class="typescript">class Animal {    private name;    public constructor(name) {        this.name = name;    }}let a = new Animal(&#39;Jack&#39;);console.log(a.name); // Jacka.name = &#39;Tom&#39;;// index.ts(9,13): error TS2341: Property &#39;name&#39; is private and only accessible within class &#39;Animal&#39;.// index.ts(10,1): error TS2341: Property &#39;name&#39; is private and only accessible within class &#39;Animal&#39;.</code></pre><ul><li>使用 private 修飾的屬性或方法，在子類別中也是不允許訪問的：</li></ul><pre><code class="typescript">class Animal {    private name;    public constructor(name) {        this.name = name;    }}class Cat extends Animal {    constructor(name) {        super(name);        console.log(this.name);     }}// index.ts(11,17): error TS2341: Property &#39;name&#39; is private and only accessible within class &#39;Animal&#39;.</code></pre><ul><li>而如果是用 protected 修飾，則允許在子類別中訪問：</li><li>將上述程式碼修改一下</li></ul><pre><code class="typescript">class Animal {    protected name;    public constructor(name) {        this.name = name;    }}</code></pre><h3 id="類別-class-的型別"><a href="#類別-class-的型別" class="headerlink" title="類別 class 的型別"></a>類別 class 的型別</h3><p>給類別加上 TypeScript 的型別很簡單，與介面類似：</p><pre><code class="typescript">class Animal {    name: string;    constructor(name: string) {        this.name = name;    }    sayHi(): string {      return `My name is ${this.name}`;    }}let a: Animal = new Animal(&#39;Jack&#39;);console.log(a.sayHi()); // My name is Jack</code></pre><p><a href="https://willh.gitbook.io/typescript-tutorial/advanced/class" target="_blank" rel="noopener">類別</a></p><h3 id="class-與-interface"><a href="#class-與-interface" class="headerlink" title="class 與 interface"></a>class 與 interface</h3><ul><li>介面（Interfaces）：不同類別之間公有的屬性或方法，可以抽象成一個介面。介面可以被類別實現（implements）。一個類別只能繼承自另一個類別，但是可以實現多個介面</li><li>在 物件導向 世界中，一個 class 只能繼承自另外一個class</li><li>有時候不同 class 之前，可以有共同的特性，使用子類繼承父類的方法很難來完成</li><li>class 可以使用 implements 來實現 interface （提高 OOP 的靈活性）</li></ul><h4 id="範例一："><a href="#範例一：" class="headerlink" title="範例一："></a>範例一：</h4><ul><li>有 車子和手機，都有打開radio的功能</li><li>可以將兩個共有的抽取為一個 interface</li></ul><pre><code class="typescript">class Car  {  switchRadio(trigger: boolean) {  }}class Cellphone {  switchRadio(trigger: boolean) {  }}</code></pre><h4 id="可以將兩個共有的抽取為一個-interface"><a href="#可以將兩個共有的抽取為一個-interface" class="headerlink" title="可以將兩個共有的抽取為一個 interface"></a>可以將兩個共有的抽取為一個 interface</h4><ul><li>void =&gt; 代表什麼都不返回</li><li>在class 後面放入  implements 讓類去實現它</li></ul><pre><code class="typescript">interface Radio {  switchRadio(trigger: boolean): void;}class Car implements Radio {  switchRadio(trigger) {    return 123  }}class Cellphone implements Radio {  switchRadio() {  }}</code></pre><h4 id="範例二"><a href="#範例二" class="headerlink" title="範例二"></a>範例二</h4><ul><li>新特性為 檢查電池的容量</li><li>是手機有，但汽車沒有的</li><li>所以新建立一個 interface （檢查battery）<ul><li>此功能只有手機有，所以放在手機的class</li></ul></li></ul><pre><code class="typescript">interface Battery {  checkBatteryStatus(): void;}// 要實現多个介面，我们只需要中間用 都好 隔开即可。class Cellphone implements Radio, Battery {  switchRadio() {  }  checkBatteryStatus() {  }}</code></pre><h4 id="此外-interface-之間有繼承關係"><a href="#此外-interface-之間有繼承關係" class="headerlink" title="此外 interface 之間有繼承關係"></a>此外 interface 之間有繼承關係</h4><ul><li>建立 radioWithBattery 繼承 Radio ，裡面再放入檢查電量的設定</li></ul><pre><code class="typescript">interface radioWithBattery extends Radio {  checkBatteryStatus(): void;}class Cellphone implements radioWithBattery {  switchRadio() {  }  checkBatteryStatus() {  }}</code></pre><p><a href="https://willh.gitbook.io/typescript-tutorial/advanced/class-and-interfaces" target="_blank" rel="noopener">類別與介面</a></p><h2 id="enum-列舉"><a href="#enum-列舉" class="headerlink" title="enum 列舉"></a>enum 列舉</h2><ul><li>常數指執行程序中不會被改變的值，在 JS 中我們一般會用 const 來宣告</li><li>但有些取值是在一定範圍內的一系列常數。<ul><li>如：一周內七天、三原色(紅、黃、藍)、方向(上、下、左、右)<h3 id="範例一"><a href="#範例一" class="headerlink" title="範例一"></a>範例一</h3></li></ul></li><li>數字列舉</li><li>列舉成員會被賦值為從0，開始遞增</li></ul><pre><code class="typescript">// 數字列舉，一个數字列舉可以用 enum 这个關鍵詞來定義，我们定義一系列的方向，然后这里面的值，列舉成员会被赋值为從 0 开始遞增的數字,enum Direction {  Up,  Down,  Left,  Right,}console.log(Direction.Up) //0// 還有一个神奇的點是這個列舉还做了反向映射console.log(Direction[0]) //up</code></pre><p><img src="https://i.imgur.com/VMRV8oM.png" alt=""></p><ul><li>可以手動賦予值</li><li>未手動賦值的列舉項會接著上一個列舉項遞增。</li></ul><pre><code class="typescript">  Up = 10,  Down,  Left,  Right,}console.log(Direction.Down) // 11 ，後面的項目數值會遞增console.log(Direction[0]) //up</code></pre><h3 id="範例二-1"><a href="#範例二-1" class="headerlink" title="範例二"></a>範例二</h3><pre><code class="typescript">// 字符串列舉enum Direction {  Up = &#39;UP&#39;,  Down = &#39;DOWN&#39;,  Left = &#39;LEFT&#39;,  Right = &#39;RIGHT&#39;,}const value = &#39;UP&#39;if (value === Direction.Up) {  console.log(&#39;go up!&#39;)}</code></pre><h3 id="範例三"><a href="#範例三" class="headerlink" title="範例三"></a>範例三</h3><ul><li>常數列舉<ul><li>編譯後的邏輯變少了</li><li>使用常數列舉會內連列舉的用法並且不會將設定的列舉編譯成 JS 程式碼</li></ul></li></ul><pre><code class="typescript">const  enum Direction {  Up = &#39;UP&#39;,  Down = &#39;DOWN&#39;,  Left = &#39;LEFT&#39;,  Right = &#39;RIGHT&#39;,}const value = &#39;UP&#39;if (value === Direction.Up) {  console.log(&#39;go up!&#39;)}</code></pre><p><img src="https://i.imgur.com/Fp2XF0y.png" alt=""></p><hr><h2 id="泛型-Generics"><a href="#泛型-Generics" class="headerlink" title="泛型 Generics"></a>泛型 Generics</h2><ul><li>要解決什麼問題<ul><li>建立函式 echo 參數為 arg ，接著宣告變數傳入參數</li><li>但其中的型別沒有設定</li><li>傳入和返回的型別無法統一</li></ul></li></ul><pre><code class="typescript">function echo(arg) {  return arg}const result = echo(123)// 這時候我們發現了一個問題，我们傳入了數字，但是返回了 any</code></pre><p><img src="https://i.imgur.com/lo6XFH8.png" alt=""></p><ul><li>當在建構 function、internet及Class 時，你會希望這些component都能被重複運用的 Generic(泛型)提供了一個彈性的作法。</li><li>語法是: <code>&lt;T&gt;</code></li></ul><h3 id="範例一-1"><a href="#範例一-1" class="headerlink" title="範例一"></a>範例一</h3><ul><li>泛型（Generics）是指在定義function、internet及Class的时候，不预先指定具體的型別，而在使用的时候再指定型別的一種特性。</li></ul><pre><code class="typescript">function echo&lt;T&gt;(arg: T): T {  return arg}const result = echo(123)</code></pre><p><img src="https://i.imgur.com/X4quRIj.png" alt=""></p><h3 id="範例二-傳入多個"><a href="#範例二-傳入多個" class="headerlink" title="範例二 傳入多個"></a>範例二 傳入多個</h3><pre><code class="typescript">function swap&lt;T, U&gt;(tuple: [T, U]): [U, T] {  return [tuple[1], tuple[0]]}const result = swap([&#39;string&#39;, 123])</code></pre><p><img src="https://i.imgur.com/hJ5IqSY.png" alt=""></p><h3 id="泛型第二部分-约束泛型"><a href="#泛型第二部分-约束泛型" class="headerlink" title="泛型第二部分 - 约束泛型"></a>泛型第二部分 - 约束泛型</h3><ul><li>帶有「限制」的泛型</li></ul><pre><code class="typescript">function echoWithArr&lt;T&gt;(arg: T): T {  console.log(arg.length)  return arg}// 上例中，泛型 T 不一定包含属性 length，我们可以给他傳入任意型別，當然有些不包括 length 属性，那样就會報錯// 我們使用了 extends 約束了泛型 T 必須符合介面 IWithLength 的形狀，也就是必須包含 length 屬性。interface IWithLength {  length: number;}function echoWithLength&lt;T extends IWithLength&gt;(arg: T): T {  console.log(arg.length)  return arg}echoWithLength(&#39;str&#39;)const result3 = echoWithLength({length: 10})const result4 = echoWithLength([1, 2, 3])//此時如果呼叫 loggingIdentity 的時候，傳入的 arg 不包含 length，那麼在編譯階段就會報錯了echoWithLength(7);// index.ts(10,17): error TS2345: Argument of type &#39;7&#39; is not assignable to parameter of type &#39;Lengthwise&#39;</code></pre><h3 id="泛型第三部分-泛型在-class-和-interface-中的使用"><a href="#泛型第三部分-泛型在-class-和-interface-中的使用" class="headerlink" title="泛型第三部分 - 泛型在 class 和 interface 中的使用"></a>泛型第三部分 - 泛型在 class 和 interface 中的使用</h3><ol><li>泛型在 class 的使用</li></ol><ul><li>在第一個程式中存在一个问题，它允許你向 Queue 中添加任何型別的數據，當然，當數據被彈出隊列时，也可以是任意類型</li><li>在下方的範例中，看起来可以向隊列中添加 string 型別的數據，但是那麼在使用的過程中，就會出現無法捕捉的錯誤</li></ul><pre><code class="typescript">class Queue {  private data = [];  push(item) {    return this.data.push(item)  }  pop() {    return this.data.shift()  }}const queue = new Queue()queue.push(1)queue.push(&#39;str&#39;)console.log(queue.pop().toFixed())console.log(queue.pop().toFixed())</code></pre><pre><code class="typescript">class Queue&lt;T&gt; {  private data = [];  push(item: T) {    return this.data.push(item)  }  pop(): T {    return this.data.shift()  }}const queue = new Queue&lt;number&gt;()</code></pre><ol start="2"><li>泛型在  interface 中的使用</li></ol><ul><li>之前提過可以使用介面的方式來定義一個函式需要符合的形狀</li><li>當然也可以使用含有泛型的介面來定義函式的形狀：</li></ul><pre><code class="typescript">//泛型和 interfaceinterface KeyPair&lt;T, U&gt; {  key: T;  value: U;}let kp1: KeyPair&lt;number, string&gt; = { key: 1, value: &quot;str&quot;}let kp2: KeyPair&lt;string, number&gt; = { key: &quot;str&quot;, value: 123}let arr:number[] = [1,2,3];let arrTwo:Array&lt;number&gt; = [1,2,3]</code></pre><p><img src="https://i.imgur.com/6GXBwCI.png" alt=""></p><p>interface 搭配泛型之后，可以靈活的返回不同的型別</p><ul><li><p>創建一个拥有特定型別的容器，class 和 泛型 仿佛给一个容器貼上標籤一样</p></li><li><p>泛型就好像一个可變的參數，在用的时候傳入，生成这個不同型別的一个容器，</p></li><li><p>上個部分的用它来靈活的约束参数的型別，不需要參數是一个特别死板的型別，不希望他是一个特定 string、number 型別，我要傳入的参數必须有某某屬性、某某方法，否則就會報錯。</p></li><li><p>在函式使用的时候，函式的这个型別推斷，不會進入到函式中，所以使用表達式，没法明確建立型別的绑定，用泛型可以让我们打破這個鴻溝，這個时候就可以返回它傳入的類型。</p><h2 id="Type-Aliases"><a href="#Type-Aliases" class="headerlink" title="Type Aliases"></a>Type Aliases</h2></li><li><p>就是给型別起一個别名，讓它可以更方便的被重用。</p></li></ul><pre><code class="typescript">let sum: (x: number, y: number) =&gt; numberconst result = sum(1,2)type PlusType = (x: number, y: number) =&gt; numberlet sum2: PlusType// 支持聯合type StrOrNumber = string | numberlet result2: StrOrNumber = &#39;123&#39;result2 = 123 //沒有錯// 字符串字面量 ，類似在列舉的常數變量type Directions = &#39;Up&#39; | &#39;Down&#39; | &#39;Left&#39; | &#39;Right&#39;// 使toWhere 這個變量為 Direction 類型let toWhere: Directions = &#39;Up&#39;</code></pre><ul><li>我們使用 type 定了一個字串字面量型別 EventNames，它只能取三種字串中的一種。<br>注意，型別別名與字串字面量型別都是使用 type 進行定義。</li></ul><pre><code class="typescript">type EventNames = &#39;click&#39; | &#39;scroll&#39; | &#39;mousemove&#39;;function handleEvent(ele: Element, event: EventNames) {    // do something}handleEvent(document.getElementById(&#39;hello&#39;), &#39;scroll&#39;);  // 沒問題handleEvent(document.getElementById(&#39;world&#39;), &#39;dbclick&#39;); // 報錯，event 不能為 &#39;dbclick&#39;// index.ts(7,47): error TS2345: Argument of type &#39;&quot;dbclick&quot;&#39; is not assignable to parameter of type &#39;EventNames&#39;.</code></pre><h2 id="Intersection-Types"><a href="#Intersection-Types" class="headerlink" title="Intersection Types"></a>Intersection Types</h2><ul><li>使用 <code>&amp;</code> 符號</li><li>經過上面的 type 使 IName 就有了 name 和 age兩個屬性在裡面<ul><li>和interface 的 extends 有點類似，都是為了實現物件形狀組合和擴展</li></ul></li></ul><pre><code class="typescript">interface IName  {  name: string}type IPerson = IName &amp; { age: number }// 經過上面的 type 使 IName 就有了 name 和 age兩個屬性在裡面let person: IPerson = { name: &#39;hello&#39;, age: 12}</code></pre><p>什麼时候用介面，什麼时候用 Type Aliases：</p><ul><li>interface 是 docker typing 的實現方式，是一種獨特類型，和extends class  implememts 有關的用interface ，</li><li>和交叉，聯合型別的有關的用 Type Aliases；</li></ul><h2 id="內建物件"><a href="#內建物件" class="headerlink" title="內建物件"></a>內建物件</h2><h3 id="DOM-和-BOM-的內建物件"><a href="#DOM-和-BOM-的內建物件" class="headerlink" title="DOM 和 BOM 的內建物件"></a>DOM 和 BOM 的內建物件</h3><p>DOM 和 BOM 提供的內建物件有：<br>Document、HTMLElement、Event、NodeList 等。<br>TypeScript 中會經常用到這些型別：</p><pre><code class="typescript">let body: HTMLElement = document.body;let allDiv: NodeList = document.querySelectorAll(&#39;div&#39;);document.addEventListener(&#39;click&#39;, function(e: MouseEvent) {  // Do something});</code></pre><h3 id="ECMAScript-的內建物件"><a href="#ECMAScript-的內建物件" class="headerlink" title="ECMAScript 的內建物件"></a>ECMAScript 的內建物件</h3><ul><li>Boolean、Error、Date、RegExp 等。</li></ul><pre><code class="typescript">let b: Boolean = new Boolean(1);let e: Error = new Error(&#39;Error occurred&#39;);let d: Date = new Date();let r: RegExp = /[a-z]/;</code></pre><p><a href="https://github.com/Microsoft/TypeScript/tree/main/src/lib">TypeScript 內置</a></p><h2 id="Utility-Types"><a href="#Utility-Types" class="headerlink" title="Utility Types"></a>Utility Types</h2><p><a href="https://www.typescriptlang.org/docs/handbook/utility-types.html" target="_blank" rel="noopener">官方</a><br>Typescript 還提供了一些功能性，帮助性的型別，這些型別，大家在 JS 的世界是看不到的，這些型別叫做 utility types，提供一些簡潔明快而且非常方便的功能。</p><ul><li>使用  Partial</li><li>Omit</li></ul><pre><code class="typescript">// partial，它可以把傳入的型別都變成可選interface IPerson {  name: string  age: number}let viking: IPerson = { name: &#39;viking&#39;, age: 20 }type IPartial = Partial&lt;IPerson&gt;let viking2: IPartial = { } //可以都不傳，也不會報錯// Omit，它返回的型別可以忽略傳入型別的某个屬性// 以下範例 將 name 忽略掉type IOmit = Omit&lt;IPerson, &#39;name&#39;&gt;let viking3: IOmit = { age: 20 }</code></pre><p>資料來源：</p><ol><li>線上課程：實戰 Vue3.0(正式版) + TS </li><li><a href="https://willh.gitbook.io/typescript-tutorial/" target="_blank" rel="noopener">TypeScript 新手指南</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/xGK5aDO.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;要熟悉 TypeScript 的型別訂定，並不容易，而且撰寫時也會花費較多的時間，但好處是減少程式碼的錯誤，也讓協作者更容易解讀對方撰寫的程式碼。&lt;br&gt;萬事</summary>
      
    
    
    
    
    <category term="TypeScript" scheme="https://github.com/Eva813/Eva813.github.io.git/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript 基礎介紹 (1)</title>
    <link href="https://github.com/Eva813/Eva813.github.io.git/2021/11/27/TS-1/"/>
    <id>https://github.com/Eva813/Eva813.github.io.git/2021/11/27/TS-1/</id>
    <published>2021-11-27T00:44:33.000Z</published>
    <updated>2022-01-08T08:42:17.900Z</updated>
    
    <content type="html"><![CDATA[<p>因為工作需求，有需多缺乏的技能需要補齊，TypeScript 就是其中一項。<br>上班看不懂的時候邊查詢，空閒時間再來上課不足不懂的知識點，但還是得透過文章的整理來好好消化一下！<br>既然要開始介紹 TypeScript 就先來說說使用它的原因吧。</p><h2 id="為什麼使用-TypeScript"><a href="#為什麼使用-TypeScript" class="headerlink" title="為什麼使用 TypeScript"></a>為什麼使用 TypeScript</h2><ul><li><p>程式語言中，有區分強型別和弱型別兩種類型。</p></li><li><p>而 JavaScript 是弱型別語言。</p></li><li><p>在 JavaScript 中，他會自己判斷應該執行的型別。自行做[型別自動轉換]</p></li><li><p>在快速開發時，很有可能引發一些預期之外的錯誤，相當不利於多人協同開發。</p><ul><li>優點：寫法彈性。</li><li>缺點：無法在開發時期檢查型別。</li></ul></li><li><p>依據上述的問題，所以使用 TypeScript</p></li></ul><ol><li>使程式碼更容易理解 （如函式需傳入的參數可以明確設定型別）</li><li>減少程式碼撰寫的錯誤</li><li>可以完全兼容JavaScript，此外能與 ES6 完美結合，並提供更多支援寫法。</li></ol><h2 id="安裝介紹"><a href="#安裝介紹" class="headerlink" title="安裝介紹"></a>安裝介紹</h2><ul><li>就是直接到官方網站查看，依需求安裝<br><img src="https://i.imgur.com/wfMqk4w.png" alt=""></li></ul><p><code>npm install -g typescript</code></p><ul><li>檢查版本<br><code>tsc -v</code></li></ul><h2 id="型別介紹"><a href="#型別介紹" class="headerlink" title="型別介紹"></a>型別介紹</h2><p>從 JavaScript 型別分類開始</p><h3 id="字串-string"><a href="#字串-string" class="headerlink" title="字串 string"></a>字串 string</h3><ul><li>和ES6一樣，可以使用[字串樣板 Template Literals]<pre><code class="TypeScript">let firstName:string = &#39;NaNa&#39;let message: string = `Hello,${firstName}`</code></pre></li></ul><pre><code>### 布林值 boolean布林值是最基礎的資料型別，在 TypeScript 中，使用 boolean 定義布林值型別： ```typescriptlet isDonw:boolean = false </code></pre><p>注意：使用建構函式 Boolean 建立的物件不是布林值：</p><ul><li>事實上 new Boolean() 返回的是一個 Boolean 物件<pre><code class="JavaScript">let createdByNewBoolean: boolean = new Boolean(1);</code></pre></li></ul><p>// Type ‘Boolean’ is not assignable to type ‘boolean’.<br>//   ‘boolean’ is a primitive, but ‘Boolean’ is a wrapper object. Prefer using ‘boolean’ when possible.</p><pre><code></code></pre><p>在 TypeScript 中，boolean 是 JavaScript 中的基本型別，而 Boolean 是 JavaScript 中的建構函式。</p><pre><code>### 數值 number```TypeScriptlet age:number = 10let notANumber: number = NaN;let infinityNumber: number = Infinity;</code></pre><h3 id="Null-和-Undefined"><a href="#Null-和-Undefined" class="headerlink" title="Null 和 Undefined"></a>Null 和 Undefined</h3><ul><li>與 void 的區別是，undefined 和 null 是所有型別的子型別<ul><li>unfefined 可以賦值給number類型的變數</li><li>陣列被赋值為 undefined 或 null 不会报错</li><li><code>let num:number = undefined</code></li></ul></li></ul><pre><code class="TypeScript">let u: undefined = undefined;let n: null = null;// 這樣也不會報錯let u: undefined;let num: number = u;</code></pre><h3 id="void"><a href="#void" class="headerlink" title="void"></a>void</h3><ul><li>通常用在當函式沒有回傳值時。<br><img src="https://i.imgur.com/OOnpUUH.png" alt=""></li><li>而 void 型別的變數不能賦值給 number 型別的變數：<pre><code class="JavaScript">let u: void;let num: number = u;</code></pre></li></ul><p>// Type ‘void’ is not assignable to type ‘number’.</p><pre><code>### any* 在任意值上任何属性都是允許的    * 當有明確型別時，應避免使用 any     * 因為 any 可以任意調用方法和屬性，很有可能出現錯誤（就喪失類型檢查的意義）如果是 any 型別，則允許被賦值為任意型別```TypeScriptlet myFavoriteNumber: any = &#39;seven&#39;;myFavoriteNumber = 7;</code></pre><h4 id="未宣告型別的變數"><a href="#未宣告型別的變數" class="headerlink" title="未宣告型別的變數"></a>未宣告型別的變數</h4><p>變數如果在宣告的時候，未指定其型別，那麼它會被識別為任意值型別：</p><pre><code class="JavaScript">let something;something = &#39;seven&#39;;something = 7;something.setName(&#39;Tom&#39;);</code></pre><h3 id="陣列-Array-與-元組-Tuple"><a href="#陣列-Array-與-元組-Tuple" class="headerlink" title="陣列 Array 與 元組 Tuple"></a>陣列 Array 與 元組 Tuple</h3><h4 id="陣列"><a href="#陣列" class="headerlink" title="陣列"></a>陣列</h4><ol><li>在想宣告的型別後面加上[]，宣告為某個型別的Array<pre><code class="TypeScript">let idList:number[] = [1,2,3]</code></pre></li><li>使用陣列泛型，Array &lt;元素型別&gt;<pre><code class="TypeScript">let list:Array&lt;number&gt; = [1,2,3]</code></pre></li></ol><ul><li>注意，當已經宣告這是個數字陣列<ul><li>要 push 字串進去，會出現錯誤<pre><code class="TypeScript">let list:Array&lt;number&gt; = [1,2,3]list.push(&quot;4&quot;)</code></pre><img src="https://i.imgur.com/bzszCFn.png" alt=""><h3 id="元組-Tuple"><a href="#元組-Tuple" class="headerlink" title="元組 Tuple"></a>元組 Tuple</h3></li><li>剛剛的陣列將同一類型的數據放在一起，但是，想加入不同型別的數據怎麼辦？</li><li>表示方式與陣列相似，將型別寫在<code>[]</code></li><li>有固定長度和元素型別的陣列<pre><code class="typescript">// 表示方式和陣列非常相似，只不过它将型別寫在了里面 這時會對每一項產生了限定的作用let user: [string, number] = [&#39;viking&#39;, 20]//但是当我们少寫一項 就會報錯，同樣多寫也會報錯user = [&#39;molly&#39;, 20, true]</code></pre><img src="https://i.imgur.com/MfhvOd7.png" alt=""></li></ul></li></ul><p><a href="https://willh.gitbook.io/typescript-tutorial/advanced/tuple#can-kao" target="_blank" rel="noopener">元組</a></p><h3 id="物件的型別——介面-Interface"><a href="#物件的型別——介面-Interface" class="headerlink" title="物件的型別——介面 (Interface)"></a>物件的型別——介面 (Interface)</h3><ul><li>Interface 可以用來定義物件，還有由物件所延伸的型別（例如，陣列、函式）</li><li><code>age?: number;</code> 在該屬性後面加上 <code>?</code> 表示為可選屬性 ，也就是在宣告新的物件時，可以彈性加入或不加入age （也不會報錯）</li></ul><pre><code class="typescript">// 我们定義了一個介面 Personinterface Person {  name: string;  age: number;}// 接着定义了一个變數 NaNa，它的型別是 Person。//这样，我们就约束了 NaNa 的形狀必須和介面 Person 一致。let NaNa: Person ={  name: &#39;NaNa&#39;,  age: 20}//有时我们希望不要完全匹配一个形狀，那么可以用可選屬性：interface Person {    name: string;    age?: number;}let NaNa: Person = {    name: &#39;NaNa&#39;}</code></pre><h3 id="唯讀屬性"><a href="#唯讀屬性" class="headerlink" title="唯讀屬性"></a>唯讀屬性</h3><ul><li>readonly 是用在屬性上面</li><li>希望物件中的一些欄位只能在建立的時候被賦值，那麼可以用 readonly 定義唯讀屬性</li></ul><pre><code class="typescript">interface Person {  readonly id: number;  name: string;  age?: number;}// 建立物件let Vic: Person ={  id:1,    name: &#39;Vic&#39;,  age: 20}//不能去修改id    Vic.id = 9527</code></pre><h3 id="函式型別"><a href="#函式型別" class="headerlink" title="函式型別"></a>函式型別</h3><ul><li>函式可以作為參數、可以存入陣列，可以被另外一個函式返回、可以被賦值另外一個變數</li><li>函式是由兩部分構成，一個是輸入(通過不同參數來實現)，二為輸出(就是函數的返回結果)<h4 id="例子一"><a href="#例子一" class="headerlink" title="例子一"></a>例子一</h4></li><li>設定參數型別、返回的型別</li><li>若參數設定了 x、y兩個，也就只能放入兩個<pre><code class="typescript">// 来到我们的第一个例子，约定输入，约定输出function add(x: number, y: number): number {return x + y}</code></pre><img src="https://i.imgur.com/RLOECvw.png" alt=""></li></ul><h4 id="例子二"><a href="#例子二" class="headerlink" title="例子二"></a>例子二</h4><ul><li>也可以設定可選參數</li><li>在 z? 表示 z 可有可無</li></ul><pre><code class="typescript">// 可选参数function add(x: number, y: number, z?: number): number {  if (typeof z === &#39;number&#39;) {    return x + y + z  } else {    return x + y  }}</code></pre><ul><li>而在可選參數後面不可以再添加確定參數<br><img src="https://i.imgur.com/qzQRT0r.png" alt=""></li></ul><h4 id="例外說明：引數預設值"><a href="#例外說明：引數預設值" class="headerlink" title="例外說明：引數預設值"></a>例外說明：引數預設值</h4><ul><li>在 ES6 中，我們允許給函式的引數新增預設值，TypeScript 會將添加了預設值的引數識別為可選引數：</li></ul><pre><code class="typescript">function buildName(firstName: string, lastName: string = &#39;Cat&#39;) {    return firstName + &#39; &#39; + lastName;}let tomcat = buildName(&#39;Tom&#39;, &#39;Cat&#39;);let tom = buildName(&#39;Tom&#39;); // 因為 lastName 添加了預設值，識別為可選引數</code></pre><p>此時就不受「可選引數必須接在必需引數後面」的限制了：</p><pre><code class="typescript">function buildName(firstName: string = &#39;Tom&#39;, lastName: string) {    return firstName + &#39; &#39; + lastName;}let tomcat = buildName(&#39;Tom&#39;, &#39;Cat&#39;);let cat = buildName(undefined, &#39;Cat&#39;);</code></pre><h4 id="例子三"><a href="#例子三" class="headerlink" title="例子三"></a>例子三</h4><ul><li>函式的表達式</li></ul><pre><code class="typescript">const add = (x: number, y: number, z?: number): number =&gt; {  if (typeof z === &#39;number&#39;) {    return x + y + z  } else {    return x + y  }}// 函式本身的类型const add2: (x: number, y: number, z?:number) =&gt; number = add</code></pre><ul><li>函式不只輸入、輸出有類型，本身也有類型<br><img src="https://i.imgur.com/f2Ym2Zb.png" alt=""></li><li>將 add2 賦予 string 會出錯誤</li><li>所以須聲明一模一樣的 <code>const add2: (x: number, y: number, z?:number) =&gt; number = add</code><br><img src="https://i.imgur.com/FvS1OvL.png" alt=""></li></ul><h4 id="例子四"><a href="#例子四" class="headerlink" title="例子四"></a>例子四</h4><ul><li>使用 interface (單純定義函式的 Interface)</li></ul><pre><code class="typescript">// interface 描述函数类型const sum = (x: number, y: number) =&gt; {  return x + y}interface ISum {  (x: number, y: number): number}const sum2: ISum = sum</code></pre><ul><li>另一個範例</li></ul><pre><code class="typescript">interface SearchFunc {    (source: string, subString: string): boolean;}let mySearch: SearchFunc;mySearch = function(source: string, subString: string) {    return source.search(subString) !== -1;}</code></pre><hr><h2 id="型別推論（Type-Inference）-聯合型別（Union-Types）-型別斷言（Type-Assertion）"><a href="#型別推論（Type-Inference）-聯合型別（Union-Types）-型別斷言（Type-Assertion）" class="headerlink" title="型別推論（Type Inference）\ 聯合型別（Union Types） \ 型別斷言（Type Assertion）"></a>型別推論（Type Inference）\ 聯合型別（Union Types） \ 型別斷言（Type Assertion）</h2><h3 id="型別推論（Type-Inference）"><a href="#型別推論（Type-Inference）" class="headerlink" title="型別推論（Type Inference）"></a>型別推論（Type Inference）</h3><ul><li>可以推論出我們賦值過程中，這個變數應該是什麼類型的</li><li>TS 會在沒有明確指定型別的時候，推測出型別<br><img src="https://i.imgur.com/280zYEs.png" alt=""></li></ul><h3 id="聯合型別（Union-Types）"><a href="#聯合型別（Union-Types）" class="headerlink" title="聯合型別（Union Types）"></a>聯合型別（Union Types）</h3><ul><li>用分隔符號</li><li>當 TypeScript 不确定一个聯合型別的變數到底是哪個型別的时候，我们只能使用此聯合型別的所有型別裡共有的屬性或方法</li></ul><pre><code class="TypeScript">// 允許 numberOrString 的型別是 string 或者 number，但是不能是其他型別。let numberOrString: number | string // 而在使用此聯合型別的所有型別里共有的屬性性或方法：numberOrString.length  //會報錯 （只有 string 適用）numberOrString.toString() //string 和 number 的共同屬性是沒問題//若放在函式定義型別function getLength(something: string | number): number {    return something.length;}// index.ts(2,22): error TS2339: Property &#39;length&#39; does not exist on type &#39;string | number&#39;.//   Property &#39;length&#39; does not exist on type &#39;number&#39;.</code></pre><ul><li>聯合型別的變數在被賦值的時候，會根據型別推論的規則推斷出一個型別：</li></ul><pre><code class="TypeScript">let numberOrString: string | number;numberOrString = &#39;seven&#39;;console.log(numberOrString.length); // 5numberOrString = 7;console.log(numberOrString.length); // 編譯時報錯// index.ts(5,30): error TS2339: Property &#39;length&#39; does not exist on type &#39;number&#39;.</code></pre><p>上例中，第二行的 numberOrString 被推斷成了 string，存取它的 length 屬性不會報錯。<br>而第四行的 numberOrString 被推斷成了 number，存取它的 length 屬性時就報錯了。</p><ul><li>type guard </li><li>當遇到聯合類型，可以使用條件語句，自動幫你縮小型別範圍</li></ul><pre><code class="javascript">// typescript 在不同的条件分支里面，智能的缩小了范围，这样我们代码出错的几率就大大的降低了。function getLength2(input: string | number): number {  if (typeof input === &#39;string&#39;) {    return input.length  } else {    return input.toString().length  }}</code></pre><h3 id="型別斷言（Type-Assertion）"><a href="#型別斷言（Type-Assertion）" class="headerlink" title="型別斷言（Type Assertion）"></a>型別斷言（Type Assertion）</h3><ul><li>開發者比 TS 更了解編寫的程式碼。因此，TS 允許開發者覆蓋它的推論，這樣的機制稱為「型別斷言」。</li></ul><pre><code class="typescript">// 这里我们可以用 as 關鍵字，告诉typescript 这里我把它看作是一個 string，你可以给他用 string 的方法。function getLength(input: string | number): number {  const str = input as string  if (str.length) {    return str.length  } else {    const number = input as number    return number.toString().length  }}</code></pre><ul><li>型別斷言不是型別轉換，斷言成一個聯合型別中不存在的型別是不允許的：</li></ul><pre><code class="TypeScript">function toBoolean(something: string | number): boolean {    return &lt;boolean&gt;something;}// index.ts(2,10): error TS2352: Type &#39;string | number&#39; cannot be converted to type &#39;boolean&#39;.//   Type &#39;number&#39; is not comparable to type &#39;boolean&#39;.</code></pre><p>基礎型別先介紹到這裡，下篇將介紹一些進階用法～</p><p>資料來源：</p><ol><li>線上課程：實戰 Vue3.0(正式版) + TS </li><li><a href="https://willh.gitbook.io/typescript-tutorial/" target="_blank" rel="noopener">TypeScript 新手指南</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;因為工作需求，有需多缺乏的技能需要補齊，TypeScript 就是其中一項。&lt;br&gt;上班看不懂的時候邊查詢，空閒時間再來上課不足不懂的知識點，但還是得透過文章的整理來好好消化一下！&lt;br&gt;既然要開始介紹 TypeScript 就先來說說使用它的原因吧。&lt;/p&gt;
&lt;h2 id</summary>
      
    
    
    
    
    <category term="TypeScript" scheme="https://github.com/Eva813/Eva813.github.io.git/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>講講幾個 Nuxt.js 重要觀念</title>
    <link href="https://github.com/Eva813/Eva813.github.io.git/2021/11/10/Nuxt-2/"/>
    <id>https://github.com/Eva813/Eva813.github.io.git/2021/11/10/Nuxt-2/</id>
    <published>2021-11-10T01:58:39.000Z</published>
    <updated>2021-11-28T08:30:57.197Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/4LE0BUW.png" alt=""></p><p>在使用 Nuxt.js 開啟專案後，會自動生成不少文件檔案，今天就來介紹幾樣基礎設定以及檔案的運用吧！</p><h2 id="了解-Nuxt-路徑引用規則"><a href="#了解-Nuxt-路徑引用規則" class="headerlink" title="了解 Nuxt 路徑引用規則"></a>了解 Nuxt 路徑引用規則</h2><ul><li><code>~</code>以及<code>@</code> ：根目錄 <ul><li>(注意：nuxt.conf.js、非 nuxt 結構的 js 檔 除外)</li></ul></li><li>波浪或小老鼠 :從根目錄 搜尋assets 資料夾<br><img src="https://i.imgur.com/CNUlrGz.png" alt=""><br>以下也一樣<br><code>import test from &quot;@/assets/js/test.js&quot;</code></li></ul><ol start="2"><li><code>./</code>：自己的目錄</li></ol><ul><li>nuxt.conf.js、以及非 nuxt 結構要這樣撰寫<br><img src="https://i.imgur.com/2qLJ5te.png" alt=""></li></ul><ol start="3"><li>放在 static 資料夾裡的引用方式(直接斜線)<code>&lt;img src=&quot;/demo.png&quot; alt=&quot;&quot;&gt;</code></li><li>補充：<br><a href="https://docs.google.com/presentation/d/15q4Vsl3I6Bf5F1f2LdNj_OvF5fcrl7aPv5aA1E39Kjw/edit#slide=id.g813fdce503_0_0" target="_blank" rel="noopener">2.4 nuxt 圖片處理 - webpack 相關設定</a></li></ol><ul><li><p>在asset 加入 img 資料夾(將圖片放在這裡)<br><code>&lt;img src=&quot;@/assets/img/demo.png&quot; alt=&quot;&quot;&gt;</code><br><img src="https://i.imgur.com/iSsni0c.png" alt=""></p></li><li><p>放在css作背景圖<br>  *<code>background: url(~assets/img/demo.png);  //nuxt css 引入圖片不能加斜線</code></p><ul><li>也不能將波浪改為@<br>:::info<br>原本波浪斜線方式:<br><code>background: url(~/assets/img/demo.png);</code><br>:::<br><img src="https://i.imgur.com/ekDF3vK.png" alt=""></li></ul></li></ul><h2 id="nuxt-config-js-設定"><a href="#nuxt-config-js-設定" class="headerlink" title="nuxt.config.js 設定"></a>nuxt.config.js 設定</h2><ul><li>vue cli3 設定vue 專案是透過是 main.js/ vue.config.js 這兩隻檔案。<ul><li>main.js 為程式的進入點</li></ul></li><li>nuxt 則統一用 nuxt.conf.js 做為設定。<ul><li>要編輯這份文件達到專案需求</li><li>如 wedpack 是放在 build</li></ul></li></ul><p><img src="https://i.imgur.com/aLpoUcR.png" alt=""></p><ul><li>此外在此檔案可以做標題、引入 CDN 等基礎設置<ul><li>head,meta 可以做表頭的設定</li><li>script 可以引入 JS 的檔案或 CDN 資源</li></ul></li><li>css 全域設定，也同樣放在這裡<ul><li><a href="https://nuxtjs.org/docs/configuration-glossary/configuration-css/" target="_blank" rel="noopener">The css property</a><pre><code class="javascript">css: [&#39;~/assets/scss/demo.scss&#39;],</code></pre></li></ul></li></ul><pre><code>```javascriptexport default {  // Global page headers: https://go.nuxtjs.dev/config-head  head: {    title: &#39;myNuxt&#39;,    htmlAttrs: {      lang: &#39;en&#39;    },    meta: [      { charset: &#39;utf-8&#39; },      { name: &#39;viewport&#39;, content: &#39;width=device-width, initial-scale=1&#39; },      { hid: &#39;description&#39;, name: &#39;description&#39;, content: &#39;&#39; },      { name: &#39;format-detection&#39;, content: &#39;網站前後端、網頁設計、程式語言網站&#39; }    ],    link: [      { rel: &#39;icon&#39;, type: &#39;image/x-icon&#39;, href: &#39;/favicon.ico&#39; }    ],    script:    [      { src: &quot;/jquery.min.js&quot;},      { src: &quot;https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/js/all.js&quot; }    ]  },</code></pre><p><img src="https://i.imgur.com/krqrhq8.png" alt=""></p><h3 id="引用-static-靜態資源的檔案"><a href="#引用-static-靜態資源的檔案" class="headerlink" title="引用 static 靜態資源的檔案"></a>引用 static 靜態資源的檔案</h3><ul><li>static資料夾:靜態資源資料夾<ul><li>其中要連接該檔案路徑要用斜線</li><li>這裡面的檔案不會被打包和優化<br><img src="https://i.imgur.com/46ebZ9F.png" alt=""></li></ul></li></ul><h2 id="套件安裝"><a href="#套件安裝" class="headerlink" title="套件安裝!"></a>套件安裝!</h2><ol><li>最簡單方式是使用打包後的 CDN 或 js 檔案 <ul><li>在head 的 script 放入 CDN</li></ul></li><li>使用 <a href="https://nuxtjs.org/docs/directory-structure/plugins/" target="_blank" rel="noopener">nuxt plugins</a> 自包 js 套件 或 vue 套件 → 較麻煩</li><li>使用 <a href="https://zh.nuxtjs.org/guide/modules/" target="_blank" rel="noopener">nuxt modules</a> 來引入套件<ul><li>套件較少</li></ul></li></ol><ul><li>nuxt module 主要是將 plugin 在封裝一層出來。(就是 nuxt 專有的套件)，如果對安裝 plugins 沒把握，就找有 nuxt modules 的套件來安裝。</li></ul><h3 id="練習1包裝一般的-vue-套件"><a href="#練習1包裝一般的-vue-套件" class="headerlink" title="練習1包裝一般的 vue 套件"></a>練習1包裝一般的 vue 套件</h3><p> <a href="https://www.npmjs.com/package/vuejs-datepicker" target="_blank" rel="noopener">vuejs-datepicker</a></p><p>1、npm install vuejs-datepicker</p><ul><li>若直接依照官網來安裝，並在檔案引入會發生錯誤</li><li>所以 install 完之後要再執行下面動作<br>2、plugins 新增一個檔案：datepicker.js → 撰寫套件</li><li>在 plugins 資料夾，新增檔案<pre><code class="javascript">import Vue from &#39;vue&#39;import Datepicker from &#39;vuejs-datepicker&#39;;</code></pre></li></ul><p>Vue.component(‘Datepicker’, Datepicker)</p><pre><code>![](https://i.imgur.com/l0kYSwT.png)3、nuxt.config.js 安裝 plugin → 可以設定該套件只在 客戶端 運作* 可以將插件安裝在客戶端或是 server 端```javascript{ src: &#39;~/plugins/datepicker.js&#39;, mode: &#39;client&#39; },</code></pre><ul><li>要使用時，再放入頁面<br><img src="https://i.imgur.com/gNNLJ2O.png" alt=""><h3 id="練習2-安裝一般的-js-套件"><a href="#練習2-安裝一般的-js-套件" class="headerlink" title="練習2 安裝一般的 js 套件"></a>練習2 安裝一般的 js 套件</h3><a href="https://greensock.com/docs/v3/Installation" target="_blank" rel="noopener">GSAP</a></li></ul><ol><li>npm install gsap</li><li>plugins 新增一個檔案：gsap.js → 撰寫套件<pre><code class="javascript">import Vue from &#39;vue&#39;import gsap from &quot;gsap&quot;;</code></pre></li></ol><p>Vue.prototype.$gsap = gsap</p><pre><code>![](https://i.imgur.com/t3G7UGN.png)3. nuxt.config.js 安裝 plugin```javascript plugins: [    { src: &#39;~/plugins/gsap.js&#39;, mode: &#39;client&#39; },  ],</code></pre><ul><li><code>create()</code> 會在前端執行\後端執行</li></ul><h3 id="練習3-nuxt-安裝"><a href="#練習3-nuxt-安裝" class="headerlink" title="練習3 nuxt 安裝"></a>練習3 nuxt 安裝</h3><p><a href="https://axios.nuxtjs.org/" target="_blank" rel="noopener">axios modules</a></p><ol><li>npm install @nuxtjs/axios</li><li>plugins 新增一個檔案：axios.js </li></ol><ul><li><p>如同前面的練習，到  nuxt.config.js</p><pre><code class="javascript">modules: [  &#39;@nuxtjs/axios&#39;,],</code></pre></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/4LE0BUW.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在使用 Nuxt.js 開啟專案後，會自動生成不少文件檔案，今天就來介紹幾樣基礎設定以及檔案的運用吧！&lt;/p&gt;
&lt;h2 id=&quot;了解-Nuxt-路徑引用規則&quot;</summary>
      
    
    
    
    
    <category term="Nuxt" scheme="https://github.com/Eva813/Eva813.github.io.git/tags/Nuxt/"/>
    
  </entry>
  
  <entry>
    <title>為何要學習 Nuxt.js ？</title>
    <link href="https://github.com/Eva813/Eva813.github.io.git/2021/11/10/Nuxt-1/"/>
    <id>https://github.com/Eva813/Eva813.github.io.git/2021/11/10/Nuxt-1/</id>
    <published>2021-11-10T01:30:01.000Z</published>
    <updated>2021-11-14T01:59:20.651Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/4LE0BUW.png" alt=""></p><p>製作網站，都會希望自己的網站可以被搜尋引擎找得到，並且可以在使用者輸入關鍵字後，可以在頭幾個項目中就能關注到自己的網站！<br>而在使用 Vue.js 框架，因為是使用 SPA 架構無法做到 SEO (search engine optimization) 的效果，別人無法輕易的找到我們所製作的網站。<br>今天要介紹的 Nuxt.js 是一個基於 Vue.js、用來處理伺服器渲染（Server-side rendering(SSR)）的框架。透過 SSR 我們可以做到更好的 SEO 效果。</p><p>本文首要任務： 認識 SPA 與 SSR 的差異</p><h2 id="SPA-Single-Page-Application-架構"><a href="#SPA-Single-Page-Application-架構" class="headerlink" title="SPA (Single Page Application) 架構"></a>SPA (Single Page Application) 架構</h2><ul><li>讓一些後端的工作，分擔到前端 (如： router 設定)</li><li>流程為：使用者開了瀏覽器 -&gt; 向後端server要資料，因為改為SPA 架構，所以提供的會是SPA 首頁（會載入JS\編譯好的CSS\一頁空殼的HTML網頁），此空殼經過 Vue 編譯產出 DOM 物件，讓瀏覽器印出。</li><li>讓回應速度更快，使用者在轉換頁面時得到更好的體驗。<ul><li>SPA（Single Page Application）意思是僅有一個頁面的應用程式，也就是說網頁不需跳轉頁面就可以達到基本的建立、讀取、修改、刪除資料功能。</li></ul></li><li>後端負責調整API 邏輯\架構<h3 id="SPA-缺點"><a href="#SPA-缺點" class="headerlink" title="SPA 缺點"></a>SPA 缺點</h3></li><li>SEO差(SPA 一開始吐的是空殼)，GOOGLE 爬不到頁面資訊</li><li>SMO差，FB爬不到頁面資訊</li><li>首屏速度慢，一開始畫面會空白或閃爍<ul><li>發出請求資訊到實際上呈現完整頁面時間</li></ul></li></ul><h2 id="SSR-Server-Side-Rendering"><a href="#SSR-Server-Side-Rendering" class="headerlink" title="SSR (Server Side Rendering)"></a>SSR (Server Side Rendering)</h2><p>流程為：使用者開了瀏覽器 -&gt; 向後端server要資料，因為改為SSR，所以會提供一整個頁面(不會是畫面空白閃爍)</p><ul><li>希望頁面可以將網頁整個東西呈現，並讓搜尋引擎查得到</li><li>處理 SEO(針對搜尋引擎)</li></ul><ul><li>title</li><li>meta tag<ul><li>全域 <code>&lt;head&gt;</code> 設定</li><li>單頁 <code>&lt;head&gt;</code> 設定 </li></ul></li><li>description</li></ul><ul><li>處理 SMO (針對 Social media)<ul><li>twitter\youtube\Line…<h3 id="有更多的彈性設定"><a href="#有更多的彈性設定" class="headerlink" title="有更多的彈性設定"></a>有更多的彈性設定</h3><h4 id="Nuxt-有三種模式，可以幫你解決問題"><a href="#Nuxt-有三種模式，可以幫你解決問題" class="headerlink" title="Nuxt 有三種模式，可以幫你解決問題"></a>Nuxt 有三種模式，可以幫你解決問題</h4></li></ul></li></ul><ol><li>Universal: SSR + CSR </li></ol><ul><li>全域設定 mode: ‘Universal’</li></ul><ol start="2"><li>SPA: 不跑SSR </li></ol><ul><li>全域設定 mode: ‘spa’ 或執行 nuxt-spa</li></ul><ol start="3"><li>Static Generated (Pre Rendering): 產生靜態頁面</li></ol><ul><li>nuxt run generate<ul><li>預先將頁面轉成靜態頁面</li><li>如要拉10樣商品，就先拉10個頁面</li></ul></li></ul><p>希望本篇的扼要介紹能夠讓讀者快速知道其中的差異。</p><p>參考資料：<br><a href="https://medium.com/@jackercleaninglab/ssr-nuxt-js-%E8%B6%85%E5%85%A5%E9%96%80-84a0823b45ed" target="_blank" rel="noopener">SSR — Nuxt.js 超入門</a><br><a href="https://www.youtube.com/watch?v=szrRDJBFmvQ" target="_blank" rel="noopener">Vue Nuxt 介紹與實作範例</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/4LE0BUW.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;製作網站，都會希望自己的網站可以被搜尋引擎找得到，並且可以在使用者輸入關鍵字後，可以在頭幾個項目中就能關注到自己的網站！&lt;br&gt;而在使用 Vue.js 框架，</summary>
      
    
    
    
    
    <category term="Nuxt" scheme="https://github.com/Eva813/Eva813.github.io.git/tags/Nuxt/"/>
    
  </entry>
  
  <entry>
    <title>實作 Vuex - Todo List</title>
    <link href="https://github.com/Eva813/Eva813.github.io.git/2021/10/20/vuex-todo/"/>
    <id>https://github.com/Eva813/Eva813.github.io.git/2021/10/20/vuex-todo/</id>
    <published>2021-10-20T06:32:01.000Z</published>
    <updated>2021-10-20T09:00:00.871Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/RPoUnyd.png" alt=""></p><p>之前的實作練習都沒有機會使用到 Vuex，總是覺得它的資料存取、取得或是管理，對於剛接觸Vue 的我來說還是相對複雜，而且剛開始接觸 Vue 總要先練習下 props \ emit 資料傳遞才行啊～<br>既然已經會使用基礎的資料傳遞後，那就要近一步實作 Vuex 狀態管理</p><h2 id="實作功能說明"><a href="#實作功能說明" class="headerlink" title="實作功能說明"></a>實作功能說明</h2><ul><li>資料的取得來自 JSONPlaceholder<ul><li>從Vuex來實作資料的取得、刪除、更新</li></ul></li><li>針對目前取得的資料進行筆數的篩選</li><li>區分未完成事項、以及完成事項</li><li>可透過點擊方塊改變色塊</li><li>接下來～會製作 3個 component ，將元件放到 App.vue</li></ul><p><a href="https://eva813.github.io/Vuex-Todo/index.html" target="_blank" rel="noopener">成品</a></p><h4 id="開始前別忘了先建立-module"><a href="#開始前別忘了先建立-module" class="headerlink" title="開始前別忘了先建立 module"></a>開始前別忘了先建立 module</h4><h2 id="Vuex-檔案的處理"><a href="#Vuex-檔案的處理" class="headerlink" title="Vuex 檔案的處理"></a>Vuex 檔案的處理</h2><ul><li>這裡開專案直接有建立 vuex</li><li>進入 store &gt; index.js</li></ul><pre><code class="javascript">import { createStore } from &#39;vuex&#39;;import todos from &#39;./modules/todos&#39;;export default createStore({  state: {  },  mutations: {  },  actions: {  },  modules: {    todos,  }})</code></pre><h2 id="建立-modules-資料夾"><a href="#建立-modules-資料夾" class="headerlink" title="建立 modules 資料夾"></a>建立 modules 資料夾</h2><ul><li>store &gt; modules &gt; todo.js<ul><li>從這裡的資料取得並傳遞到 Todos.vue<pre><code class="javascript">import axios from &#39;axios&#39;;</code></pre></li></ul></li></ul><p>const state = {};<br>const getters = {};<br>const actions = {};<br>const mutations = {};</p><p>export default {<br>  state,<br>  getters,<br>  actions,<br>  mutations<br>}</p><pre><code>#### 接下來要嘗試來串取資料* 取得假資料[jsonplaceholder-todo](https://jsonplaceholder.typicode.com/todos)## 在 todo.js 來製作資料的串接* 首先state這裡要先建立空陣列，getters 則是建立資料取得的函式* 在action 來發出請求，取得回應，並傳給 mutations    * mutations 是改變資料的地方* 引入axios，使用 Asyc await 使用 get 來串接資料   * 將串到的資料 commit 到 mutations，改變原本todos資料內容```javascriptimport axios from &#39;axios&#39;;const state = {  todos: []};const getters = {  getTodos: (state) =&gt; state.todos,};const actions = {  async fetchTodos({ commit }) {    const res = await axios.get(&quot;https://jsonplaceholder.typicode.com/todos&quot;);    // console.log(res.data);    commit(&#39;setTodos&#39;, res.data);  }};const mutations = {  setTodos: (state, todos) =&gt; {    state.todos = todos;  }};export default {  state,  getters,  actions,  mutations}</code></pre><p><img src="https://i.imgur.com/4wmzRwy.png" alt=""></p><h2 id="建立-Todos-vue"><a href="#建立-Todos-vue" class="headerlink" title="建立 Todos.vue"></a>建立 Todos.vue</h2><ul><li><p>此元件主要是呈現所有的 Todo list</p><h3 id="取得-vuex-中的資料"><a href="#取得-vuex-中的資料" class="headerlink" title="取得 vuex 中的資料"></a>取得 vuex 中的資料</h3></li><li><p>引入 mapGetters, mapActions</p></li><li><p>將要從 getters 拿到的陣列，放到computed做資料的取得</p><ul><li>將該陣列<code>getTodos</code> 放到 v-for</li></ul></li><li><p>串接的 action 使用 mapActions，於 methods中執行，而此函式要在<code>created</code>階段運行</p></li><li><p>如此一來就可以，從 Vuex 中得到資料</p></li></ul><pre><code class="javascript">&lt;template&gt;  &lt;h3&gt;Todos&lt;/h3&gt;  &lt;div class=&quot;todos&quot;&gt;    &lt;div class=&quot;todo&quot; v-for=&quot;todo in getTodos&quot; :key=&quot;todo.id&quot;&gt;      {{ todo.title }}    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import { mapGetters, mapActions } from &quot;vuex&quot;;export default {  name: &quot;Todos&quot;,  methods:{    ...mapActions([&quot;fetchTodos&quot;])  },  computed: mapGetters([&quot;getTodos&quot;]),  created() {    this.fetchTodos();  },};&lt;/script&gt;</code></pre><p><img src="https://i.imgur.com/4RKUMtJ.png" alt=""></p><p><img src="https://i.imgur.com/IiWla0A.png" alt=""></p><h2 id="製作加入新-todo-功能"><a href="#製作加入新-todo-功能" class="headerlink" title="製作加入新 todo 功能"></a>製作加入新 todo 功能</h2><ul><li>建立一個新的 component =&gt; AddTodo.vue</li><li>在 AddTodo 這個元件，製作 輸入框<pre><code class="javascript">&lt;template&gt;&lt;div&gt;  &lt;h3&gt;Add Todo&lt;/h3&gt;  &lt;div class=&quot;add&quot;&gt;    &lt;form&gt;    &lt;input type=&quot;text&quot; placeholder=&quot;Add Todo...&quot; v-model=&quot;title&quot; /&gt;    &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;    &lt;/form&gt;  &lt;/div&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {name: &quot;AddTodo&quot;,};&lt;/script&gt;</code></pre><h3 id="到-module-gt-todo-js"><a href="#到-module-gt-todo-js" class="headerlink" title="到 module &gt; todo.js"></a>到 module &gt; todo.js</h3></li><li>使用 async 與 axios 傳入資料<ul><li>第二個參數為 title</li><li>post 的網址一樣，後面接的參數為title, complete: false (any new todo that it’s not going to completed)</li></ul></li></ul><pre><code class="javascript">const actions = {  async fetchTodos({ commit }) {    const res = await axios.get(&quot;https://jsonplaceholder.typicode.com/todos&quot;);    // console.log(res.data);    commit(&#39;setTodos&#39;, res.data);  },  async addTodo({ commit }, title) {    const res = await axios.post(&quot;https://jsonplaceholder.typicode.com/todos&quot;, { title, completed: false });    commit(&#39;addNewTodo&#39;, res.data);  }};</code></pre><ul><li>而在action 中使用axios 來新增資料，要將這必新資料 push 到 todo的陣列中<ul><li>存入的該資料要放在，陣列的最前面所以使用 unshift<pre><code class="javascript">const mutations = {setTodos: (state, todos) =&gt; {state.todos = todos;},addNewTodo: (state, todo) =&gt; {state.todos.unshift(todo);}};</code></pre></li></ul></li></ul><h3 id="到-AddTodo-vue-來呼叫此-action"><a href="#到-AddTodo-vue-來呼叫此-action" class="headerlink" title="到 AddTodo.vue 來呼叫此 action"></a>到 AddTodo.vue 來呼叫此 action</h3><ul><li>import <code>mapActions</code></li></ul><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;h3&gt;Add Todo&lt;/h3&gt;    &lt;div class=&quot;add&quot;&gt;      &lt;form @submit=&quot;onSubmit&quot;&gt;        &lt;input type=&quot;text&quot; placeholder=&quot;Add Todo...&quot; v-model=&quot;title&quot; /&gt;        &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;      &lt;/form&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><pre><code class="javascript">&lt;script&gt;import { mapActions } from &quot;vuex&quot;;export default {  name: &quot;AddTodo&quot;,  data() {    return {      title: &quot;&quot;,    };  },  method: {    ...mapActions([&quot;addTodo&quot;]),    onSubmit(e) {      e.preventDefault();      //點擊後呼叫action中的加入todo函式，並傳入title資料      this.addTodo(this.title);    },  },};&lt;/script&gt;</code></pre><p><img src="https://i.imgur.com/57j3S5m.png" alt=""></p><h3 id="這裡要特別提出說明"><a href="#這裡要特別提出說明" class="headerlink" title="這裡要特別提出說明"></a>這裡要特別提出說明</h3><p>因為是使用線上的虛擬資料，他不允許我們可以存入新資料到他的API裡面<br>所以可以看到下方的錯誤顯示(重複 id)<br>而此在重新整理之後，存入的資料會消失</p><p><img src="https://i.imgur.com/nNh6AXL.png" alt=""></p><p><img src="https://i.imgur.com/0IZlhhL.png" alt=""></p><hr><h2 id="製作刪除功能"><a href="#製作刪除功能" class="headerlink" title="製作刪除功能"></a>製作刪除功能</h2><ul><li>以id作為參數，來依此刪除</li><li>不用儲存response資料<ul><li>在 async deleteTodo ，製作 by id 刪除</li><li>到 mutations =&gt; 使用 filter 存下資料</li></ul></li></ul><pre><code class="javascript">import axios from &#39;axios&#39;;const state = {  todos: []};const getters = {  getTodos: (state) =&gt; state.todos,};const actions = {  async fetchTodos({ commit }) {    const res = await axios.get(&quot;https://jsonplaceholder.typicode.com/todos&quot;);    // console.log(res.data);    commit(&#39;setTodos&#39;, res.data);  },  async addTodo({ commit }, title) {    const res = await axios.post(&quot;https://jsonplaceholder.typicode.com/todos&quot;, { title, completed: false });    commit(&#39;addNewTodo&#39;, res.data);  },  async deleteTodo({ commit }, id) {    await axios.delete(`https://jsonplaceholder.typicode.com/todos/${id}`);    commit(&#39;removeTodo&#39;, id)  }};const mutations = {  setTodos: (state, todos) =&gt; {    state.todos = todos;  },  addNewTodo: (state, todo) =&gt; {    state.todos.unshift(todo);  },  removeTodo: (state, id) =&gt; {    state.todos = state.todos.filter((todo) =&gt; todo.id !== id);    //使用filter 將，不是id的篩選出來  }};export default {  state,  getters,  actions,  mutations}</code></pre><ul><li>回到 Todos.vue</li><li>在 template 放入垃圾桶的 icon<ul><li>執行刪除的功能，在 icon 綁定刪除事件<code>deleteTodo()</code></li><li><code>deleteTodo()</code>就是來自於 methods 取得的事件<pre><code class="html">&lt;template&gt;&lt;h3&gt;Todos&lt;/h3&gt;&lt;div class=&quot;todos&quot;&gt;&lt;div class=&quot;todo&quot; v-for=&quot;todo in getTodos&quot; :key=&quot;todo.id&quot;&gt;{{ todo.title }}&lt;i class=&quot;fas fa-trash-alt&quot; @click=&quot;deleteTodo(todo.id)&quot;&gt;&lt;/i&gt;&lt;/div&gt;&lt;/div&gt;&lt;/template&gt;</code></pre><pre><code class="javascript">&lt;script&gt;import { mapGetters, mapActions } from &quot;vuex&quot;;export default {name: &quot;Todos&quot;,methods: {...mapActions([&quot;fetchTodos&quot;, &quot;deleteTodo&quot;]),},computed: mapGetters([&quot;getTodos&quot;]),created() {this.fetchTodos();},};&lt;/script&gt;</code></pre></li></ul></li></ul><pre><code>---## 製作篩選器功能* 當 FilterTodo.vue 這裡的篩選器執行的時候，會執行 action中的函式，進行篩選```html&lt;style scoped&gt;select {  margin-top: 20px;  padding: 6px;  border: #ef9a9a 1px solid;}&lt;/style&gt;&lt;template&gt;  &lt;div&gt;    Filter todos:    &lt;select&gt;      &lt;option value=&quot;200&quot;&gt;200&lt;/option&gt;      &lt;option value=&quot;100&quot;&gt;100&lt;/option&gt;      &lt;option value=&quot;50&quot;&gt;50&lt;/option&gt;      &lt;option value=&quot;30&quot;&gt;30&lt;/option&gt;      &lt;option value=&quot;20&quot;&gt;20&lt;/option&gt;      &lt;option value=&quot;10&quot;&gt;10&lt;/option&gt;    &lt;/select&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><pre><code class="javascript">&lt;script&gt;export default {  name: &quot;FilterTodos&quot;,};&lt;/script&gt;</code></pre><p>將該元件綁到 App.vue</p><pre><code class="javascript">&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;div class=&quot;container&quot;&gt;      &lt;AddTodo /&gt;      &lt;FilterTodos /&gt;      &lt;Todos /&gt;    &lt;/div&gt;  &lt;/div&gt;  &lt;!-- &lt;router-view /&gt; --&gt;&lt;/template&gt;&lt;script&gt;import Todos from &quot;@/components/Todos.vue&quot;;import AddTodo from &quot;@/components/AddTodo.vue&quot;;import FilterTodos from &quot;@/components/FilterTodos.vue&quot;;export default {  name: &quot;app&quot;,  components: {    Todos,    AddTodo,    FilterTodos,  },};&lt;/script&gt;</code></pre><h3 id="到-module-gt-todo-js-來製作-actions"><a href="#到-module-gt-todo-js-來製作-actions" class="headerlink" title="到 module &gt; todo.js 來製作 actions"></a>到 module &gt; todo.js 來製作 actions</h3><ul><li>要傳入 option 的 value<ul><li>第二個參數為事件</li><li>在 axios 的 get 放入 url，接上取得的參數</li><li>commit 直接傳到 setTodos ，將串接到的資料透過 mutations 存到 todos<pre><code class="javascript">import axios from &#39;axios&#39;;</code></pre></li></ul></li></ul><p>const state = {<br>  todos: []<br>};<br>const getters = {<br>  getTodos: (state) =&gt; state.todos,<br>};<br>const actions = {</p><p>  async filterTodos({ commit }, e) {<br>    //取得下拉選單的值<br>    //console.log(e.target.value);<br>    let selected = parseInt(e.target.value);<br>    const res = await axios.get(<code>https://jsonplaceholder.typicode.com/todos?_limit=${selected}</code>);<br>    commit(‘setTodos’, res.data);<br>  }</p><p>};<br>const mutations = {<br>  setTodos: (state, todos) =&gt; {<br>    state.todos = todos;<br>  },<br>  addNewTodo: (state, todo) =&gt; {<br>    state.todos.unshift(todo);<br>  },<br>  removeTodo: (state, id) =&gt; {<br>    state.todos = state.todos.filter((todo) =&gt; todo.id !== id);<br>    //使用filter 將，不是id的篩選出來<br>  }<br>};</p><p>export default {<br>  state,<br>  getters,<br>  actions,<br>  mutations<br>}</p><pre><code>* 將ａction 綁到 FilterTodos.vue```javascript&lt;template&gt;  &lt;div&gt;    Filter todos:    &lt;select @change=&quot;filterTodos($event)&quot;&gt;      &lt;option value=&quot;200&quot;&gt;200&lt;/option&gt;      &lt;option value=&quot;100&quot;&gt;100&lt;/option&gt;      &lt;option value=&quot;50&quot;&gt;50&lt;/option&gt;      &lt;option value=&quot;30&quot;&gt;30&lt;/option&gt;      &lt;option value=&quot;20&quot;&gt;20&lt;/option&gt;      &lt;option value=&quot;10&quot;&gt;10&lt;/option&gt;    &lt;/select&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import { mapActions } from &quot;vuex&quot;;export default {  name: &quot;FilterTodos&quot;,  methods: {    ...mapActions([&quot;filterTodos&quot;]),  },};&lt;/script&gt;</code></pre><hr><h2 id="todos-完成與否，狀態的改變"><a href="#todos-完成與否，狀態的改變" class="headerlink" title="todos 完成與否，狀態的改變"></a>todos 完成與否，狀態的改變</h2><ul><li>點擊兩下來更改狀態<ul><li>當要更新資料，要使用put，傳入updTodo物件資料<ul><li>將該資料傳到mutation</li></ul></li><li>接著到 mutation 製作更新的動作</li><li>要取得目前的index</li></ul></li></ul><pre><code class="javascript">import axios from &#39;axios&#39;;const state = {  todos: []};const getters = {  getTodos: (state) =&gt; state.todos,};const actions = {  async updataTodo({ commit }, updTodo) {    const res = await axios.put(`https://jsonplaceholder.typicode.com/todos/${updTodo.id}`,updTodo);    commit(&#39;renewTodo&#39;, res.data);  },};const mutations = {  renewTodo: (state, updTodo) =&gt; {    console.log(updTodo);    //我們是要在同一筆資料上更新    const index = state.todos.findIndex(todo =&gt; todo.id === updTodo.id);    //以下簡單確認 indx 是否有存在    if (index !== -1) {      state.todos.splice(index, 1, updTodo);    }  }};export default {  state,  getters,  actions,  mutations}</code></pre><h3 id="回到-Todos-vue"><a href="#回到-Todos-vue" class="headerlink" title="回到 Todos.vue"></a>回到 Todos.vue</h3><ul><li>template 插入legend</li><li>引入 <code>updataTodo</code>到 methods</li><li><code>onDblclick()</code>建立一個變數，它包含的物件內容為id、title、completed，其中我只要要改變的值是 complete true\false<ul><li>這裡的 id,title 都一樣。complete 則設定狀態的改變</li><li>最後在呼叫一次 <code>updataTodo()</code>  傳入新的物件<pre><code class="html">&lt;template&gt;&lt;h3&gt;Todos&lt;/h3&gt;&lt;div class=&quot;legend&quot;&gt;&lt;span&gt;雙重點擊來標示已完成的事項&lt;/span&gt;&lt;span&gt; &lt;span class=&quot;incomplete-box&quot;&gt;&lt;/span&gt; = 未完成 &lt;/span&gt;&lt;span&gt; &lt;span class=&quot;complete-box&quot;&gt;&lt;/span&gt; = 已完成 &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;todos&quot;&gt;&lt;div @dblclick=&quot;onDblclick(todo)&quot; class=&quot;todo&quot; v-for=&quot;todo in getTodos&quot; :key=&quot;todo.id&quot; :class=&quot;{ &#39;is-complete&#39;: todo.completed }&quot;&gt; {{ todo.title }} &lt;i class=&quot;fas fa-trash-alt&quot; @click=&quot;deleteTodo(todo.id)&quot;&gt;&lt;/i&gt;&lt;/div&gt;&lt;/div&gt;&lt;/template&gt;</code></pre></li></ul></li></ul><pre><code>```javascript&lt;script&gt;import { mapGetters, mapActions } from &quot;vuex&quot;;export default {  name: &quot;Todos&quot;,  methods: {    ...mapActions([&quot;fetchTodos&quot;, &quot;deleteTodo&quot;, &quot;updataTodo&quot;]),    onDblclick(todo) {      const updTodo = {        id: todo.id,        title: todo.title,        completed: !todo.completed,      };      this.updataTodo(updTodo);    },  },  computed: mapGetters([&quot;getTodos&quot;]),  created() {    this.fetchTodos();  },};&lt;/script&gt;</code></pre><p>參考資料：<br><a href="https://ithelp.ithome.com.tw/articles/10191225" target="_blank" rel="noopener">[Vue.js] Vuex 學習筆記 (5) - getters 的核心概念</a><br><a href="https://vuex.vuejs.org/zh/guide/getters.html#%E9%80%9A%E8%BF%87%E5%B1%9E%E6%80%A7%E8%AE%BF%E9%97%AE" target="_blank" rel="noopener">Vuex</a><br><a href="https://forum.vuejs.org/t/using-this-store-dispatch-vs-using-mapactions/2186/2" target="_blank" rel="noopener">Using <code>this.$store.dispatch</code> vs using mapActions</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/RPoUnyd.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;之前的實作練習都沒有機會使用到 Vuex，總是覺得它的資料存取、取得或是管理，對於剛接觸Vue 的我來說還是相對複雜，而且剛開始接觸 Vue 總要先練習下 p</summary>
      
    
    
    
    
    <category term="Vue" scheme="https://github.com/Eva813/Eva813.github.io.git/tags/Vue/"/>
    
    <category term="Vuex" scheme="https://github.com/Eva813/Eva813.github.io.git/tags/Vuex/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js 3 -  組件的拆分</title>
    <link href="https://github.com/Eva813/Eva813.github.io.git/2021/10/19/Vue-setComponent/"/>
    <id>https://github.com/Eva813/Eva813.github.io.git/2021/10/19/Vue-setComponent/</id>
    <published>2021-10-19T08:36:10.000Z</published>
    <updated>2021-11-28T08:50:18.258Z</updated>
    
    <content type="html"><![CDATA[<p>試想今天有一個網頁，上方的導覽列有不同的分類，帶領你到該項目的分頁中<br>那我們該如何實現，將各個項目的內容一一呈現<br><img src="https://i.imgur.com/7LUqd5I.png" alt=""></p><h2 id="簡單分別製作-component"><a href="#簡單分別製作-component" class="headerlink" title="簡單分別製作 component"></a>簡單分別製作 component</h2><p>首先：component的命名要用大寫<br><img src="https://i.imgur.com/fAOtmM8.png" alt=""></p><ul><li>在 component 中<br><img src="https://i.imgur.com/dgWnvii.png" alt=""></li></ul><h3 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h3><ul><li>在 App.vue<br>讓vue知道有個component可以被使用，透過ES6的解構放入<br><img src="https://i.imgur.com/4yAMVNw.png" alt=""><br>將引入的component放到template<br><img src="https://i.imgur.com/PO4LhRv.png" alt=""><br><img src="https://i.imgur.com/K0UmvdI.png" alt=""></li></ul><h2 id="將其他組件引入"><a href="#將其他組件引入" class="headerlink" title="將其他組件引入"></a>將其他組件引入</h2><p><img src="https://i.imgur.com/EgWUGfG.png" alt=""></p><p><img src="https://i.imgur.com/qIvkq2l.png" alt=""></p><h2 id="補充說明："><a href="#補充說明：" class="headerlink" title="補充說明："></a>補充說明：</h2><p>修改路徑:<br>用~@來指定圖片路徑：@在vuecli是代表特殊意義，就會直接從src這個資料夾底下開始查找;而波浪符號，代表現在在css之中使用這個功能<br><img src="https://i.imgur.com/NefWOd8.png" alt=""></p><ul><li>也就是在專案中，即便路徑複雜，只要在路徑最前面加上<code>@</code>就會直接進去src<br><img src="https://i.imgur.com/sPhH1rs.png" alt=""></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;試想今天有一個網頁，上方的導覽列有不同的分類，帶領你到該項目的分頁中&lt;br&gt;那我們該如何實現，將各個項目的內容一一呈現&lt;br&gt;&lt;img src=&quot;https://i.imgur.com/7LUqd5I.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;簡單分別製作-comp</summary>
      
    
    
    
    
    <category term="Vue" scheme="https://github.com/Eva813/Eva813.github.io.git/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>JS基本觀念 - 認識 pass by value、pass by reference 、 pass by sharing，Javascript 又是哪一個？</title>
    <link href="https://github.com/Eva813/Eva813.github.io.git/2021/10/09/js-pass/"/>
    <id>https://github.com/Eva813/Eva813.github.io.git/2021/10/09/js-pass/</id>
    <published>2021-10-09T04:18:41.000Z</published>
    <updated>2021-10-09T09:24:30.373Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/zT0UU5c.jpg" alt=""></p><p>之所以會撰寫這篇文，是因為面試過程被考倒的觀念，才發現自己過去從沒注意到這部分啊，那就來寫篇文章來認識它們之中的傳遞方式。</p><h2 id="首先，先從型別的認識開始"><a href="#首先，先從型別的認識開始" class="headerlink" title="首先，先從型別的認識開始"></a>首先，先從型別的認識開始</h2><p>在Javascript分兩大類，一種是基本型別(primitive type)，另一種是物件(Object)。</p><ul><li>Primitive type （以純值的形式存在）<br>Boolean<br>Null<br>Undefined<br>Number<br>BigInt<br>String<br>Symbol（於 ECMAScript 6 新定義）</li><li>Object<br>物件型別指的是可能由零或多種不同型別 (包括純值與物件) 所組合成，例如object,array, function, map</li></ul><p>知道型別後，可以簡易的分類：</p><ul><li>primitive type會是 pass by value，</li><li>object 是 pass by reference。</li></ul><h2 id="接下來來觀察，它們之間不同"><a href="#接下來來觀察，它們之間不同" class="headerlink" title="接下來來觀察，它們之間不同"></a>接下來來觀察，它們之間不同</h2><h3 id="pass-by-value"><a href="#pass-by-value" class="headerlink" title="pass by value"></a>pass by value</h3><p>範例1：</p><pre><code class="javascript">let x=10;let y=x;x=20;console.log(x); //20console.log(y); //10</code></pre><ul><li>注意：x和y是兩個獨立變數 （先記著這點）<ul><li>值會存入該變數<br><code>var y = x;</code> 看起來會像是y的內容要複製x，但可以的話要理解為，變數 y 是去建立了一個新的值，然後將變數 x 的內容複製了一份過來。</li></ul></li><li>因為兩的變數，各自獨立，所以當變數 x 的內容後來經過更新變成 20 之後，變數 y 的內容依舊保持原來的 10 而不受影響。</li></ul><p>範例2</p><pre><code class="javascript">var num=3;console.log(&quot;num start:&quot;,num);function passByValue(func_num){  func_num=5;}passByValue(num);console.log(&quot;num end:&quot;, num);</code></pre><h4 id="結果："><a href="#結果：" class="headerlink" title="結果："></a>結果：</h4><pre><code class="javascript">num start:3num end: 3</code></pre><ul><li>先是宣告新變數</li><li>隨後建立<code>passByValue()</code> 函式</li><li>呼叫<code>passByValue(num)</code> 複製變數num的值，3傳入<code>passByValue(func_num)</code>。<ul><li>一開始 值會是3</li><li>遇到<code>func_num=5;</code> =&gt; 將值改為 5</li></ul></li><li>但因為出去了函式範圍(scope)，最終的值 <code>num end:3</code></li></ul><h3 id="pass-by-refrence"><a href="#pass-by-refrence" class="headerlink" title="pass by refrence"></a>pass by refrence</h3><p>範例</p><pre><code class="javascript">let x={value:10};let y=x;x.value=20;console.log(x); //{value:20}console.log(y); //{value:20}console.log( x === y );  //true</code></pre><h3 id="拆解說明一下"><a href="#拆解說明一下" class="headerlink" title="拆解說明一下"></a>拆解說明一下</h3><ul><li>當宣告一個物件</li><li>JavaScript 會在記憶體的某處建立起一個物件 (圖右側)，然後再將這個 <code>x</code>變數指向新生成的物件</li></ul><p><img src="https://i.imgur.com/LPwkZAg.png" alt=""></p><ul><li>接著，當我們宣告了第二個變數 y ，並且透過 = 將y 指向 x 的位置。</li><li>接著當我們更新了 x.value 的內容後， y.value 的內容也被更新了。</li></ul><p><img src="https://i.imgur.com/vFUhP6X.png" alt=""></p><p>範例2</p><pre><code class="javascript">var obj1={item:&quot;unchanged&quot;};console.log(&quot;obj1 start:&quot;,obj1);function passByReference(ref){  ref.item= &quot;changed&quot;;}passByReference(obj1);console.log(&quot;obj end&quot;, obj1);</code></pre><h4 id="結果"><a href="#結果" class="headerlink" title="結果"></a>結果</h4><pre><code class="javascript">obj1 start:{item: &quot;unchanged&quot;}obj1 end:{item:&quot;changed&quot;}</code></pre><ul><li>當執行passByReference(obj1) 。想像他是個地址(0x0016)，進入函式中將地址複製，傳入。<ul><li>此時他的value 是個地址(0x0016)</li></ul></li><li>進入函式，遇到<code>ref.item</code><ul><li>de-reference ，進入原本的記憶體位置，找到item，並改變他的值</li></ul></li></ul><p><img src="https://i.imgur.com/3Ytn7bk.png" alt=""></p><h4 id="在不一般情況下，基本型別是-pass-by-value，而物件型別是-pass-by-reference的方式，但總有例外的時候。"><a href="#在不一般情況下，基本型別是-pass-by-value，而物件型別是-pass-by-reference的方式，但總有例外的時候。" class="headerlink" title="在不一般情況下，基本型別是 pass by value，而物件型別是 pass by reference的方式，但總有例外的時候。"></a>在不一般情況下，基本型別是 pass by value，而物件型別是 pass by reference的方式，但總有例外的時候。</h4><h3 id="pass-by-sharing"><a href="#pass-by-sharing" class="headerlink" title="pass by  sharing"></a>pass by  sharing</h3><pre><code class="javascript">var obj1={item:&quot;unchanged&quot;};console.log(&quot;obj1 start:&quot;,obj1);function passBySharing(ref){  ref={ item: &quot;changed&quot;};}passBySharing(obj1);console.log(&quot;obj end&quot;, obj1);</code></pre><pre><code class="javascript">obj1 start:{item: &quot;unchanged&quot;}obj1 end:{item:&quot;unchanged&quot;}</code></pre><ul><li>傳入之前start 沒有改變</li><li>呼叫函式，並進入<code>passBySharing()</code>，還是複製地址，傳入</li><li>遇到<code>ref={ item: &quot;changed&quot;};</code>，會直接覆蓋地址(有點類似pass by value)<ul><li>這並不是直接更改物件特性</li></ul></li></ul><p><img src="https://i.imgur.com/Kst3565.png" alt=""></p><h2 id="最後，來說說-JavaScript-屬於？"><a href="#最後，來說說-JavaScript-屬於？" class="headerlink" title="最後，來說說 JavaScript 屬於？"></a>最後，來說說 JavaScript 屬於？</h2><p>看了多篇文章，實在也是有點混亂，該認為三種形式都有呢？還是就是Pass by sharing、Pass by reference呢？ 那例外情形又該如何解釋？</p><p>所以這邊的結尾，直接引用Kuro、Huli老師文章的資訊，供給大家參考。</p><p>從Kuro Hsu 的<a href="https://ithelp.ithome.com.tw/articles/10191057" target="_blank" rel="noopener">文章</a>、<a href="https://www.tenlong.com.tw/products/9789864344130" target="_blank" rel="noopener">書</a><br>提及認為 JavaScript 應該更屬於 Pass by sharing 的形式。</p><ul><li>JavaScript 不屬於單純的傳值或傳址。</li></ul><p>參考 ECMA-262-3 in detail. Chapter 8. Evaluation strategy</p><blockquote><p>Regardless of usage concept of reference in this case, this strategy should not be confused with the “call by reference” discussed above. The value of the argument is not a direct alias, but the copy of the address.<br>由於在 JavaScript 的物件類型是可變的 (mutable)，當物件更新時，會影響到所有引用這個物件的變數與其副本，修改時會變動到原本的參考，但當賦與新值時，會產生新的實體參考。</p></blockquote><p>另外在 Huli 的文章中：</p><blockquote><p>依據細分程度的不同，下面幾句話都是正確的：<br>JavaScript 裡面只有 pass by value<br>JavaScript 的 primitive type 是 pass by value，object 是 pass by sharing</p></blockquote><hr><h2 id="最終來個綜合練習："><a href="#最終來個綜合練習：" class="headerlink" title="最終來個綜合練習："></a>最終來個綜合練習：</h2><p>相信在最後的這個練習，可以更清楚，pass by value，pass by reference，pass by sharing</p><pre><code class="javascript">function changeStuff(num,obj,obj2){  num=num*10;  obj.item=&quot;changed&quot;;  obj={item:&quot;changed&quot;};}var num=10;var obj={item: &quot;unchanged&quot;};var obj2= {item: &quot;unchanged&quot;};changeStuff(num, obj, obj2);console.log(num);console.log(obj.item);console.log(obj.item);</code></pre><pre><code>console=&gt; 10 &quot;changed&quot; &quot;unchanged&quot;</code></pre><p>參考資料：<br><a href="https://medium.com/@mengchiang000/js%E5%9F%BA%E6%9C%AC%E8%A7%80%E5%BF%B5-call-by-value-%E9%82%84%E6%98%AFreference-%E5%8F%88%E6%88%96%E6%98%AF-sharing-22a87ca478fc" target="_blank" rel="noopener">JS基本觀念：call by value 還是reference 又或是 sharing?</a><br><a href="https://ithelp.ithome.com.tw/articles/10191057" target="_blank" rel="noopener">重新認識 JavaScript: Day 05 JavaScript 是「傳值」或「傳址」？</a><br><a href="https://www.youtube.com/watch?v=1YFss_4B_o4&t=302s" target="_blank" rel="noopener">Tech Talk: Pass By Sharing with Javascript</a><br><a href="https://blog.techbridge.cc/2018/06/23/javascript-call-by-value-or-reference/" target="_blank" rel="noopener">深入探討 JavaScript 中的參數傳遞：call by value 還是 reference？</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/zT0UU5c.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;之所以會撰寫這篇文，是因為面試過程被考倒的觀念，才發現自己過去從沒注意到這部分啊，那就來寫篇文章來認識它們之中的傳遞方式。&lt;/p&gt;
&lt;h2 id=&quot;首先，先從</summary>
      
    
    
    
    
    <category term="JS" scheme="https://github.com/Eva813/Eva813.github.io.git/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>演算法入門 - Sorting-Algorithms</title>
    <link href="https://github.com/Eva813/Eva813.github.io.git/2021/10/08/Sorting-Algorithms/"/>
    <id>https://github.com/Eva813/Eva813.github.io.git/2021/10/08/Sorting-Algorithms/</id>
    <published>2021-10-08T06:08:05.000Z</published>
    <updated>2021-10-12T08:06:52.414Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/glzKE9I.png" alt=""></p><p>延續 Wilson Ren<a href="https://www.udemy.com/course/algorithm-data-structure/?course_id=3819536&fbclid=IwAR3ugnEJMsniBCvoMHthf31EqEQeG9hCL3BQb2gWS7eAFZ4lcixmWOiwNAo" target="_blank" rel="noopener">課程</a>來認識常見的排列方法！</p><h2 id="排列的演算法介紹"><a href="#排列的演算法介紹" class="headerlink" title="排列的演算法介紹"></a>排列的演算法介紹</h2><p><img src="https://i.imgur.com/zeRjPef.png" alt=""></p><ul><li>在JS中，就有內建 <code>array.sort()</code><ul><li>同樣在其他程式語言，都會有內建的 sorting function</li><li>但還是需要知道他們是如何運作</li></ul></li><li>總共有 6 種 sorting</li><li>此篇文章會以前面兩種為主</li></ul><h2 id="Bubble-Sort"><a href="#Bubble-Sort" class="headerlink" title="Bubble Sort"></a>Bubble Sort</h2><ul><li>冒泡排序</li><li>會比較相鄰的元素，如果順序不對會互換element</li><li>是相當簡單的演算法，在現實世界很少拿來使用，最常用在教學</li><li>而像在python、java 他們內建的排序演算法，都不是用冒泡排序，多是用 quicksort,merge sort（比較複雜、但有效率）<h3 id="範例說明"><a href="#範例說明" class="headerlink" title="範例說明"></a>範例說明</h3><img src="https://i.imgur.com/pDdBK9i.png" alt=""></li><li>比較array的最後兩個數字 =&gt; 發現順序不對就對調<br><img src="https://i.imgur.com/ElpC2qh.png" alt=""></li><li>對調之後，再往下兩個元素<ul><li>發現順序正確，不需更動<br><img src="https://i.imgur.com/mQuFUvU.png" alt=""></li></ul></li><li>不更動之後，再往下兩個<br><img src="https://i.imgur.com/Qk1T9c3.png" alt=""><br>以此類推…</li><li>小結：將找到的最小值，推到最左邊</li></ul><h3 id="要如何做-Bubble-Sort"><a href="#要如何做-Bubble-Sort" class="headerlink" title="要如何做 Bubble Sort"></a>要如何做 Bubble Sort</h3><ul><li><p>先從一個陣列中2個數值比較開始思考</p><pre><code>for j from A.length-1 to 1; if A[j] &lt; A[j-i] ; swap A[j] and A[j-i]</code></pre></li><li><p>虛擬碼<br><img src="https://i.imgur.com/2VFPI3E.png" alt=""></p></li><li><p>i =&gt; sorted elements</p></li><li><p>j =&gt; adjacent elements(j是相對i而來)</p><pre><code class="javascript">function bubbleSort(arr){  for(let i=0;i&lt;arr.length-2;i++){    for(let j=arr.length-1;j&gt;=i+1;j--){      if (arr[j]&lt;arr[j-1]){        //swap arr[j] and arr[j-1]        let temp=arr[j];        arr[j] = arr[j-1];        arr[j-1] = temp;      }    }  }  console.log(arr);}bubbleSort([4,1,5,2,7]);</code></pre></li><li><p>加入隨機的數字，組成新的陣列</p><pre><code class="javascript">function bubbleSort(arr) {let step = 0;for (let i = 0; i &lt;= arr.length - 2; i++) {  for (let j = arr.length - 1; j &gt;= i + 1; j--) {    if (arr[j] &lt; arr[j - 1]) {      // swap arr[j] and arr[j - 1]      let temp = arr[j];      arr[j] = arr[j - 1];      arr[j - 1] = temp;      step++;    }  }}console.log(&quot;It takes &quot; + step + &quot; steps to complete.&quot;);console.log(arr);}</code></pre></li></ul><p>let test = [];</p><p>for (let i = 0; i &lt; 100; i++) {<br>  test.push(Math.floor(Math.random() * 100));<br>}</p><p>bubbleSort(test);</p><pre><code>## Big O of Bubble Sort![](https://i.imgur.com/NSg6FSC.png)* 最糟情況下： 由大到小，要排成 由小到大 =&gt; 他交換的次數會是 (n-1)+(n-2)+(n-3)+...+(n-n)次* 最好的情況： 本身的arr就接近 小到大    * 優化語法    * 發現沒有任何elements被交換，就可以停止迴圈```javascriptfunction bubbleSort(arr){    for(let i=0;i&lt;arr.length-2;i++){      let swapping=false;      for(let j=arr.length-1;j&gt;=i+1;j--){        if (arr[j]&lt;arr[j-1]){          //swap arr[j] and arr[j-1]          let temp=arr[j];          arr[j] = arr[j-1];          arr[j-1] = temp;          swapping=true;        }      }    }    if (swapping==false){      break;    }  }</code></pre><ul><li>平均情況還是用到 nested for loop<ul><li>O(n^2)</li></ul></li></ul><h2 id="Insertion-Sort"><a href="#Insertion-Sort" class="headerlink" title="Insertion Sort"></a>Insertion Sort</h2><p><img src="https://i.imgur.com/NwAm9cW.png" alt=""></p><ul><li>效率比 bubble sort 好一些</li><li>理論上， 都是 O(n^2)</li><li>不斷做插入的動作<h3 id="範例說明-1"><a href="#範例說明-1" class="headerlink" title="範例說明"></a>範例說明</h3><img src="https://i.imgur.com/HtfgFYG.png" alt=""></li><li>先認為這條arr長度是1</li><li>從陣列最前面開始，要將1插入4這個arr上</li></ul><p><img src="https://i.imgur.com/CrYGinm.png" alt=""></p><ul><li><p>數字2，要和左邊的數字作比較<br><img src="https://i.imgur.com/lb7mYhc.png" alt=""></p></li><li><p>數字3去比較<br><img src="https://i.imgur.com/gqnhQYA.png" alt=""></p></li></ul><h3 id="虛擬碼"><a href="#虛擬碼" class="headerlink" title="虛擬碼"></a>虛擬碼</h3><p><img src="https://i.imgur.com/lNSbpjL.png" alt=""></p><pre><code>index 0,1,2,3,4value 1,2,3,4,0</code></pre><ul><li>檢查這條arr的 index=1</li><li>設定<code>key=A[j]</code>，並將key插入 sorted sequence <ul><li>j 的前一格為 i</li></ul></li><li>確認 i 有沒有大於key =&gt; 也就是對於key而言，要不斷地和它左邊的值比較<ul><li>如果左邊的值比key大，就要讓他們互換</li></ul></li></ul><pre><code>index 0,1,2,3,4value 1,2,3,4 (i),0 (j key)while i&gt;0 &amp;&amp; A[i] &gt; key  A[i+1] = A[i]  i -= 1</code></pre><ul><li>語法</li></ul><pre><code class="javascript">let unsorted = [14, -4, 17, 6, 22, 1, -5];insertionSort(unsorted);function insertionSort(arr) {  for (let j = 1; j &lt;= arr.length - 1; j++) {    let key = arr[j];    i = j - 1;    while (i &gt;= 0 &amp;&amp; arr[i] &gt; key) {      arr[i + 1] = arr[i];      i -= 1;    }    arr[i + 1] = key;  }  console.log(arr);  return arr;}</code></pre><p><img src="https://i.imgur.com/E8xWtkL.png" alt=""></p><h2 id="Big-O"><a href="#Big-O" class="headerlink" title="Big O"></a>Big O</h2><p><img src="https://i.imgur.com/OVF4VRl.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/glzKE9I.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;延續 Wilson Ren&lt;a href=&quot;https://www.udemy.com/course/algorithm-data-structure/?co</summary>
      
    
    
    
    
    <category term="Algorithm" scheme="https://github.com/Eva813/Eva813.github.io.git/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>演算法入門</title>
    <link href="https://github.com/Eva813/Eva813.github.io.git/2021/10/02/Algorithm/"/>
    <id>https://github.com/Eva813/Eva813.github.io.git/2021/10/02/Algorithm/</id>
    <published>2021-10-02T05:17:40.000Z</published>
    <updated>2021-10-12T06:29:45.095Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/LHDcmBI.png" alt=""></p><p>常常看到 YouTube 演算法造成頻道經營的難度、或是facebook演算法而使得行銷曝光度的改變，但始終對演算法這個名詞沒有認識。<br>藉由 Wilson Ren<a href="https://www.udemy.com/course/algorithm-data-structure/?course_id=3819536&fbclid=IwAR3ugnEJMsniBCvoMHthf31EqEQeG9hCL3BQb2gWS7eAFZ4lcixmWOiwNAo" target="_blank" rel="noopener">課程</a></p><h2 id="什麼是演算法？"><a href="#什麼是演算法？" class="headerlink" title="什麼是演算法？"></a>什麼是演算法？</h2><p>用以解決問題而可以逐步執行的步驟或程序。</p><h4 id="來看看現實生活中的演算法"><a href="#來看看現實生活中的演算法" class="headerlink" title="來看看現實生活中的演算法"></a>來看看現實生活中的演算法</h4><ul><li>Google Map 如何找到最短路徑</li><li>YouTube 推薦給你，認為你有興趣的影片</li><li>FB\IG 的加好友、追蹤推薦</li></ul><h2 id="演算法比較"><a href="#演算法比較" class="headerlink" title="演算法比較"></a>演算法比較</h2><p>有兩個演算法都可以完成目標任務，那我們會如何取決誰比較好？</p><ul><li>哪個演算法執行速度快？</li><li>所佔用電腦的記憶體資源少？<h3 id="時間"><a href="#時間" class="headerlink" title="時間?"></a>時間?</h3>首先，在計時演算法所耗時的部分：</li><li>幫演算法做計時，是不實際的事情<ul><li>同一台電腦在執行同一任務，所執行的時間會不同</li><li>不同電腦、CPU處理速度不一樣<h4 id="應該考慮，複雜度-Complexity"><a href="#應該考慮，複雜度-Complexity" class="headerlink" title="應該考慮，複雜度 Complexity"></a>應該考慮，複雜度 Complexity</h4></li></ul></li><li>複雜度分為兩種：時間複雜度、空間複雜度 （在本文多是討論時間複雜度）</li><li>要如何計算時間複雜度?<ul><li>加、減、乘、除、comparison ，這些每一個都可以被算作一個 operation</li><li>Complexity: 在所寫的演算法中，總共用到多少 operations(運算子)</li><li>使用 function 來顯示 Complexity 和 input size 的關係。</li></ul></li></ul><h2 id="Big-O-Notation"><a href="#Big-O-Notation" class="headerlink" title="Big O Notation"></a>Big O Notation</h2><ol><li>是一個工具，用來描述當你的值不斷擴大時，f(n)值會去哪裡</li><li>為最壞情況的打算。他會展示一個演算法複雜度的趨勢</li></ol><h3 id="計算-Big-O-的值"><a href="#計算-Big-O-的值" class="headerlink" title="計算 Big O 的值"></a>計算 Big O 的值</h3><ol><li>Constant doesn’t matter : 常數它並不重要<ul><li>f(n)=3n ：3為常數、n為變數</li></ul></li><li>Small Terms don’t matter<ul><li>fn= 3n^2 + 6n + 4 =&gt; 只需保留到fn= 3n^2</li></ul></li><li>Logarithm Base doesn’t matter<br><img src="https://i.imgur.com/dNM08rx.png" alt=""><h2 id="範例："><a href="#範例：" class="headerlink" title="範例："></a>範例：</h2></li><li>f(n)=3n<br>答案：O(n)</li><li>f(n)=13n^3 + 6n +7<br>答案：O(n^3)</li><li>f(n)=4log₂n<br>答案：O(logn)</li><li>f(n)=5<br>答案：O(1)</li></ol><h2 id="演算法常見-Big-O-的值"><a href="#演算法常見-Big-O-的值" class="headerlink" title="演算法常見 Big O 的值"></a>演算法常見 Big O 的值</h2><p>由好至差</p><ol><li>O(1)</li><li>O(logn)</li><li>O(n)</li><li>O(nlogn)</li><li>O(n^2)</li><li>O(n^3)</li></ol><ul><li>很多sorting值會是 O(nlogn)</li><li>盡量讓演算法可以達到3、4的值</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/LHDcmBI.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;常常看到 YouTube 演算法造成頻道經營的難度、或是facebook演算法而使得行銷曝光度的改變，但始終對演算法這個名詞沒有認識。&lt;br&gt;藉由 Wilso</summary>
      
    
    
    
    
    <category term="Algorithm" scheme="https://github.com/Eva813/Eva813.github.io.git/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js 3 -  資料傳遞 emit</title>
    <link href="https://github.com/Eva813/Eva813.github.io.git/2021/09/21/vue-emit/"/>
    <id>https://github.com/Eva813/Eva813.github.io.git/2021/09/21/vue-emit/</id>
    <published>2021-09-21T04:42:48.000Z</published>
    <updated>2021-10-25T05:22:15.348Z</updated>
    
    <content type="html"><![CDATA[<p>圖示：<br><img src="https://i.imgur.com/PxIIobu.png" alt=""></p><h2 id="emit-實作練習"><a href="#emit-實作練習" class="headerlink" title="emit 實作練習"></a>emit 實作練習</h2><p><img src="https://i.imgur.com/7guYdVb.png" alt=""></p><ul><li>透過點擊add按鈕，觸發外層元件數值的改變<ul><li>先定義外層接收資料方式</li><li>定義內層的 $emit 觸發方法</li><li>使用 v-on 的方式觸發外層方法（口訣：前內、後外）</li></ul></li></ul><h3 id="外層元件"><a href="#外層元件" class="headerlink" title="外層元件"></a>外層元件</h3><ul><li><p>定義接收方法：當內層傳給你的時候，要做什麼事</p><ul><li><p><code>addNumber()</code>使num 增加1</p><pre><code class="javascript">const app = Vue.createApp({      data() {        return {          num: 0,          text: &#39;&#39;        };      },      methods: {        addNumber() {          console.log(&#39;addnumber&#39;);          this.num++;        },      }    });</code></pre></li></ul></li></ul><h3 id="內層元件"><a href="#內層元件" class="headerlink" title="內層元件"></a>內層元件</h3><ul><li>在方法內建立函式，來觸發資料傳遞</li><li>並將<code>click</code>綁到內部元件的按鈕上。使點擊時候，會觸發$emit<ul><li>emit 名稱<code>emit-num</code><pre><code class="javascript">app.component(&#39;button-counter&#39;, {      methods: {        click() {          console.log(&#39;inner,click&#39;);          this.$emit(&#39;emit-num&#39;);        }      },      template: `&lt;button type=&quot;button&quot; @click=&quot;click&quot;&gt;add&lt;/button&gt;`    });</code></pre></li></ul></li></ul><p><img src="https://i.imgur.com/W1s9mhp.png" alt=""></p><h2 id="建立內外層元件的溝通橋樑"><a href="#建立內外層元件的溝通橋樑" class="headerlink" title="建立內外層元件的溝通橋樑"></a>建立內外層元件的溝通橋樑</h2><ul><li>使用 v-on 的方式觸發外層方法（口訣：前內、後外）<ul><li>在 div內放入子元件<code>button-counter</code></li><li><code>:emit-num=&quot;addNumber&quot;</code></li></ul></li></ul><pre><code class="javascript">&lt;div id=&quot;app&quot;&gt;          {{ num }}    &lt;button-counter v-on:emit-num=&quot;addNumber&quot;&gt;&lt;/button-counter&gt;     &lt;/div&gt;</code></pre><h2 id="練習二，資料接收"><a href="#練習二，資料接收" class="headerlink" title="練習二，資料接收"></a>練習二，資料接收</h2><h3 id="外層元件-1"><a href="#外層元件-1" class="headerlink" title="外層元件"></a>外層元件</h3><ul><li><p>接收方法為 <code>getData</code> 接收 text</p><pre><code class="javascript">const app = Vue.createApp({          data() {            return {              text: &#39;&#39;            };          },          methods: {            getData(value) {              console.log(&#39;getData&#39;, text);              this.text = value;            }          }        });</code></pre></li></ul><h3 id="內層元件-1"><a href="#內層元件-1" class="headerlink" title="內層元件"></a>內層元件</h3><ul><li>建立觸發傳遞的方式<ul><li>將內層元件<code>text: &#39;內部資料&#39;</code> 傳遞到外層<pre><code class="javascript">app.component(&#39;button-text&#39;, {data() {  return {  text: &#39;內部資料&#39;,   }},methods: {emitText() {this.emit(&#39;emit-text&#39;, this.text)   }},template: `&lt;button type=&quot;button&quot; @click=&quot;emitText&quot;&gt;emit data&lt;/button&gt;`});</code></pre><h3 id="建立內外橋樑"><a href="#建立內外橋樑" class="headerlink" title="建立內外橋樑"></a>建立內外橋樑</h3><pre><code class="javascript">&lt;h3&gt;傳遞資料狀態&lt;/h3&gt;內部傳來的文字：{{ text }}&lt;br&gt;&lt;button-text @emit-text=&quot;getData&quot;&gt;&lt;/button-text&gt;</code></pre><img src="https://i.imgur.com/avhMirS.png" alt=""></li></ul></li></ul><h2 id="emit-命名"><a href="#emit-命名" class="headerlink" title="emit 命名"></a>emit 命名</h2><p>與 props 命名一樣需要注意：</p><ul><li>在內層若以駝峰命名 <code>emitText</code><ul><li>也可以一開始內層就是用<code>-</code> 來命名即可，如<code>emit-text</code><pre><code class="javascript">emitText() { this.emit(&#39;emitText&#39;, this.text)}</code></pre></li></ul></li><li>到了要綁定的 template 上，<code>emit-text</code><pre><code class="javascript">&lt;button-text @emit-text=&quot;getData&quot;&gt;&lt;/button-text&gt;</code></pre></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;圖示：&lt;br&gt;&lt;img src=&quot;https://i.imgur.com/PxIIobu.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;emit-實作練習&quot;&gt;&lt;a href=&quot;#emit-實作練習&quot; class=&quot;headerlink&quot; title=&quot;emit 實作練習</summary>
      
    
    
    
    
    <category term="Vue" scheme="https://github.com/Eva813/Eva813.github.io.git/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js 3 -  資料傳遞 props</title>
    <link href="https://github.com/Eva813/Eva813.github.io.git/2021/09/21/vue-props/"/>
    <id>https://github.com/Eva813/Eva813.github.io.git/2021/09/21/vue-props/</id>
    <published>2021-09-21T03:42:48.000Z</published>
    <updated>2021-10-25T05:22:10.673Z</updated>
    
    <content type="html"><![CDATA[<p>因為Vue每個元件都是各自獨立，所以我們無法在各自元件去調整資料，而直接修改另一個元件的資料。<br>所以，要使元件之間可以相互溝通，就需要使用資料傳遞方式。<br>在傳遞方式：</p><ul><li>外層傳遞內層 : props</li><li>內層向外傳遞 : emit<br>當外層元件，要將資料往內層元件丟時，此過程就是使用props。</li></ul><p><img src="https://i.imgur.com/FTbHDPk.png" alt=""></p><h2 id="傳遞資料的方式："><a href="#傳遞資料的方式：" class="headerlink" title="傳遞資料的方式："></a>傳遞資料的方式：</h2><h3 id="靜態資料傳入"><a href="#靜態資料傳入" class="headerlink" title="靜態資料傳入"></a>靜態資料傳入</h3><ul><li>預期將外層傳入一個url的變數，傳進給內層使用<ul><li>photo為內部元件，在template 我希望能夠取得外層傳入的圖片(urlimg)</li><li>故在 props 以此命名，並將它綁到 template<pre><code class="javascript">app.component(&#39;photo&#39;, {  props: [&#39;url&#39;],  template: `&lt;img :src=&quot;url&quot; class=&quot;img-thumbnail&quot; alt&gt;`});</code></pre></li></ul></li><li>將上方的元件資料，加到外層元件：像是加入html屬性一樣<pre><code class="javascript">&lt;photo  url=&quot;https://images.unsplash.com/photo-1605784401368-5af1d9d6c4dc?ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&amp;ixlib=rb-1.2.1&amp;auto=format&amp;fit=crop&amp;w=600&amp;q=80&quot;&gt;&lt;/photo&gt;</code></pre></li></ul><p><img src="https://i.imgur.com/f079ziY.png" alt=""></p><h3 id="動態資源"><a href="#動態資源" class="headerlink" title="動態資源"></a>動態資源</h3><ul><li>使用 <code>v-bind</code>，綁定內部元件的props ，使資料可以跟外層元件連動</li><li>記得使用口訣： 前內、後外 =&gt;前面就是props內的名稱，後面就是外層元件的名稱<br><img src="https://i.imgur.com/BMVZtkn.png" alt=""><pre><code class="htmlembedded">&lt;h3&gt;動態資源&lt;/h3&gt;&lt;p&gt;技巧：前內、後外&lt;/p&gt;&lt;photo v-bind:urlimg=&quot;imgUrl&quot;&gt;&lt;/photo&gt;</code></pre></li></ul><h2 id="資料傳遞為-單向數據流"><a href="#資料傳遞為-單向數據流" class="headerlink" title="資料傳遞為 單向數據流"></a>資料傳遞為 單向數據流</h2><ul><li>外部所定義的資料，當往內層傳遞，是單向性</li><li>不能試圖使用v-model或各種方式，來改變props傳入的內容<ul><li>以下範例：在子元件 <code>photo2</code> 放入 <code>input</code>綁定 <code>v-model</code></li><li>當嘗試在輸入框修改網址，會出現錯誤</li></ul></li></ul><pre><code class="javascript">//外層元件綁定 url&lt;photo2 :url=&quot;imgUrl&quot;&gt;&lt;/photo2&gt;</code></pre><pre><code class="javascript">const app = Vue.createApp({    data() {    return {      imgUrl: &#39;https://images.unsplash.com/photo-1605784401368-5af1d9d6c4dc?ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&amp;ixlib=rb-1.2.1&amp;auto=format&amp;fit=crop&amp;w=600&amp;q=80&#39;,         };     },}); app.component(&#39;photo2&#39;, {    props: [&#39;url&#39;],    template: `&lt;img :src=&quot;url&quot; class=&quot;img-thumbnail&quot; alt&gt;&lt;br&gt;    &lt;input type=&quot;text&quot; v-model=&quot;url&quot;&gt; {{ url }}`     })</code></pre><p><img src="https://i.imgur.com/OmmIxpi.png" alt=""></p><p><img src="https://i.imgur.com/2BqCNTp.png" alt=""></p><h2 id="在內部元件，要為props來命名"><a href="#在內部元件，要為props來命名" class="headerlink" title="在內部元件，要為props來命名"></a>在內部元件，要為props來命名</h2><p>在命名上有些要注意的地方</p><ul><li>首字母大寫: PostData、SetItems</li><li>駝峰命名法: postData、setItems<br>要注意：在 HTML 中使用時必須使用 kebab-case (短橫線分隔)且應該為小寫。</li></ul><pre><code class="javascript">&lt;div id=&quot;app&quot;&gt; &lt;photo3 :super-url=&quot;imgUrl&quot; &gt;&lt;/photo3&gt;&lt;/div&gt;&lt;script&gt;Vue.component(&quot;photo3&quot;, {  props: [&quot;superUrl&quot;],  template: `&lt;img :src=&quot;superUrl&quot; class=&quot;img-thumbnail alt &gt;&quot;`});&lt;/script&gt;</code></pre><p><img src="https://i.imgur.com/57P1JDW.png" alt=""></p><h2 id="定義-Props-型別驗證"><a href="#定義-Props-型別驗證" class="headerlink" title="定義 Props 型別驗證"></a>定義 Props 型別驗證</h2><ul><li><p>使用型別驗證，會改用大括號，裡面放入props名稱，並用物件形式加入設定的內容</p><ul><li><code>props:{  propC: {  type: String,  required: true,  }}</code></li></ul></li><li><p>其中，可以針對該props 來設定：</p><ul><li><p><code>type</code>型別 ： 可以是 String、Number、Boolean、Array、Object、Date、Function、Symbol</p></li><li><p><code>default</code> ：如果該 prop 沒有接收到傳入的值，就會使用 default 的值作為預設值。</p></li><li><p><code>required</code> ： 是否為必填項，如果設為 true 則表示必須要有值傳入，若沒有，就會出現錯誤提示。</p><pre><code class="javascript">app.component(&#39;props-validation&#39;, {props: {// 單一型別檢查，可接受的型別 String, Number, Object, Boolean, Function(在 Vue 中可使用 Function 驗證型別)// null, undefined 會直接通過驗證propA: Function,// 多個型別檢查propB: [String, Number],// 必要值propC: {  type: String,  required: true,},// 預設值propD: {  type: Number,  default: 300},// 自訂函式propE: {  type: Object,  default() {    return {      money: 300    }  }},// 自訂驗證propF: {  validator(value) {    return value &gt; 1000  }}, },</code></pre><p><a href="https://www.hexschool.com/courses/vue3.html" target="_blank" rel="noopener">六角學院</a><br><a href="https://ithelp.ithome.com.tw/articles/10254050" target="_blank" rel="noopener">[DAY12]跟 Vue.js 認識的30天 - Vue 模組資料傳遞(<code>props</code>)</a></p></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;因為Vue每個元件都是各自獨立，所以我們無法在各自元件去調整資料，而直接修改另一個元件的資料。&lt;br&gt;所以，要使元件之間可以相互溝通，就需要使用資料傳遞方式。&lt;br&gt;在傳遞方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;外層傳遞內層 : props&lt;/li&gt;
&lt;li&gt;內層向外傳遞 : e</summary>
      
    
    
    
    
    <category term="Vue" scheme="https://github.com/Eva813/Eva813.github.io.git/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js 3 - v-on 修飾符</title>
    <link href="https://github.com/Eva813/Eva813.github.io.git/2021/09/20/Vue-modify/"/>
    <id>https://github.com/Eva813/Eva813.github.io.git/2021/09/20/Vue-modify/</id>
    <published>2021-09-20T07:06:46.000Z</published>
    <updated>2021-10-05T08:38:42.809Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/NBBY8vo.png" alt=""></p><p>修飾符有分為：<br>1.按件修飾符<br>2.滑鼠修飾符<br>3.事件修飾符</p><p><a href="https://codepen.io/Eva-go/pen/RwgMXGN" target="_blank" rel="noopener">codepen</a></p><h2 id="按鍵修飾符"><a href="#按鍵修飾符" class="headerlink" title="按鍵修飾符"></a>按鍵修飾符</h2><h3 id="1-1-別名修飾"><a href="#1-1-別名修飾" class="headerlink" title="1-1. 別名修飾"></a>1-1. 別名修飾</h3><ul><li>在特定按鍵，按下去的時候觸發<ul><li><code>.enter</code>, <code>.tab</code>, <code>.delete</code>, <code>.esc</code>, <code>.space</code>, <code>.up</code>, <code>.down</code>, <code>.left</code>, <code>.righ</code></li></ul></li><li>使用<code>.enter</code>只有再按下 enter 鍵才會觸發</li></ul><pre><code class="html">  &lt;div id=&quot;app&quot;&gt;   &lt;h6 class=&quot;mt-3&quot;&gt;別名修飾&lt;/h6&gt;  &lt;input type=&quot;text&quot; class=&quot;form-control&quot; v-model=&quot;text&quot; @keyup.enter=&quot;trigger(&#39;enter&#39;)&quot;&gt;  &lt;/div&gt;</code></pre><pre><code class="javascript">Vue.createApp({  data(){     return {    }  },  methods: {   trigger: function(name) {      console.log(name, &#39;此事件被觸發了&#39;)    },  }}).mount(&#39;#app&#39;)</code></pre><h3 id="1-2-相應按鍵時才觸發的監聽器"><a href="#1-2-相應按鍵時才觸發的監聽器" class="headerlink" title="1-2. 相應按鍵時才觸發的監聽器"></a>1-2. 相應按鍵時才觸發的監聽器</h3><ul><li>僅在按下相應按鍵時才觸發鼠標或鍵盤事件的監聽器</li><li><code>.ctrl</code>, <code>.alt</code>, <code>.shift</code>, <code>.meta</code></li><li>此範例為 <code>@keyup.shift.enter</code><pre><code class="html">&lt;h6 class=&quot;mt-3&quot;&gt;相應按鍵時才觸發的監聽器&lt;/h6&gt;&lt;input type=&quot;text&quot; class=&quot;form-control&quot; v-model=&quot;text&quot; @keyup.shift.enter=&quot;trigger(&#39;shift + Enter&#39;)&quot;&gt;</code></pre><img src="https://i.imgur.com/gQjWYVy.png" alt=""></li></ul><ol start="2"><li>滑鼠修飾符<br><code>.left</code> 只當點擊鼠標左鍵時觸發。<br><code>.right</code> 只當點擊鼠標右鍵時觸發。<br><code>.middle</code> 只當點擊鼠標中鍵時觸發。</li></ol><ul><li>按下滑鼠右鍵<br><code>&lt;span class=&quot;box&quot; @click.right=&quot;trigger(&#39;right button&#39;)&quot;&gt;</code></li></ul><pre><code class="html">          &lt;h4&gt;滑鼠修飾符&lt;/h4&gt;          &lt;h6 class=&quot;mt-3&quot;&gt;滑鼠修飾符&lt;/h6&gt;          &lt;div class=&quot;p-3 bg-primary&quot;&gt;            &lt;span class=&quot;box&quot; @click.right=&quot;trigger(&#39;right button&#39;)&quot;&gt;            &lt;/span&gt;          &lt;/div&gt;</code></pre><p><img src="https://i.imgur.com/lddG6zT.png" alt=""></p><ol start="3"><li>事件修飾符</li></ol><ul><li>不會限定，是使用滑鼠還是鍵盤，是針對事件本身來進行修飾<br><code>.stop</code> - 調用 <code>event.stopPropagation()</code>。<br><code>.prevent</code> - 調用 <code>event.preventDefault()</code>。<br><code>.capture</code> - 添加事件偵聽器時使用 capture 模式。<br><code>.self</code> - 只當事件是從偵聽器綁定的元素本身觸發時才觸發回調。<br><code>.once</code> - 只觸發一次回調。</li><li>常用的是 <code>&lt;a&gt;</code>外部連結：移除預設事件<pre><code class="html">     &lt;h4&gt;事件修飾符&lt;/h4&gt;        &lt;ul&gt;          &lt;li&gt;.stop - 調用 event.stopPropagation()。&lt;/li&gt;          &lt;li&gt;&lt;strong&gt;.prevent - 調用 event.preventDefault()。&lt;/strong&gt;&lt;/li&gt;          &lt;li&gt;.capture - 添加事件偵聽器時使用 capture 模式。&lt;/li&gt;          &lt;li&gt;.self - 只當事件是從偵聽器綁定的元素本身觸發時才觸發回調。&lt;/li&gt;          &lt;li&gt;.once - 只觸發一次回調。&lt;/li&gt;        &lt;/ul&gt;        &lt;a href=&quot;https://www.google.com/&quot; @click.prevent=&quot;trigger(&#39;prevent&#39;)&quot;&gt;加入 Prevent&lt;/a&gt;</code></pre></li></ul><p>資料來源：<br>六角學院 - Vue 3.js</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/NBBY8vo.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;修飾符有分為：&lt;br&gt;1.按件修飾符&lt;br&gt;2.滑鼠修飾符&lt;br&gt;3.事件修飾符&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://codepen.io/Eva</summary>
      
    
    
    
    
    <category term="Vue" scheme="https://github.com/Eva813/Eva813.github.io.git/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>認識 Node.js</title>
    <link href="https://github.com/Eva813/Eva813.github.io.git/2021/06/11/node-1/"/>
    <id>https://github.com/Eva813/Eva813.github.io.git/2021/06/11/node-1/</id>
    <published>2021-06-11T06:28:30.000Z</published>
    <updated>2021-10-11T06:33:48.093Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>  之前在安裝套件時，就有先安裝過 Node.js 但從沒有特別去注意，它是應用在哪一塊、可以做什麼？就找了之前 udemy 全端課程，特意拉此部分來認識一下。</p><p>Node.js，讓我們可以將js檔案拿出瀏覽器，並直接和電腦硬件互動</p><ul><li>js: 進行網頁中的實作、函式、行為的建立。動畫的執行、下拉選單</li><li>Node.js: 允許我們用JS 直接與電腦的硬體互動。例如建立桌面應用程式</li><li>此外，還能在別人的電腦或server用Node.js來用行JS。例如：使用者登入 google 並輸入詢問，而你的瀏覽器會發出請求給google servers，而在這些servers 可以真的執行JS程式碼來執行發出的請求</li></ul><p><img src="https://i.imgur.com/49D3LbW.png" alt=""></p><h2 id="如何使用Node"><a href="#如何使用Node" class="headerlink" title="如何使用Node"></a>如何使用Node</h2><ol><li>首先，建立一個資料夾 <code>intro-to-node</code>，在資料夾內建立檔案<code>index.js</code></li><li>在該資料夾位置，運行<code>node index.js</code></li></ol><p><img src="https://i.imgur.com/fsgHKd8.png" alt=""></p><ul><li>印出檔案內的console<br><img src="https://i.imgur.com/bptXcfu.png" alt=""><br><img src="https://i.imgur.com/QQ1BXXI.png" alt=""></li></ul><h2 id="node-REPL"><a href="#node-REPL" class="headerlink" title="node REPL"></a>node REPL</h2><ul><li>Read Evaluation Print Loop</li><li>要進入：就是在終端機下node<br><img src="https://i.imgur.com/gomqsjQ.png" alt=""></li><li>和google 的console有點類似<br><img src="https://i.imgur.com/hOMWtn5.png" alt=""></li><li>取得些提示 con+ tab 會列出相關的可能性<br><img src="https://i.imgur.com/ijg4eJg.png" alt=""><br><img src="https://i.imgur.com/36ZOTYu.png" alt=""><h3 id="離開"><a href="#離開" class="headerlink" title="離開"></a>離開</h3></li><li><code>.exit</code></li><li>control+c 兩次</li><li><code>clear</code> 可以清除終端機的資料<h2 id="native-node-module"><a href="#native-node-module" class="headerlink" title="native node module"></a>native node module</h2></li><li>當安裝node，他就會包含許多建立好的模組<h3 id="使用node-js-進入電腦本地端的資料"><a href="#使用node-js-進入電腦本地端的資料" class="headerlink" title="使用node.js 進入電腦本地端的資料"></a>使用node.js 進入電腦本地端的資料</h3></li><li>nodejs.org/api 可以查到所有native node module，以及使用方式說明的文件</li><li>當要使用 modual<br><img src="https://i.imgur.com/eIDZjer.png" alt=""></li></ul><p><img src="https://i.imgur.com/DDWBxTn.png" alt=""></p><ul><li>警告 jshint esversion:6<br><img src="https://i.imgur.com/zdRpkQ4.png" alt=""></li></ul><h3 id="實際應用練習：複製檔案"><a href="#實際應用練習：複製檔案" class="headerlink" title="實際應用練習：複製檔案"></a>實際應用練習：複製檔案</h3><ul><li>在原本的資料夾內建立新的檔案<br><img src="https://i.imgur.com/ndvRf3A.png" alt=""><br><img src="https://i.imgur.com/24EYw4k.png" alt=""></li><li>在index.jd 輸入該語法<br><img src="https://i.imgur.com/0oGOWsV.png" alt=""></li><li>輸入後要運行 <code>node index.js</code><br><img src="https://i.imgur.com/hCsZbOF.png" alt=""><ul><li>運行之後會看到 <code>file2</code> 建立完成<br><img src="https://i.imgur.com/YR3MLWP.png" alt=""></li></ul></li><li>若是已經建立好的檔案</li><li>在檔案內輸入資訊<code>I am file2</code><br><img src="https://i.imgur.com/9ODoKY5.png" alt=""></li><li>執行 <code>copyFileSync</code><br><img src="https://i.imgur.com/Jae1spC.png" alt=""></li></ul><hr><h2 id="NPM-package-manager"><a href="#NPM-package-manager" class="headerlink" title="NPM package manager"></a>NPM package manager</h2><ul><li>即為 Node Package Manager 的縮寫，他是套件管理工具</li><li>在安裝node 的同時，就已經裝有 NPM<br><a href="https://tw.alphacamp.co/blog/npm-node-package-manager" target="_blank" rel="noopener">NPM是什麼？了解Node Package Manager套件管理機制</a></li><li>npm init<br><img src="https://i.imgur.com/75YtfQR.png" alt=""></li><li>建立一個 package.json<br><img src="https://i.imgur.com/HdtTW6p.png" alt=""><br><img src="https://i.imgur.com/eHkTGKZ.png" alt=""></li></ul><h2 id="如何使用真實npm"><a href="#如何使用真實npm" class="headerlink" title="如何使用真實npm"></a>如何使用真實npm</h2><p><img src="https://i.imgur.com/OQ0764J.png" alt=""></p><ul><li>在要進行安裝的資料夾內，<code>npm install superheroes</code><br><img src="https://i.imgur.com/05qxzDJ.png" alt=""><br><img src="https://i.imgur.com/XOlgK2J.png" alt=""></li><li>參考文件的說明<br><img src="https://i.imgur.com/6xrdtZG.png" alt=""><ul><li>在js檔案中輸入<br><img src="https://i.imgur.com/87emqhz.png" alt=""></li><li>運行 <code>node index.js</code><br><img src="https://i.imgur.com/F9f6Qzj.png" alt=""></li></ul></li></ul><p><a href="https://blog.hiskio.com/what-is-node-js/" target="_blank" rel="noopener">什麼是 Node.js？Node.js 完整介紹懶人包！</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;  之前在安裝套件時，就有先安裝過 Node.js 但從沒有特別去注意，它是應用在哪一塊、可以做什麼？就找了之前 udemy 全端課程，特意</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Vue.js 3 -  多筆資料渲染 v-for</title>
    <link href="https://github.com/Eva813/Eva813.github.io.git/2021/05/17/Vue-v-for/"/>
    <id>https://github.com/Eva813/Eva813.github.io.git/2021/05/17/Vue-v-for/</id>
    <published>2021-05-17T08:20:22.000Z</published>
    <updated>2021-10-05T08:38:36.440Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/NBBY8vo.png" alt=""></p><h2 id="v-for-呈現多筆陣列"><a href="#v-for-呈現多筆陣列" class="headerlink" title="v-for 呈現多筆陣列"></a><code>v-for</code> 呈現多筆陣列</h2><ul><li><code>v-for= item in peopleArr</code> ， item 為 自定義名稱，後面(peopleArr)填入要迴圈的資料<ul><li>item是表示 peopleArr 陣列中每個單一物件</li></ul></li><li>key ：為帶入陣列的 key 值</li></ul><pre><code class="html">  &lt;div id=&quot;app&quot;&gt;   &lt;h3&gt;v-for 與 key&lt;/h3&gt;  &lt;p&gt; 人員介紹&lt;/p&gt;  &lt;ul&gt;    &lt;li v-for=&quot;(item, key) in peopleArr&quot;&gt;      {{ key }} - {{ item.name}} / {{ item.age }} 歲    &lt;/li&gt;  &lt;/ul&gt;  &lt;/div&gt;</code></pre><pre><code class="javascript">Vue.createApp({  data(){     return {     peopleArr: [        {          name: &#39;Ken&#39;,          age: 30,          vegan: false        },        {          name: &#39;Wong&#39;,          page: 35,          vegan: false        },        {          name: &#39;Merry&#39;,          age: 60,          vegan: false        },        {          name: &#39;Tom&#39;,          age: 30,          vegan: true        },      ],    }  },}).mount(&#39;#app&#39;)</code></pre><p><a href="https://codepen.io/Eva-go/pen/powVYmN" target="_blank" rel="noopener">codepen</a><br><img src="https://i.imgur.com/TebHrmC.png" alt=""></p><h2 id="物件迴圈"><a href="#物件迴圈" class="headerlink" title="物件迴圈"></a>物件迴圈</h2><ul><li>每個item 就是每個物件的資料</li><li>key值為物件的屬性名稱</li></ul><pre><code class="html">  &lt;div id=&quot;app&quot;&gt;   &lt;h3&gt;v-for 與 key&lt;/h3&gt;  &lt;p&gt; 人員介紹&lt;/p&gt;  &lt;ul&gt;    &lt;li v-for=&quot;(item, key) in peopleObj&quot;&gt;      {{ key }} - {{ item.name}} / {{ item.age }} 歲    &lt;/li&gt;  &lt;/ul&gt;  &lt;/div&gt;</code></pre><pre><code class="javascript">Vue.createApp({  data(){     return {     peopleObj:{        Salse: {           name: &#39;Ken&#39;,          age: 30,          vegan: false        },        Manager: {          name: &#39;Wong&#39;,          page: 35,          vegan: false        },        HumanResource: {          name: &#39;Merry&#39;,          age: 60,          vegan: false        },        Crew: {           name: &#39;Tom&#39;,          age: 30,          vegan: true        }      },    }  },}).mount(&#39;#app&#39;)</code></pre><p><img src="https://i.imgur.com/tzjh6Ah.png" alt=""></p><h2 id="v-for-與-key"><a href="#v-for-與-key" class="headerlink" title="v-for 與 key"></a>v-for 與 key</h2><h3 id="v-for-可以使用-index-當作-key-嗎？"><a href="#v-for-可以使用-index-當作-key-嗎？" class="headerlink" title="v-for 可以使用 index 當作 key 嗎？"></a>v-for 可以使用 index 當作 key 嗎？</h3><p>以六角課程為範例說明</p><pre><code class="html">&lt;h3&gt;v-for 與 key &lt;/h3&gt;  &lt;p&gt;菜單&lt;/p&gt;  &lt;ul&gt;    &lt;li v-for=&quot;(item, key) in products&quot;&gt;      {{ key }} - {{ item.name}} / {{ item.price }} 元      &lt;input type=&quot;text&quot;&gt;    &lt;/li&gt;  &lt;/ul&gt;</code></pre><pre><code class="javascript">Vue.createApp({  data(){    return {     products: [        {          name: &#39;蛋餅&#39;,          price: 30,          vegan: false        },        {          name: &#39;飯糰&#39;,          price: 35,          vegan: false        },        {          name: &#39;小籠包&#39;,          price: 60,          vegan: false        },        {          name: &#39;蘿蔔糕&#39;,          price: 30,          vegan: true        },      ],    },  method:{    reverseArray: function () {      this.products.reverse();    },  }  }}).mount(&#39;#app&#39;)</code></pre><p><img src="https://i.imgur.com/GKjdBGd.png" alt=""></p><ul><li><p>反轉之後，並沒有跟著<br><img src="https://i.imgur.com/ALe8vst.png" alt=""></p></li><li><p>綁定key之後</p><pre><code class="html">&lt;li v-for=&quot;(item, key) in products&quot; v-bind:key=&#39;item.name&#39;&gt;</code></pre></li></ul><p><img src="https://i.imgur.com/kbtUwy1.png" alt=""></p><h3 id="v-for-可以使用-index-當作-key-嗎？-1"><a href="#v-for-可以使用-index-當作-key-嗎？-1" class="headerlink" title="v-for 可以使用 index 當作 key 嗎？"></a><code>v-for</code> 可以使用 index 當作 key 嗎？</h3><p>索引是依照位置來判定，所以當資料的位置修改，索引值也會跟著變動，導致後續的渲染錯誤。<br>如果key是會變動的話，可能會導致資料的渲染錯誤</p><h3 id="如果後端提供的資料，沒有唯一索引要如何處理？"><a href="#如果後端提供的資料，沒有唯一索引要如何處理？" class="headerlink" title="如果後端提供的資料，沒有唯一索引要如何處理？"></a>如果後端提供的資料，沒有唯一索引要如何處理？</h3><p>  1.與後端溝通，為何前端要用到key的值<br>  2.拿到資料後，自己產生key，並放入該物件資料中</p><pre><code>使用v-for時，一定要用key 使用v-for時，不要拿索引當作key請使用唯一的值當作key的值</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/NBBY8vo.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;v-for-呈現多筆陣列&quot;&gt;&lt;a href=&quot;#v-for-呈現多筆陣列&quot; class=&quot;headerlink&quot; title=&quot;v-for 呈現多筆</summary>
      
    
    
    
    
    <category term="Vue" scheme="https://github.com/Eva813/Eva813.github.io.git/tags/Vue/"/>
    
    <category term="v-for" scheme="https://github.com/Eva813/Eva813.github.io.git/tags/v-for/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js 3 -  資料雙向綁定 v-model</title>
    <link href="https://github.com/Eva813/Eva813.github.io.git/2021/05/17/Vue-v-model/"/>
    <id>https://github.com/Eva813/Eva813.github.io.git/2021/05/17/Vue-v-model/</id>
    <published>2021-05-17T08:16:22.000Z</published>
    <updated>2021-10-05T08:38:31.980Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/NBBY8vo.png" alt=""></p><p>使用<code>v-model</code>來進行資料的「雙向」綁定， v-model 會根據不同的表單類別來更新元素的內容。<br>主要應用在表單類型進行綁定，常見的表單元素像是 <code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code> 以及 <code>&lt;select&gt;</code> 等。</p><h2 id="v-model-可以與-input-、textarea-綁定"><a href="#v-model-可以與-input-、textarea-綁定" class="headerlink" title="v-model 可以與 input 、textarea 綁定"></a>v-model 可以與 input 、textarea 綁定</h2><pre><code class="html">  &lt;h3&gt;input&lt;/h3&gt;     &lt;input type=&quot;text&quot; class=&quot;form-control&quot; v-model=&quot;name&quot;&gt;          {{ name }}</code></pre><pre><code class="javascript">Vue.createApp({  data(){     return {      name: &quot;小明&quot;    }  },}).mount(&#39;#app&#39;)</code></pre><p><img src="https://i.imgur.com/fuPfWXo.png" alt=""></p><p><img src="https://i.imgur.com/Vyon4w6.png" alt=""></p><pre><code class="html">&lt;h3&gt;textarea&lt;/h3&gt;          &lt;textarea cols=&quot;30&quot; rows=&quot;3&quot; class=&quot;form-control&quot; v-model=&quot;text&quot;&gt;&lt;/textarea&gt;          {{ text }}</code></pre><pre><code class="javascript">Vue.createApp({  data(){     return {      text: &quot;一段文字敘述&quot;    }  },}).mount(&#39;#app&#39;)</code></pre><p><img src="https://i.imgur.com/T7AMqwY.png" alt=""></p><p><img src="https://i.imgur.com/fxYLTcU.png" alt=""></p><h2 id="checkbox-單選框"><a href="#checkbox-單選框" class="headerlink" title="checkbox 單選框"></a>checkbox 單選框</h2><ol><li>checkbox與p段落連動</li></ol><ul><li>在input加入<code>v-model=&quot;checkAnswer&quot;</code></li><li>P段洛，放入三元運算：用來判斷當checkAnswer為true，顯示’吃飽了’;反之，’還沒’<ul><li>透過選單的勾選，來顯示 checkAnswer 是 true \ false</li></ul></li></ul><pre><code class="html">     &lt;h3&gt;checkbox 單選框&lt;/h3&gt;     &lt;p&gt;小明，你是吃飽沒？&lt;/p&gt;     &lt;p&gt;{{ checkAnswer ? '吃飽了' : '還沒'}}&lt;/p&gt;     &lt;div class=&quot;form-check&quot;&gt;     &lt;input type=&quot;checkbox&quot; class=&quot;form-check-input&quot; id=&quot;check1&quot; v-model=&quot;checkAnswer&quot;&gt;    &lt;label class=&quot;form-check-label&quot; for=&quot;check1&quot;&gt;小明回覆&lt;/label&gt;          &lt;/div&gt;</code></pre><pre><code class="javascript">Vue.createApp({  data(){     return {      checkAnswer: false,    }  },}).mount(&#39;#app&#39;)</code></pre><p><img src="https://i.imgur.com/wBR8ESD.png" alt=""></p><p><img src="https://i.imgur.com/cRDgctR.gif" alt=""></p><ol start="2"><li>checkbox 單選延伸</li></ol><ul><li>回傳單一的值，相對使用三元運算比較直觀</li><li><code>checkAnswer2</code> 是空字串，在 input 綁定後，設定false-value、true-value</li><li>將文字綁入：<code>true-value=&quot;吃飽了&quot; false-value=&quot;還沒&quot;</code>，就可以放入資料欄位上</li></ul><pre><code class="html"> &lt;h3&gt;checkbox 單選延伸&lt;/h3&gt;     &lt;p&gt;小明，你是吃飽沒？&lt;/p&gt;     &lt;p&gt;{{ checkAnswer2 }}&lt;/p&gt;     &lt;div class=&quot;form-check&quot;&gt;     &lt;input type=&quot;checkbox&quot; v-model=&quot;checkAnswer2&quot; true-value=&quot;吃飽了&quot; false-value=&quot;還沒&quot; class=&quot;form-check-input&quot;              id=&quot;check2&quot;&gt;     &lt;label class=&quot;form-check-label&quot; for=&quot;check2&quot;&gt;小明回覆&lt;/label&gt;     &lt;/div&gt;</code></pre><pre><code class="javascript">Vue.createApp({  data(){     return {      checkAnswer2: &#39;&#39;,    }  },}).mount(&#39;#app&#39;)</code></pre><p><img src="https://i.imgur.com/x4aeut8.png" alt=""></p><p><img src="https://i.imgur.com/qvyj7dH.png" alt=""></p><h2 id="checkbox-複選框"><a href="#checkbox-複選框" class="headerlink" title="checkbox 複選框"></a>checkbox 複選框</h2><ul><li><p>資料格式為陣列</p></li><li><p>覆選框的input裡面要有value</p></li><li><p>當綁定v-model，於畫面點選該項目時，會將 input 中的 value，放入的陣列中</p><ul><li>最後將資料渲染於畫面<pre><code class="html">&lt;h3&gt;checkbox 複選框&lt;/h3&gt;&lt;p&gt;你還要吃什麼？&lt;/p&gt;&lt;p&gt;{{ checkAnswer3.join('') }}&lt;/p&gt;&lt;div class=&quot;form-check&quot;&gt;   &lt;input type=&quot;checkbox&quot; class=&quot;form-check-input&quot; id=&quot;check3&quot; value=&quot;蛋餅&quot; v-model=&quot;checkAnswer3&quot;&gt;   &lt;label class=&quot;form-check-label&quot; for=&quot;check3&quot;&gt;蛋餅&lt;/label&gt;         &lt;/div&gt;&lt;div class=&quot;form-check&quot;&gt;    &lt;input type=&quot;checkbox&quot; class=&quot;form-check-input&quot; id=&quot;check4&quot; value=&quot;蘿蔔糕&quot; v-model=&quot;checkAnswer3&quot;&gt;    &lt;label class=&quot;form-check-label&quot; for=&quot;check4&quot;&gt;蘿蔔糕&lt;/label&gt;&lt;/div&gt;&lt;div class=&quot;form-check&quot;&gt;  &lt;input type=&quot;checkbox&quot; class=&quot;form-check-input&quot; id=&quot;check5&quot; value=&quot;豆漿&quot; v-model=&quot;checkAnswer3&quot;&gt;  &lt;label class=&quot;form-check-label&quot; for=&quot;check5&quot;&gt;豆漿&lt;/label&gt; &lt;/div&gt;</code></pre><pre><code class="javascript">Vue.createApp({</code></pre></li></ul><p>data(){<br>   return {</p><pre><code>checkAnswer3: [],</code></pre><p>  }<br>},</p></li></ul><p>}).mount(‘#app’)</p><pre><code>![](https://i.imgur.com/V6RUoEF.png)## v-model 修飾符修飾符為畫面上，v-model的資料和實際data中的資料在綁定之間，額外處理的小方法。1. 延遲 Lazy* 輸入文字後，要點擊外面或是按下enter，才會出現* 綁定到html的change事件：當完成輸入框的事件之後，才會綁定到資料集```html   &lt;h3&gt;修飾符&lt;/h3&gt;   &lt;h4 class=&quot;mt-3&quot;&gt;延遲 Lazy&lt;/h4&gt;     {{ lazyMsg }}   &lt;input type=&quot;text&quot; class=&quot;form-control&quot; v-model.lazy=&quot;lazyMsg&quot;&gt;</code></pre><p><img src="https://i.imgur.com/1Jp0XWl.png" alt=""></p><h2 id="純數值-Number"><a href="#純數值-Number" class="headerlink" title="純數值 Number"></a>純數值 Number</h2><p>需要用戶輸入數值，可先將type改為number,並加入修飾符</p><ul><li><code>&lt;input type=&quot;number&quot;&gt;</code>:輸入框無法輸入文字，只能輸入數字，但型別依然是string</li></ul><pre><code class="html">   &lt;h4 class=&quot;mt-3&quot;&gt;純數值 Number&lt;/h4&gt;     {{ numberMsg }}{{ typeof numberMsg }}   &lt;input type=&quot;number&quot; class=&quot;form-control&quot; v-model=&quot;numberMsg&quot;&gt;</code></pre><p><img src="https://i.imgur.com/48WNFq2.png" alt=""></p><ul><li>要確保輸入的內容為純數字型別：要加修飾符</li></ul><pre><code class="html">   &lt;h4 class=&quot;mt-3&quot;&gt;純數值 Number&lt;/h4&gt;       {{ numberMsg }}{{ typeof numberMsg }}   &lt;input type=&quot;number&quot; class=&quot;form-control&quot; v-model.number=&quot;numberMsg&quot;&gt;</code></pre><p><img src="https://i.imgur.com/ANESock.png" alt=""></p><h2 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h2><p>將資料內容的前後空白鍵，刪除</p><ul><li>應用於要輸入e-mail帳號，避免用戶不小心在前後加入空白，而造成資料錯誤<pre><code class="html"> &lt;h4 class=&quot;mt-3&quot;&gt;修剪 Trim&lt;/h4&gt;        這是一段{{ trimMsg }}緊黏的文字 &lt;input type=&quot;text&quot; class=&quot;form-control&quot; v-model.trim=&quot;trimMsg&quot;&gt;</code></pre><img src="https://i.imgur.com/SCJddsn.png" alt=""></li></ul><p>參考資料：<br><a href="https://book.vue.tw/CH1/1-4-directive.html" target="_blank" rel="noopener">重新認識 Vue.js | Kuro Hsu</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/NBBY8vo.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;v-model&lt;/code&gt;來進行資料的「雙向」綁定， v-model 會根據不同的表單類別來更新元素的內容。&lt;br&gt;主要應用在表單類型進行綁</summary>
      
    
    
    
    
    <category term="Vue" scheme="https://github.com/Eva813/Eva813.github.io.git/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js 3 - 綁定方式多變化</title>
    <link href="https://github.com/Eva813/Eva813.github.io.git/2021/05/16/Vue-bind2/"/>
    <id>https://github.com/Eva813/Eva813.github.io.git/2021/05/16/Vue-bind2/</id>
    <published>2021-05-16T08:17:30.000Z</published>
    <updated>2021-10-05T08:38:07.644Z</updated>
    
    <content type="html"><![CDATA[<h2 id="動態屬性綁定-注意大小寫"><a href="#動態屬性綁定-注意大小寫" class="headerlink" title="動態屬性綁定(注意大小寫)"></a>動態屬性綁定(注意大小寫)</h2><ul><li>宣告變數dynamic，將 dynamic 綁定於點擊事件上 <code>:click=&quot;dynamic = dynamic === &#39;disabled&#39; ? &#39;readonly&#39;:&#39;disabled&#39;&quot;</code><ul><li>如果變數結果是 disable 的話就會切換成 readonly，反之，就會切換為 disabled</li></ul></li><li>接著可以將值動態地加入 HTML 屬性上 <code>:[dynamic]</code><ul><li>綁定後，就會發現輸入框隨著切換，有不同效果<pre><code class="html">&lt;h3&gt;動態屬性綁定(注意大小寫)&lt;/h3&gt;&lt;button type=&quot;button&quot;v-on:click=&quot;dynamic = dynamic === &#39;disabled&#39; ? &#39;readonly&#39;:&#39;disabled&#39;&quot;&gt;切換為 {{ dynamic }}&lt;/button&gt;&lt;br&gt;&lt;input type=&quot;text&quot; :[dynamic] :value=&quot;name&quot;&gt;</code></pre><pre><code class="javascript">//JS</code></pre></li></ul></li></ul><p>Vue.createApp({</p><p>  data(){<br>     return {<br>      dynamic: ‘disabled’,<br>      breakfastShop: {<br>      name: ‘奇蹟早餐’,<br>        imgUrl: ‘<a href="https://images.unsplash.com/photo-1600182610361-4b4d664e07b9?ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&amp;ixlib=rb-1.2.1&amp;auto=format&amp;fit=crop&amp;w=200&amp;q=80&#39;" target="_blank" rel="noopener">https://images.unsplash.com/photo-1600182610361-4b4d664e07b9?ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&amp;ixlib=rb-1.2.1&amp;auto=format&amp;fit=crop&amp;w=200&amp;q=80&#39;</a>,<br>        resizeImg: ‘<a href="https://images.unsplash.com/photo-1600182610361-4b4d664e07b9?ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&amp;ixlib=rb-1.2.1&amp;auto=format&amp;fit=crop&amp;q=80&#39;" target="_blank" rel="noopener">https://images.unsplash.com/photo-1600182610361-4b4d664e07b9?ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&amp;ixlib=rb-1.2.1&amp;auto=format&amp;fit=crop&amp;q=80&#39;</a><br>      },<br>    }<br>  }<br>}).mount(‘#app’)</p><pre><code>`readony`:可以選擇輸入框，但無法輸入值`disabled`:無法點選輸入框![](https://i.imgur.com/GfAhQJk.png)![](https://i.imgur.com/YUf3XZk.png)</code></pre><p>再次補充說明：<br>    1. dynamic = 【這邊是最前面的變數，用來存放後面回傳回來的值】<br>    2. dynamic === ‘disabled’ ? 【這邊就是中間判斷式的部分，判斷 dynamic 變數是否為 ‘disabled’】<br>    3. ‘readonly’:’disabled’ 【這邊就是最後面的值，會依照前方的判斷式來決定回傳 ‘readonly’ 還是 ‘disabled’，如果判斷式結果為 True 則回傳 ‘readonly’ ，反之回傳 ‘disabled’】</p><pre><code>## HTML 樣式綁定樣式綁定是時常使用到的效果，能透過此方式，使顏色改變、增加一點簡易動畫的效果。## 範例解說* 替 box 增加旋轉效果* 綁定class可以用陣列方式、或物件方式來添加，以下範例為物件方式  * 物件key值對應 className，物件的值是對應 true\false(判斷式)  * 若className 有 `-` ， 注意要 &quot;bg-danger&quot;* 事件的綁定 `change()` 透過函式來切換 true\false` this[key] = !this[key];`* 切換是否旋轉、切換背景色 ```html&lt;style&gt;.box {  background-color: var(--bs-light);  border: 1px solid var(--bs-gray);  width: 80px;  height: 80px;}.box {  transition: all .5s;}.box.rotate {  transform: rotate(45deg)}&lt;/style&gt; &lt;h2&gt;切換 Class&lt;/h2&gt;          &lt;h3&gt;物件寫法&lt;/h3&gt;          &lt;!-- 物件key值對應 className，物件的值是對應 true\false --&gt;          &lt;div class=&quot;box&quot; :class=&quot;{ rotate: isTransform ,&#39;bg-danger&#39;:boxColor}&quot;&gt;&lt;/div&gt;          &lt;hr&gt;          &lt;button class=&quot;btn btn-outline-primary&quot; v-on:click=&quot;change(&#39;isTransform&#39;)&quot;&gt;選轉物件&lt;/button&gt;          &lt;button class=&quot;btn btn-outline-primary ms-1&quot; v-on:click=&quot;change(&#39;boxColor&#39;)&quot;&gt;切換色彩&lt;/button&gt;</code></pre><pre><code class="javascript">const App = {  data() {    return {      isTransform: true,      boxColor: false,    };  },  methods: {    change: function (key) {      this[key] = !this[key];    },    addClass(arr) {      this.arrayClass.push(...arr);    }  },};Vue.createApp(App).mount(&#39;#app&#39;);</code></pre><p><img src="https://i.imgur.com/KFqN9hz.png" alt=""></p><p><img src="https://i.imgur.com/b9OCub3.gif" alt=""></p><h3 id="整合為一個物件"><a href="#整合為一個物件" class="headerlink" title="整合為一個物件"></a>整合為一個物件</h3><p>將上個範例的兩個class樣式，整合成一個物件</p><pre><code class="html"> &lt;hr class=&quot;mt-4&quot;&gt;   &lt;h3&gt;物件寫法 2&lt;/h5&gt;         &lt;div class=&quot;box&quot; :class=&#39;classObj&#39;&gt;&lt;/div&gt;</code></pre><pre><code class="javascript">const App = {  data() {    return {      isTransform: true,      boxColor: false,      classObj:{        rotata: true,        &quot;bg-danger&quot;: true,      }    };  },  methods: {    change: function (key) {      this[key] = !this[key];    },    addClass(arr) {      this.arrayClass.push(...arr);    }  },};Vue.createApp(App).mount(&#39;#app&#39;);</code></pre><p><img src="https://i.imgur.com/41AKFc8.png" alt=""></p><p><img src="https://i.imgur.com/StALtsi.png" alt=""></p><h2 id="綁定樣式，陣列寫法"><a href="#綁定樣式，陣列寫法" class="headerlink" title="綁定樣式，陣列寫法"></a>綁定樣式，陣列寫法</h2><ul><li>針對單一元素，加入多個class<ul><li>此方式就不用 true\false 的判斷動作，只要綁定在陣列之中的樣式，就會套入效果</li><li>像是範例，就是使按鈕背景色彩為紅色(‘btn-danger’)、無法點擊(‘disabled’)<pre><code class="html">&lt;h4&gt;陣列寫法&lt;/h4&gt;        &lt;button class=&quot;btn&quot; :class=&quot;[&#39;disabled&#39;,&#39;btn-danger&#39;]&quot;&gt;請操作本元件&lt;/button&gt;        &lt;button type=&quot;button&quot; class=&quot;btn btn-outline-primary&quot; v-on:click=&quot;addClass([&#39;btn-primary&#39;, &#39;active&#39;])&quot;&gt;為陣列加入          Class&lt;/button&gt;</code></pre><img src="https://i.imgur.com/RZFOrdK.png" alt=""></li></ul></li></ul><ul><li>另一種，製作陣列，並將陣列放入<ul><li>將arrayClass，綁定在標籤的class上</li><li>在點擊按鈕，綁定點擊事件，<code>addClass(arr)</code>，在該函式傳入參數，將陣列內容加入arrayClass，並套入綁定的標籤上</li><li>相對應的方法：<br><img src="https://i.imgur.com/VFfDXPY.png" alt=""></li></ul></li></ul><pre><code class="html">&lt;h4&gt;陣列寫法&lt;/h4&gt;  &lt;button class=&quot;btn&quot; :class=&quot;arrayClass&quot;  &gt;請操作本元件&lt;/button&gt;  &lt;button type=&quot;button&quot;    class=&quot;btn btn-outline-primary&quot;    v-on:click=&quot;addClass([&#39;btn-primary&#39;, &#39;active&#39;])&quot;&gt;為陣列加入 Class&lt;/button&gt;</code></pre><pre><code class="javascript">const App = {  data() {    return {       // Array 操作      arrayClass: [&#39;&#39;],    };  },  methods: {    addClass(arr) {      this.arrayClass.push(...arr);    }  },};Vue.createApp(App).mount(&#39;#app&#39;);</code></pre><p><img src="https://i.imgur.com/PZd0sKO.png" alt=""></p><ul><li><code>btn-primary</code>:背景色為綠色<br><img src="https://i.imgur.com/S0zLJKb.png" alt=""></li></ul><h4 id="補充：混合寫法"><a href="#補充：混合寫法" class="headerlink" title="補充：混合寫法"></a>補充：混合寫法</h4><ul><li>將bootstrap的class放入，且加入arrayClass<ul><li><code>:class=&quot;[arrayClass,&#39;text-danger&#39;]</code>，也就是除了放入 arrayClass 這個變數之外，我們還可以放入新的class給予不同樣式<pre><code class="html">&lt;h4&gt;陣列寫法&lt;/h4&gt;&lt;button class=&quot;btn&quot; :class=&quot;[arrayClass,&#39;text-danger&#39;]&quot;&gt;請操作本元件&lt;/button&gt;  &lt;button type=&quot;button&quot; class=&quot;btn btn-outline-primary&quot; v-on:click=&quot;addClass([&#39;btn-primary&#39;, &#39;active&#39;])&quot;&gt;為陣列加入          Class&lt;/button&gt;</code></pre></li></ul></li></ul><p><img src="https://i.imgur.com/d3dqSTj.png" alt=""></p><h2 id="行內樣式style"><a href="#行內樣式style" class="headerlink" title="行內樣式style"></a>行內樣式style</h2><h4 id="要綁定style的時候"><a href="#要綁定style的時候" class="headerlink" title="要綁定style的時候"></a>要綁定style的時候</h4><ul><li>key會帶入style的屬性(注意要以駝峰式)，如background-color，要改為backgroundColor</li><li>值則是帶入style相對應的值</li></ul><pre><code class="html">&lt;h2&gt;行內樣式&lt;/h2&gt;            &lt;h4&gt;綁定行內樣式&lt;/h4&gt;            &lt;div class=&quot;box&quot; :style=&quot;{backgroundColor:&#39;red&#39;}&quot;&gt;&lt;/div&gt;            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</code></pre><h3 id="加入準備好的資料格式"><a href="#加入準備好的資料格式" class="headerlink" title="加入準備好的資料格式"></a>加入準備好的資料格式</h3><ul><li><p>將設定好的物件，裡面有包含數個樣式，直接綁定至style<br><img src="https://i.imgur.com/z93Jmam.png" alt=""></p></li><li><p>背景色彩，紅色，邊框5px<br><img src="https://i.imgur.com/lWYdxIi.png" alt=""></p></li></ul><h3 id="同時多個樣式"><a href="#同時多個樣式" class="headerlink" title="同時多個樣式"></a>同時多個樣式</h3><ul><li>以陣列裡面包多個物件<pre><code class="html">&lt;div class=&quot;box&quot; :style=&quot;[styleObject,styleObject2]&quot;&gt;&lt;/div&gt;</code></pre><img src="https://i.imgur.com/11h8F7J.png" alt=""></li></ul><p><img src="https://i.imgur.com/62sDl0J.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;動態屬性綁定-注意大小寫&quot;&gt;&lt;a href=&quot;#動態屬性綁定-注意大小寫&quot; class=&quot;headerlink&quot; title=&quot;動態屬性綁定(注意大小寫)&quot;&gt;&lt;/a&gt;動態屬性綁定(注意大小寫)&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;宣告變數dynamic，將 dynamic </summary>
      
    
    
    
    
    <category term="Vue" scheme="https://github.com/Eva813/Eva813.github.io.git/tags/Vue/"/>
    
  </entry>
  
</feed>
