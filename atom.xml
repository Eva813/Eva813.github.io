<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Let&#39;s Code</title>
  
  
  <link href="https://github.com/Eva813/Eva813.github.io.git/atom.xml" rel="self"/>
  
  <link href="https://github.com/Eva813/Eva813.github.io.git/"/>
  <updated>2021-11-28T08:30:09.833Z</updated>
  <id>https://github.com/Eva813/Eva813.github.io.git/</id>
  
  <author>
    <name>Eva Chan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TypeScript 基礎介紹 (2)</title>
    <link href="https://github.com/Eva813/Eva813.github.io.git/2021/11/27/TS-2/"/>
    <id>https://github.com/Eva813/Eva813.github.io.git/2021/11/27/TS-2/</id>
    <published>2021-11-27T01:44:33.000Z</published>
    <updated>2021-11-28T08:30:09.833Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/xGK5aDO.png" alt=""></p><p>要熟悉 TypeScript 的型別訂定，並不容易，而且撰寫時也會花費較多的時間，但好處是減少程式碼的錯誤，也讓協作者更容易解讀對方撰寫的程式碼。<br>萬事起頭難，不同的地方就是多讀幾次，或是尋找相關的範例來相呼應！</p><h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><p>傳統方法中，JavaScript 透過建構函式實現類別的概念，透過原型鏈實現繼承。而在 ES6 中，我們終於迎來了 class。</p><ul><li><p>定義一切事務的抽象特點</p></li><li><p>object  ：class 的實例  new Class 生成</p></li><li><p>物件導向 OOP(Object Oriented Programming) ：三大特性 封裝、繼承、多型</p><ul><li>封裝（Encapsulation）：將對資料的操作細節隱藏起來，只暴露對外的介面。外界呼叫端不需要（也不可能）知道細節，就能透過對外提供的介面來訪問該物件，同時也保證了外界無法任意更改物件內部的資料</li><li>繼承（Inheritance）：子類別繼承父類別，子類別除了擁有父類別的所有特性外，還有一些更具體的特性</li><li>多型（Polymorphism）：由繼承而產生了相關的不同的類別，對同一個方法可以有不同的響應<h3 id="複習下-ES6-撰寫方式"><a href="#複習下-ES6-撰寫方式" class="headerlink" title="複習下 ES6 撰寫方式"></a>複習下 ES6 撰寫方式</h3></li></ul></li><li><p>使用 class 定義類別，使用 constructor 定義建構函式。</p></li></ul><pre><code class="javascript">class Animal{    constructor(name){        this.name = name;    }     run () {       return `${this.name} is running`     }}const snake = new Animal(&#39;lily&#39;)console.log(snake.run()); // lily is running// 繼承的特性（繼承父類的屬性及方法）， 繼承 run 的方法class Dog extends Animal {  bark() {    return `${this.name} is barking`  }}const bao = new Dog(&#39;bao&#39;)console.log(bao.run()) // bao is runningconsole.log(bao.bark()) // bao is  barking</code></pre><ul><li>使用 extends 關鍵字實現繼承</li><li>这里我们重寫構造函式，注意在子類的構造函式中，必須使用 super 調用父類的方法，否則會報錯。</li></ul><pre><code class="typescript">// class Cat extends Animal {  constructor(name) {    super(name)    console.log(this.name) //maomao  }  run() {      // run 方法重寫    return &#39;Meow, &#39; + super.run()  }}const maomao = new Cat(&#39;maomao&#39;)console.log(maomao.run()) //Meow, maomao is runing</code></pre><h4 id="TypeScript-中的-class"><a href="#TypeScript-中的-class" class="headerlink" title="TypeScript 中的 class"></a>TypeScript 中的 class</h4><p>TypeScript 可以使用三種訪問修飾符（Access Modifiers）</p><ul><li>public 修飾的屬性或方法是公有的，可以在任何地方被調用到，預設所有的屬性和方法都是 public 的</li><li>private 修飾的屬性或方法是私有的，不能在声明它的类的外部調用</li><li>protected 修飾的屬性或方法是受保护的，它和 private 類似，區别是它在子類中也是允许被訪問的<br>例子說明：</li><li>name 被設定為了 public，所以直接訪問實例的 name 屬性是允許的。</li></ul><pre><code class="typescript">class Animal {    public name;    public constructor(name) {        this.name = name;    }}let a = new Animal(&#39;Jack&#39;);console.log(a.name); // Jacka.name = &#39;Tom&#39;;console.log(a.name); // Tom</code></pre><ul><li>希望有的屬性是無法直接存取的，這時候就可以用 private 了：</li><li>name 設為 private</li></ul><pre><code class="typescript">class Animal {    private name;    public constructor(name) {        this.name = name;    }}let a = new Animal(&#39;Jack&#39;);console.log(a.name); // Jacka.name = &#39;Tom&#39;;// index.ts(9,13): error TS2341: Property &#39;name&#39; is private and only accessible within class &#39;Animal&#39;.// index.ts(10,1): error TS2341: Property &#39;name&#39; is private and only accessible within class &#39;Animal&#39;.</code></pre><ul><li>使用 private 修飾的屬性或方法，在子類別中也是不允許訪問的：</li></ul><pre><code class="typescript">class Animal {    private name;    public constructor(name) {        this.name = name;    }}class Cat extends Animal {    constructor(name) {        super(name);        console.log(this.name);     }}// index.ts(11,17): error TS2341: Property &#39;name&#39; is private and only accessible within class &#39;Animal&#39;.</code></pre><ul><li>而如果是用 protected 修飾，則允許在子類別中訪問：</li><li>將上述程式碼修改一下</li></ul><pre><code class="typescript">class Animal {    protected name;    public constructor(name) {        this.name = name;    }}</code></pre><h3 id="類別-class-的型別"><a href="#類別-class-的型別" class="headerlink" title="類別 class 的型別"></a>類別 class 的型別</h3><p>給類別加上 TypeScript 的型別很簡單，與介面類似：</p><pre><code class="typescript">class Animal {    name: string;    constructor(name: string) {        this.name = name;    }    sayHi(): string {      return `My name is ${this.name}`;    }}let a: Animal = new Animal(&#39;Jack&#39;);console.log(a.sayHi()); // My name is Jack</code></pre><p><a href="https://willh.gitbook.io/typescript-tutorial/advanced/class" target="_blank" rel="noopener">類別</a></p><h3 id="class-與-interface"><a href="#class-與-interface" class="headerlink" title="class 與 interface"></a>class 與 interface</h3><ul><li>介面（Interfaces）：不同類別之間公有的屬性或方法，可以抽象成一個介面。介面可以被類別實現（implements）。一個類別只能繼承自另一個類別，但是可以實現多個介面</li><li>在 物件導向 世界中，一個 class 只能繼承自另外一個class</li><li>有時候不同 class 之前，可以有共同的特性，使用子類繼承父類的方法很難來完成</li><li>class 可以使用 implements 來實現 interface （提高 OOP 的靈活性）</li></ul><h4 id="範例一："><a href="#範例一：" class="headerlink" title="範例一："></a>範例一：</h4><ul><li>有 車子和手機，都有打開radio的功能</li><li>可以將兩個共有的抽取為一個 interface</li></ul><pre><code class="typescript">class Car  {  switchRadio(trigger: boolean) {  }}class Cellphone {  switchRadio(trigger: boolean) {  }}</code></pre><h4 id="可以將兩個共有的抽取為一個-interface"><a href="#可以將兩個共有的抽取為一個-interface" class="headerlink" title="可以將兩個共有的抽取為一個 interface"></a>可以將兩個共有的抽取為一個 interface</h4><ul><li>void =&gt; 代表什麼都不返回</li><li>在class 後面放入  implements 讓類去實現它</li></ul><pre><code class="typescript">interface Radio {  switchRadio(trigger: boolean): void;}class Car implements Radio {  switchRadio(trigger) {    return 123  }}class Cellphone implements Radio {  switchRadio() {  }}</code></pre><h4 id="範例二"><a href="#範例二" class="headerlink" title="範例二"></a>範例二</h4><ul><li>新特性為 檢查電池的容量</li><li>是手機有，但汽車沒有的</li><li>所以新建立一個 interface （檢查battery）<ul><li>此功能只有手機有，所以放在手機的class</li></ul></li></ul><pre><code class="typescript">interface Battery {  checkBatteryStatus(): void;}// 要實現多个介面，我们只需要中間用 都好 隔开即可。class Cellphone implements Radio, Battery {  switchRadio() {  }  checkBatteryStatus() {  }}</code></pre><h4 id="此外-interface-之間有繼承關係"><a href="#此外-interface-之間有繼承關係" class="headerlink" title="此外 interface 之間有繼承關係"></a>此外 interface 之間有繼承關係</h4><ul><li>建立 radioWithBattery 繼承 Radio ，裡面再放入檢查電量的設定</li></ul><pre><code class="typescript">interface radioWithBattery extends Radio {  checkBatteryStatus(): void;}class Cellphone implements radioWithBattery {  switchRadio() {  }  checkBatteryStatus() {  }}</code></pre><p><a href="https://willh.gitbook.io/typescript-tutorial/advanced/class-and-interfaces" target="_blank" rel="noopener">類別與介面</a></p><h2 id="enum-列舉"><a href="#enum-列舉" class="headerlink" title="enum 列舉"></a>enum 列舉</h2><ul><li>常數指執行程序中不會被改變的值，在 JS 中我們一般會用 const 來宣告</li><li>但有些取值是在一定範圍內的一系列常數。<ul><li>如：一周內七天、三原色(紅、黃、藍)、方向(上、下、左、右)<h3 id="範例一"><a href="#範例一" class="headerlink" title="範例一"></a>範例一</h3></li></ul></li><li>數字列舉</li><li>列舉成員會被賦值為從0，開始遞增</li></ul><pre><code class="typescript">// 數字列舉，一个數字列舉可以用 enum 这个關鍵詞來定義，我们定義一系列的方向，然后这里面的值，列舉成员会被赋值为從 0 开始遞增的數字,enum Direction {  Up,  Down,  Left,  Right,}console.log(Direction.Up) //0// 還有一个神奇的點是這個列舉还做了反向映射console.log(Direction[0]) //up</code></pre><p><img src="https://i.imgur.com/VMRV8oM.png" alt=""></p><ul><li>可以手動賦予值</li><li>未手動賦值的列舉項會接著上一個列舉項遞增。</li></ul><pre><code class="typescript">  Up = 10,  Down,  Left,  Right,}console.log(Direction.Down) // 11 ，後面的項目數值會遞增console.log(Direction[0]) //up</code></pre><h3 id="範例二-1"><a href="#範例二-1" class="headerlink" title="範例二"></a>範例二</h3><pre><code class="typescript">// 字符串列舉enum Direction {  Up = &#39;UP&#39;,  Down = &#39;DOWN&#39;,  Left = &#39;LEFT&#39;,  Right = &#39;RIGHT&#39;,}const value = &#39;UP&#39;if (value === Direction.Up) {  console.log(&#39;go up!&#39;)}</code></pre><h3 id="範例三"><a href="#範例三" class="headerlink" title="範例三"></a>範例三</h3><ul><li>常數列舉<ul><li>編譯後的邏輯變少了</li><li>使用常數列舉會內連列舉的用法並且不會將設定的列舉編譯成 JS 程式碼</li></ul></li></ul><pre><code class="typescript">const  enum Direction {  Up = &#39;UP&#39;,  Down = &#39;DOWN&#39;,  Left = &#39;LEFT&#39;,  Right = &#39;RIGHT&#39;,}const value = &#39;UP&#39;if (value === Direction.Up) {  console.log(&#39;go up!&#39;)}</code></pre><p><img src="https://i.imgur.com/Fp2XF0y.png" alt=""></p><hr><h2 id="泛型-Generics"><a href="#泛型-Generics" class="headerlink" title="泛型 Generics"></a>泛型 Generics</h2><ul><li>要解決什麼問題<ul><li>建立函式 echo 參數為 arg ，接著宣告變數傳入參數</li><li>但其中的型別沒有設定</li><li>傳入和返回的型別無法統一</li></ul></li></ul><pre><code class="typescript">function echo(arg) {  return arg}const result = echo(123)// 這時候我們發現了一個問題，我们傳入了數字，但是返回了 any</code></pre><p><img src="https://i.imgur.com/lo6XFH8.png" alt=""></p><ul><li>當在建構 function、internet及Class 時，你會希望這些component都能被重複運用的 Generic(泛型)提供了一個彈性的作法。</li><li>語法是: <code>&lt;T&gt;</code></li></ul><h3 id="範例一-1"><a href="#範例一-1" class="headerlink" title="範例一"></a>範例一</h3><ul><li>泛型（Generics）是指在定義function、internet及Class的时候，不预先指定具體的型別，而在使用的时候再指定型別的一種特性。</li></ul><pre><code class="typescript">function echo&lt;T&gt;(arg: T): T {  return arg}const result = echo(123)</code></pre><p><img src="https://i.imgur.com/X4quRIj.png" alt=""></p><h3 id="範例二-傳入多個"><a href="#範例二-傳入多個" class="headerlink" title="範例二 傳入多個"></a>範例二 傳入多個</h3><pre><code class="typescript">function swap&lt;T, U&gt;(tuple: [T, U]): [U, T] {  return [tuple[1], tuple[0]]}const result = swap([&#39;string&#39;, 123])</code></pre><p><img src="https://i.imgur.com/hJ5IqSY.png" alt=""></p><h3 id="泛型第二部分-约束泛型"><a href="#泛型第二部分-约束泛型" class="headerlink" title="泛型第二部分 - 约束泛型"></a>泛型第二部分 - 约束泛型</h3><ul><li>帶有「限制」的泛型</li></ul><pre><code class="typescript">function echoWithArr&lt;T&gt;(arg: T): T {  console.log(arg.length)  return arg}// 上例中，泛型 T 不一定包含属性 length，我们可以给他傳入任意型別，當然有些不包括 length 属性，那样就會報錯// 我們使用了 extends 約束了泛型 T 必須符合介面 IWithLength 的形狀，也就是必須包含 length 屬性。interface IWithLength {  length: number;}function echoWithLength&lt;T extends IWithLength&gt;(arg: T): T {  console.log(arg.length)  return arg}echoWithLength(&#39;str&#39;)const result3 = echoWithLength({length: 10})const result4 = echoWithLength([1, 2, 3])//此時如果呼叫 loggingIdentity 的時候，傳入的 arg 不包含 length，那麼在編譯階段就會報錯了echoWithLength(7);// index.ts(10,17): error TS2345: Argument of type &#39;7&#39; is not assignable to parameter of type &#39;Lengthwise&#39;</code></pre><h3 id="泛型第三部分-泛型在-class-和-interface-中的使用"><a href="#泛型第三部分-泛型在-class-和-interface-中的使用" class="headerlink" title="泛型第三部分 - 泛型在 class 和 interface 中的使用"></a>泛型第三部分 - 泛型在 class 和 interface 中的使用</h3><ol><li>泛型在 class 的使用</li></ol><ul><li>在第一個程式中存在一个问题，它允許你向 Queue 中添加任何型別的數據，當然，當數據被彈出隊列时，也可以是任意類型</li><li>在下方的範例中，看起来可以向隊列中添加 string 型別的數據，但是那麼在使用的過程中，就會出現無法捕捉的錯誤</li></ul><pre><code class="typescript">class Queue {  private data = [];  push(item) {    return this.data.push(item)  }  pop() {    return this.data.shift()  }}const queue = new Queue()queue.push(1)queue.push(&#39;str&#39;)console.log(queue.pop().toFixed())console.log(queue.pop().toFixed())</code></pre><pre><code class="typescript">class Queue&lt;T&gt; {  private data = [];  push(item: T) {    return this.data.push(item)  }  pop(): T {    return this.data.shift()  }}const queue = new Queue&lt;number&gt;()</code></pre><ol start="2"><li>泛型在  interface 中的使用</li></ol><ul><li>之前提過可以使用介面的方式來定義一個函式需要符合的形狀</li><li>當然也可以使用含有泛型的介面來定義函式的形狀：</li></ul><pre><code class="typescript">//泛型和 interfaceinterface KeyPair&lt;T, U&gt; {  key: T;  value: U;}let kp1: KeyPair&lt;number, string&gt; = { key: 1, value: &quot;str&quot;}let kp2: KeyPair&lt;string, number&gt; = { key: &quot;str&quot;, value: 123}let arr:number[] = [1,2,3];let arrTwo:Array&lt;number&gt; = [1,2,3]</code></pre><p><img src="https://i.imgur.com/6GXBwCI.png" alt=""></p><p>interface 搭配泛型之后，可以靈活的返回不同的型別</p><ul><li><p>創建一个拥有特定型別的容器，class 和 泛型 仿佛给一个容器貼上標籤一样</p></li><li><p>泛型就好像一个可變的參數，在用的时候傳入，生成这個不同型別的一个容器，</p></li><li><p>上個部分的用它来靈活的约束参数的型別，不需要參數是一个特别死板的型別，不希望他是一个特定 string、number 型別，我要傳入的参數必须有某某屬性、某某方法，否則就會報錯。</p></li><li><p>在函式使用的时候，函式的这个型別推斷，不會進入到函式中，所以使用表達式，没法明確建立型別的绑定，用泛型可以让我们打破這個鴻溝，這個时候就可以返回它傳入的類型。</p><h2 id="Type-Aliases"><a href="#Type-Aliases" class="headerlink" title="Type Aliases"></a>Type Aliases</h2></li><li><p>就是给型別起一個别名，讓它可以更方便的被重用。</p></li></ul><pre><code class="typescript">let sum: (x: number, y: number) =&gt; numberconst result = sum(1,2)type PlusType = (x: number, y: number) =&gt; numberlet sum2: PlusType// 支持聯合type StrOrNumber = string | numberlet result2: StrOrNumber = &#39;123&#39;result2 = 123 //沒有錯// 字符串字面量 ，類似在列舉的常數變量type Directions = &#39;Up&#39; | &#39;Down&#39; | &#39;Left&#39; | &#39;Right&#39;// 使toWhere 這個變量為 Direction 類型let toWhere: Directions = &#39;Up&#39;</code></pre><ul><li>我們使用 type 定了一個字串字面量型別 EventNames，它只能取三種字串中的一種。<br>注意，型別別名與字串字面量型別都是使用 type 進行定義。</li></ul><pre><code class="typescript">type EventNames = &#39;click&#39; | &#39;scroll&#39; | &#39;mousemove&#39;;function handleEvent(ele: Element, event: EventNames) {    // do something}handleEvent(document.getElementById(&#39;hello&#39;), &#39;scroll&#39;);  // 沒問題handleEvent(document.getElementById(&#39;world&#39;), &#39;dbclick&#39;); // 報錯，event 不能為 &#39;dbclick&#39;// index.ts(7,47): error TS2345: Argument of type &#39;&quot;dbclick&quot;&#39; is not assignable to parameter of type &#39;EventNames&#39;.</code></pre><h2 id="Intersection-Types"><a href="#Intersection-Types" class="headerlink" title="Intersection Types"></a>Intersection Types</h2><ul><li>使用 <code>&amp;</code> 符號</li><li>經過上面的 type 使 IName 就有了 name 和 age兩個屬性在裡面<ul><li>和interface 的 extends 有點類似，都是為了實現物件形狀組合和擴展</li></ul></li></ul><pre><code class="typescript">interface IName  {  name: string}type IPerson = IName &amp; { age: number }// 經過上面的 type 使 IName 就有了 name 和 age兩個屬性在裡面let person: IPerson = { name: &#39;hello&#39;, age: 12}</code></pre><p>什麼时候用介面，什麼时候用 Type Aliases：</p><ul><li>interface 是 docker typing 的實現方式，是一種獨特類型，和extends class  implememts 有關的用interface ，</li><li>和交叉，聯合型別的有關的用 Type Aliases；</li></ul><h2 id="內建物件"><a href="#內建物件" class="headerlink" title="內建物件"></a>內建物件</h2><h3 id="DOM-和-BOM-的內建物件"><a href="#DOM-和-BOM-的內建物件" class="headerlink" title="DOM 和 BOM 的內建物件"></a>DOM 和 BOM 的內建物件</h3><p>DOM 和 BOM 提供的內建物件有：<br>Document、HTMLElement、Event、NodeList 等。<br>TypeScript 中會經常用到這些型別：</p><pre><code class="typescript">let body: HTMLElement = document.body;let allDiv: NodeList = document.querySelectorAll(&#39;div&#39;);document.addEventListener(&#39;click&#39;, function(e: MouseEvent) {  // Do something});</code></pre><h3 id="ECMAScript-的內建物件"><a href="#ECMAScript-的內建物件" class="headerlink" title="ECMAScript 的內建物件"></a>ECMAScript 的內建物件</h3><ul><li>Boolean、Error、Date、RegExp 等。</li></ul><pre><code class="typescript">let b: Boolean = new Boolean(1);let e: Error = new Error(&#39;Error occurred&#39;);let d: Date = new Date();let r: RegExp = /[a-z]/;</code></pre><p><a href="https://github.com/Microsoft/TypeScript/tree/main/src/lib">TypeScript 內置</a></p><h2 id="Utility-Types"><a href="#Utility-Types" class="headerlink" title="Utility Types"></a>Utility Types</h2><p><a href="https://www.typescriptlang.org/docs/handbook/utility-types.html" target="_blank" rel="noopener">官方</a><br>Typescript 還提供了一些功能性，帮助性的型別，這些型別，大家在 JS 的世界是看不到的，這些型別叫做 utility types，提供一些簡潔明快而且非常方便的功能。</p><ul><li>使用  Partial</li><li>Omit</li></ul><pre><code class="typescript">// partial，它可以把傳入的型別都變成可選interface IPerson {  name: string  age: number}let viking: IPerson = { name: &#39;viking&#39;, age: 20 }type IPartial = Partial&lt;IPerson&gt;let viking2: IPartial = { } //可以都不傳，也不會報錯// Omit，它返回的型別可以忽略傳入型別的某个屬性// 以下範例 將 name 忽略掉type IOmit = Omit&lt;IPerson, &#39;name&#39;&gt;let viking3: IOmit = { age: 20 }</code></pre><p>資料來源：</p><ol><li>線上課程：實戰 Vue3.0(正式版) + TS </li><li><a href="https://willh.gitbook.io/typescript-tutorial/" target="_blank" rel="noopener">TypeScript 新手指南</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/xGK5aDO.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;要熟悉 TypeScript 的型別訂定，並不容易，而且撰寫時也會花費較多的時間，但好處是減少程式碼的錯誤，也讓協作者更容易解讀對方撰寫的程式碼。&lt;br&gt;萬事</summary>
      
    
    
    
    
    <category term="TypeScript" scheme="https://github.com/Eva813/Eva813.github.io.git/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript 基礎介紹 (1)</title>
    <link href="https://github.com/Eva813/Eva813.github.io.git/2021/11/27/TS-1/"/>
    <id>https://github.com/Eva813/Eva813.github.io.git/2021/11/27/TS-1/</id>
    <published>2021-11-27T00:44:33.000Z</published>
    <updated>2021-11-27T07:13:44.838Z</updated>
    
    <content type="html"><![CDATA[<p>因為工作需求，有需多缺乏的技能需要補齊，TypeScript 就是其中一項。<br>上班看不懂的時候邊查詢，空閒時間再來上課不足不懂的知識點，但還是得透過文章的整理來好好消化一下！<br>既然要開始介紹 TypeScript 就先來說說使用它的原因吧。</p><h2 id="為什麼使用-TypeScript"><a href="#為什麼使用-TypeScript" class="headerlink" title="為什麼使用 TypeScript"></a>為什麼使用 TypeScript</h2><ul><li><p>程式語言中，有區分強型別和弱型別兩種類型。</p></li><li><p>而 JavaScript 是弱型別語言。</p></li><li><p>在 JavaScript 中，他會自己判斷應該執行的型別。自行做[型別自動轉換]</p></li><li><p>在快速開發時，很有可能引發一些預期之外的錯誤，相當不利於多人協同開發。</p><ul><li>優點：寫法彈性。</li><li>缺點：無法在開發時期檢查型別。</li></ul></li><li><p>依據上述的問題，所以使用 TypeScript</p></li></ul><ol><li>使程式碼更容易理解 （如函式需傳入的參數可以明確設定型別）</li><li>減少程式碼撰寫的錯誤</li><li>可以完全兼容JavaScript，此外能與 ES6 完美結合，並提供更多支援寫法。</li></ol><h2 id="安裝介紹"><a href="#安裝介紹" class="headerlink" title="安裝介紹"></a>安裝介紹</h2><ul><li>就是直接到官方網站查看，依需求安裝<br><img src="https://i.imgur.com/wfMqk4w.png" alt=""></li></ul><p><code>npm install -g typescript</code></p><ul><li>檢查版本<br><code>tsc -v</code></li></ul><h2 id="型別介紹"><a href="#型別介紹" class="headerlink" title="型別介紹"></a>型別介紹</h2><p>從 JavaScript 型別分類開始</p><h3 id="字串-string"><a href="#字串-string" class="headerlink" title="字串 string"></a>字串 string</h3><ul><li>和ES6一樣，可以使用[字串樣板 Template Literals]<pre><code class="TypeScript">let firstName:string = &#39;NaNa&#39;let message: string = `Hello,${firstName}`</code></pre></li></ul><pre><code>### 布林值 boolean布林值是最基礎的資料型別，在 TypeScript 中，使用 boolean 定義布林值型別： ```typescriptlet isDonw:boolean = false </code></pre><p>注意：使用建構函式 Boolean 建立的物件不是布林值：</p><ul><li>事實上 new Boolean() 返回的是一個 Boolean 物件<pre><code class="JavaScript">let createdByNewBoolean: boolean = new Boolean(1);</code></pre></li></ul><p>// Type ‘Boolean’ is not assignable to type ‘boolean’.<br>//   ‘boolean’ is a primitive, but ‘Boolean’ is a wrapper object. Prefer using ‘boolean’ when possible.</p><pre><code></code></pre><p>在 TypeScript 中，boolean 是 JavaScript 中的基本型別，而 Boolean 是 JavaScript 中的建構函式。</p><pre><code>### 數值 number```TypeScriptlet age:number = 10let notANumber: number = NaN;let infinityNumber: number = Infinity;</code></pre><h3 id="Null-和-Undefined"><a href="#Null-和-Undefined" class="headerlink" title="Null 和 Undefined"></a>Null 和 Undefined</h3><ul><li>與 void 的區別是，undefined 和 null 是所有型別的子型別<ul><li>unfefined 可以賦值給number類型的變數</li><li>陣列被赋值為 undefined 或 null 不会报错</li><li><code>let num:number = undefined</code><pre><code class="TypeScript">let u: undefined = undefined;let n: null = null;</code></pre></li></ul></li></ul><p>// 這樣也不會報錯<br>let u: undefined;<br>let num: number = u;</p><pre><code>### void* 通常用在當函式沒有回傳值時。![](https://i.imgur.com/OOnpUUH.png)* 而 void 型別的變數不能賦值給 number 型別的變數：```JavaScriptlet u: void;let num: number = u;// Type &#39;void&#39; is not assignable to type &#39;number&#39;.</code></pre><h3 id="any"><a href="#any" class="headerlink" title="any"></a>any</h3><ul><li>在任意值上任何属性都是允許的<ul><li>當有明確型別時，應避免使用 any </li><li>因為 any 可以任意調用方法和屬性，很有可能出現錯誤（就喪失類型檢查的意義）<br>如果是 any 型別，則允許被賦值為任意型別</li></ul></li></ul><pre><code class="TypeScript">let myFavoriteNumber: any = &#39;seven&#39;;myFavoriteNumber = 7;</code></pre><h4 id="未宣告型別的變數"><a href="#未宣告型別的變數" class="headerlink" title="未宣告型別的變數"></a>未宣告型別的變數</h4><p>變數如果在宣告的時候，未指定其型別，那麼它會被識別為任意值型別：</p><pre><code class="JavaScript">let something;something = &#39;seven&#39;;something = 7;something.setName(&#39;Tom&#39;);</code></pre><h3 id="陣列-Array-與-元組-Tuple"><a href="#陣列-Array-與-元組-Tuple" class="headerlink" title="陣列 Array 與 元組 Tuple"></a>陣列 Array 與 元組 Tuple</h3><h4 id="陣列"><a href="#陣列" class="headerlink" title="陣列"></a>陣列</h4><ol><li>在想宣告的型別後面加上[]，宣告為某個型別的Array<pre><code class="TypeScript">let idList:number[] = [1,2,3]</code></pre></li><li>使用陣列泛型，Array &lt;元素型別&gt;<pre><code class="TypeScript">let list:Array&lt;number&gt; = [1,2,3]</code></pre></li></ol><ul><li>注意，當已經宣告這是個數字陣列<ul><li>要 push 字串進去，會出現錯誤<pre><code class="TypeScript">let list:Array&lt;number&gt; = [1,2,3]list.push(&quot;4&quot;)</code></pre><img src="https://i.imgur.com/bzszCFn.png" alt=""><h3 id="元組-Tuple"><a href="#元組-Tuple" class="headerlink" title="元組 Tuple"></a>元組 Tuple</h3></li><li>剛剛的陣列將同一類型的數據放在一起，但是，想加入不同型別的數據怎麼辦？</li><li>表示方式與陣列相似，將型別寫在<code>[]</code></li><li>有固定長度和元素型別的陣列<pre><code class="typescript">// 表示方式和陣列非常相似，只不过它将型別寫在了里面 這時會對每一項產生了限定的作用let user: [string, number] = [&#39;viking&#39;, 20]//但是当我们少寫一項 就會報錯，同樣多寫也會報錯user = [&#39;molly&#39;, 20, true]</code></pre><img src="https://i.imgur.com/MfhvOd7.png" alt=""></li></ul></li></ul><p><a href="https://willh.gitbook.io/typescript-tutorial/advanced/tuple#can-kao" target="_blank" rel="noopener">元組</a></p><h3 id="物件的型別——介面-Interface"><a href="#物件的型別——介面-Interface" class="headerlink" title="物件的型別——介面 (Interface)"></a>物件的型別——介面 (Interface)</h3><ul><li>Interface 可以用來定義物件，還有由物件所延伸的型別（例如，陣列、函式）</li><li><code>age?: number;</code> 在該屬性後面加上 <code>?</code> 表示為可選屬性 ，也就是在宣告新的物件時，可以彈性加入或不加入age （也不會報錯）</li></ul><pre><code class="typescript">// 我们定義了一個介面 Personinterface Person {  name: string;  age: number;}// 接着定义了一个變數 NaNa，它的型別是 Person。//这样，我们就约束了 NaNa 的形狀必須和介面 Person 一致。let NaNa: Person ={  name: &#39;NaNa&#39;,  age: 20}//有时我们希望不要完全匹配一个形狀，那么可以用可選屬性：interface Person {    name: string;    age?: number;}let NaNa: Person = {    name: &#39;NaNa&#39;}</code></pre><h3 id="唯讀屬性"><a href="#唯讀屬性" class="headerlink" title="唯讀屬性"></a>唯讀屬性</h3><ul><li>readonly 是用在屬性上面</li><li>希望物件中的一些欄位只能在建立的時候被賦值，那麼可以用 readonly 定義唯讀屬性</li></ul><pre><code class="typescript">interface Person {  readonly id: number;  name: string;  age?: number;}// 建立物件let Vic: Person ={  id:1,    name: &#39;Vic&#39;,  age: 20}//不能去修改id    Vic.id = 9527</code></pre><h3 id="函式型別"><a href="#函式型別" class="headerlink" title="函式型別"></a>函式型別</h3><ul><li>函式可以作為參數、可以存入陣列，可以被另外一個函式返回、可以被賦值另外一個變數</li><li>函式是由兩部分構成，一個是輸入(通過不同參數來實現)，二為輸出(就是函數的返回結果)<h4 id="例子一"><a href="#例子一" class="headerlink" title="例子一"></a>例子一</h4></li><li>設定參數型別、返回的型別</li><li>若參數設定了 x、y兩個，也就只能放入兩個<pre><code class="typescript">// 来到我们的第一个例子，约定输入，约定输出function add(x: number, y: number): number {return x + y}</code></pre><img src="https://i.imgur.com/RLOECvw.png" alt=""></li></ul><h4 id="例子二"><a href="#例子二" class="headerlink" title="例子二"></a>例子二</h4><ul><li>也可以設定可選參數</li><li>在 z? 表示 z 可有可無</li></ul><pre><code class="typescript">// 可选参数function add(x: number, y: number, z?: number): number {  if (typeof z === &#39;number&#39;) {    return x + y + z  } else {    return x + y  }}</code></pre><ul><li>而在可選參數後面不可以再添加確定參數<br><img src="https://i.imgur.com/qzQRT0r.png" alt=""></li></ul><h4 id="例外說明：引數預設值"><a href="#例外說明：引數預設值" class="headerlink" title="例外說明：引數預設值"></a>例外說明：引數預設值</h4><ul><li>在 ES6 中，我們允許給函式的引數新增預設值，TypeScript 會將添加了預設值的引數識別為可選引數：</li></ul><pre><code class="typescript">function buildName(firstName: string, lastName: string = &#39;Cat&#39;) {    return firstName + &#39; &#39; + lastName;}let tomcat = buildName(&#39;Tom&#39;, &#39;Cat&#39;);let tom = buildName(&#39;Tom&#39;); // 因為 lastName 添加了預設值，識別為可選引數</code></pre><p>此時就不受「可選引數必須接在必需引數後面」的限制了：</p><pre><code class="typescript">function buildName(firstName: string = &#39;Tom&#39;, lastName: string) {    return firstName + &#39; &#39; + lastName;}let tomcat = buildName(&#39;Tom&#39;, &#39;Cat&#39;);let cat = buildName(undefined, &#39;Cat&#39;);</code></pre><h4 id="例子三"><a href="#例子三" class="headerlink" title="例子三"></a>例子三</h4><ul><li>函式的表達式</li></ul><pre><code class="typescript">const add = (x: number, y: number, z?: number): number =&gt; {  if (typeof z === &#39;number&#39;) {    return x + y + z  } else {    return x + y  }}// 函式本身的类型const add2: (x: number, y: number, z?:number) =&gt; number = add</code></pre><ul><li>函式不只輸入、輸出有類型，本身也有類型<br><img src="https://i.imgur.com/f2Ym2Zb.png" alt=""></li><li>將 add2 賦予 string 會出錯誤</li><li>所以須聲明一模一樣的 <code>const add2: (x: number, y: number, z?:number) =&gt; number = add</code><br><img src="https://i.imgur.com/FvS1OvL.png" alt=""></li></ul><h4 id="例子四"><a href="#例子四" class="headerlink" title="例子四"></a>例子四</h4><ul><li>使用 interface (單純定義函式的 Interface)</li></ul><pre><code class="typescript">// interface 描述函数类型const sum = (x: number, y: number) =&gt; {  return x + y}interface ISum {  (x: number, y: number): number}const sum2: ISum = sum</code></pre><ul><li>另一個範例</li></ul><pre><code class="typescript">interface SearchFunc {    (source: string, subString: string): boolean;}let mySearch: SearchFunc;mySearch = function(source: string, subString: string) {    return source.search(subString) !== -1;}</code></pre><hr><h2 id="型別推論（Type-Inference）-聯合型別（Union-Types）-型別斷言（Type-Assertion）"><a href="#型別推論（Type-Inference）-聯合型別（Union-Types）-型別斷言（Type-Assertion）" class="headerlink" title="型別推論（Type Inference）\ 聯合型別（Union Types） \ 型別斷言（Type Assertion）"></a>型別推論（Type Inference）\ 聯合型別（Union Types） \ 型別斷言（Type Assertion）</h2><h3 id="型別推論（Type-Inference）"><a href="#型別推論（Type-Inference）" class="headerlink" title="型別推論（Type Inference）"></a>型別推論（Type Inference）</h3><ul><li>可以推論出我們賦值過程中，這個變數應該是什麼類型的</li><li>TS 會在沒有明確指定型別的時候，推測出型別<br><img src="https://i.imgur.com/280zYEs.png" alt=""></li></ul><h3 id="聯合型別（Union-Types）"><a href="#聯合型別（Union-Types）" class="headerlink" title="聯合型別（Union Types）"></a>聯合型別（Union Types）</h3><ul><li>用分隔符號</li><li>當 TypeScript 不确定一个聯合型別的變數到底是哪個型別的时候，我们只能使用此聯合型別的所有型別裡共有的屬性或方法</li></ul><pre><code class="TypeScript">// 允許 numberOrString 的型別是 string 或者 number，但是不能是其他型別。let numberOrString: number | string // 而在使用此聯合型別的所有型別里共有的屬性性或方法：numberOrString.length  //會報錯 （只有 string 適用）numberOrString.toString() //string 和 number 的共同屬性是沒問題//若放在函式定義型別function getLength(something: string | number): number {    return something.length;}// index.ts(2,22): error TS2339: Property &#39;length&#39; does not exist on type &#39;string | number&#39;.//   Property &#39;length&#39; does not exist on type &#39;number&#39;.</code></pre><ul><li>聯合型別的變數在被賦值的時候，會根據型別推論的規則推斷出一個型別：</li></ul><pre><code class="TypeScript">let numberOrString: string | number;numberOrString = &#39;seven&#39;;console.log(numberOrString.length); // 5numberOrString = 7;console.log(numberOrString.length); // 編譯時報錯// index.ts(5,30): error TS2339: Property &#39;length&#39; does not exist on type &#39;number&#39;.</code></pre><p>上例中，第二行的 numberOrString 被推斷成了 string，存取它的 length 屬性不會報錯。<br>而第四行的 numberOrString 被推斷成了 number，存取它的 length 屬性時就報錯了。</p><ul><li>type guard </li><li>當遇到聯合類型，可以使用條件語句，自動幫你縮小型別範圍</li></ul><pre><code class="javascript">// typescript 在不同的条件分支里面，智能的缩小了范围，这样我们代码出错的几率就大大的降低了。function getLength2(input: string | number): number {  if (typeof input === &#39;string&#39;) {    return input.length  } else {    return input.toString().length  }}</code></pre><h3 id="型別斷言（Type-Assertion）"><a href="#型別斷言（Type-Assertion）" class="headerlink" title="型別斷言（Type Assertion）"></a>型別斷言（Type Assertion）</h3><ul><li>開發者比 TS 更了解編寫的程式碼。因此，TS 允許開發者覆蓋它的推論，這樣的機制稱為「型別斷言」。</li></ul><pre><code class="typescript">// 这里我们可以用 as 關鍵字，告诉typescript 这里我把它看作是一個 string，你可以给他用 string 的方法。function getLength(input: string | number): number {  const str = input as string  if (str.length) {    return str.length  } else {    const number = input as number    return number.toString().length  }}</code></pre><ul><li>型別斷言不是型別轉換，斷言成一個聯合型別中不存在的型別是不允許的：</li></ul><pre><code class="TypeScript">function toBoolean(something: string | number): boolean {    return &lt;boolean&gt;something;}// index.ts(2,10): error TS2352: Type &#39;string | number&#39; cannot be converted to type &#39;boolean&#39;.//   Type &#39;number&#39; is not comparable to type &#39;boolean&#39;.</code></pre><p>基礎型別先介紹到這裡，下篇將介紹一些進階用法～</p><p>資料來源：</p><ol><li>線上課程：實戰 Vue3.0(正式版) + TS </li><li><a href="https://willh.gitbook.io/typescript-tutorial/" target="_blank" rel="noopener">TypeScript 新手指南</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;因為工作需求，有需多缺乏的技能需要補齊，TypeScript 就是其中一項。&lt;br&gt;上班看不懂的時候邊查詢，空閒時間再來上課不足不懂的知識點，但還是得透過文章的整理來好好消化一下！&lt;br&gt;既然要開始介紹 TypeScript 就先來說說使用它的原因吧。&lt;/p&gt;
&lt;h2 id</summary>
      
    
    
    
    
    <category term="TypeScript" scheme="https://github.com/Eva813/Eva813.github.io.git/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>講講幾個 Nuxt.js 重要觀念</title>
    <link href="https://github.com/Eva813/Eva813.github.io.git/2021/11/10/Nuxt-2/"/>
    <id>https://github.com/Eva813/Eva813.github.io.git/2021/11/10/Nuxt-2/</id>
    <published>2021-11-10T01:58:39.000Z</published>
    <updated>2021-11-28T08:30:57.197Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/4LE0BUW.png" alt=""></p><p>在使用 Nuxt.js 開啟專案後，會自動生成不少文件檔案，今天就來介紹幾樣基礎設定以及檔案的運用吧！</p><h2 id="了解-Nuxt-路徑引用規則"><a href="#了解-Nuxt-路徑引用規則" class="headerlink" title="了解 Nuxt 路徑引用規則"></a>了解 Nuxt 路徑引用規則</h2><ul><li><code>~</code>以及<code>@</code> ：根目錄 <ul><li>(注意：nuxt.conf.js、非 nuxt 結構的 js 檔 除外)</li></ul></li><li>波浪或小老鼠 :從根目錄 搜尋assets 資料夾<br><img src="https://i.imgur.com/CNUlrGz.png" alt=""><br>以下也一樣<br><code>import test from &quot;@/assets/js/test.js&quot;</code></li></ul><ol start="2"><li><code>./</code>：自己的目錄</li></ol><ul><li>nuxt.conf.js、以及非 nuxt 結構要這樣撰寫<br><img src="https://i.imgur.com/2qLJ5te.png" alt=""></li></ul><ol start="3"><li>放在 static 資料夾裡的引用方式(直接斜線)<code>&lt;img src=&quot;/demo.png&quot; alt=&quot;&quot;&gt;</code></li><li>補充：<br><a href="https://docs.google.com/presentation/d/15q4Vsl3I6Bf5F1f2LdNj_OvF5fcrl7aPv5aA1E39Kjw/edit#slide=id.g813fdce503_0_0" target="_blank" rel="noopener">2.4 nuxt 圖片處理 - webpack 相關設定</a></li></ol><ul><li><p>在asset 加入 img 資料夾(將圖片放在這裡)<br><code>&lt;img src=&quot;@/assets/img/demo.png&quot; alt=&quot;&quot;&gt;</code><br><img src="https://i.imgur.com/iSsni0c.png" alt=""></p></li><li><p>放在css作背景圖<br>  *<code>background: url(~assets/img/demo.png);  //nuxt css 引入圖片不能加斜線</code></p><ul><li>也不能將波浪改為@<br>:::info<br>原本波浪斜線方式:<br><code>background: url(~/assets/img/demo.png);</code><br>:::<br><img src="https://i.imgur.com/ekDF3vK.png" alt=""></li></ul></li></ul><h2 id="nuxt-config-js-設定"><a href="#nuxt-config-js-設定" class="headerlink" title="nuxt.config.js 設定"></a>nuxt.config.js 設定</h2><ul><li>vue cli3 設定vue 專案是透過是 main.js/ vue.config.js 這兩隻檔案。<ul><li>main.js 為程式的進入點</li></ul></li><li>nuxt 則統一用 nuxt.conf.js 做為設定。<ul><li>要編輯這份文件達到專案需求</li><li>如 wedpack 是放在 build</li></ul></li></ul><p><img src="https://i.imgur.com/aLpoUcR.png" alt=""></p><ul><li>此外在此檔案可以做標題、引入 CDN 等基礎設置<ul><li>head,meta 可以做表頭的設定</li><li>script 可以引入 JS 的檔案或 CDN 資源</li></ul></li><li>css 全域設定，也同樣放在這裡<ul><li><a href="https://nuxtjs.org/docs/configuration-glossary/configuration-css/" target="_blank" rel="noopener">The css property</a><pre><code class="javascript">css: [&#39;~/assets/scss/demo.scss&#39;],</code></pre></li></ul></li></ul><pre><code>```javascriptexport default {  // Global page headers: https://go.nuxtjs.dev/config-head  head: {    title: &#39;myNuxt&#39;,    htmlAttrs: {      lang: &#39;en&#39;    },    meta: [      { charset: &#39;utf-8&#39; },      { name: &#39;viewport&#39;, content: &#39;width=device-width, initial-scale=1&#39; },      { hid: &#39;description&#39;, name: &#39;description&#39;, content: &#39;&#39; },      { name: &#39;format-detection&#39;, content: &#39;網站前後端、網頁設計、程式語言網站&#39; }    ],    link: [      { rel: &#39;icon&#39;, type: &#39;image/x-icon&#39;, href: &#39;/favicon.ico&#39; }    ],    script:    [      { src: &quot;/jquery.min.js&quot;},      { src: &quot;https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/js/all.js&quot; }    ]  },</code></pre><p><img src="https://i.imgur.com/krqrhq8.png" alt=""></p><h3 id="引用-static-靜態資源的檔案"><a href="#引用-static-靜態資源的檔案" class="headerlink" title="引用 static 靜態資源的檔案"></a>引用 static 靜態資源的檔案</h3><ul><li>static資料夾:靜態資源資料夾<ul><li>其中要連接該檔案路徑要用斜線</li><li>這裡面的檔案不會被打包和優化<br><img src="https://i.imgur.com/46ebZ9F.png" alt=""></li></ul></li></ul><h2 id="套件安裝"><a href="#套件安裝" class="headerlink" title="套件安裝!"></a>套件安裝!</h2><ol><li>最簡單方式是使用打包後的 CDN 或 js 檔案 <ul><li>在head 的 script 放入 CDN</li></ul></li><li>使用 <a href="https://nuxtjs.org/docs/directory-structure/plugins/" target="_blank" rel="noopener">nuxt plugins</a> 自包 js 套件 或 vue 套件 → 較麻煩</li><li>使用 <a href="https://zh.nuxtjs.org/guide/modules/" target="_blank" rel="noopener">nuxt modules</a> 來引入套件<ul><li>套件較少</li></ul></li></ol><ul><li>nuxt module 主要是將 plugin 在封裝一層出來。(就是 nuxt 專有的套件)，如果對安裝 plugins 沒把握，就找有 nuxt modules 的套件來安裝。</li></ul><h3 id="練習1包裝一般的-vue-套件"><a href="#練習1包裝一般的-vue-套件" class="headerlink" title="練習1包裝一般的 vue 套件"></a>練習1包裝一般的 vue 套件</h3><p> <a href="https://www.npmjs.com/package/vuejs-datepicker" target="_blank" rel="noopener">vuejs-datepicker</a></p><p>1、npm install vuejs-datepicker</p><ul><li>若直接依照官網來安裝，並在檔案引入會發生錯誤</li><li>所以 install 完之後要再執行下面動作<br>2、plugins 新增一個檔案：datepicker.js → 撰寫套件</li><li>在 plugins 資料夾，新增檔案<pre><code class="javascript">import Vue from &#39;vue&#39;import Datepicker from &#39;vuejs-datepicker&#39;;</code></pre></li></ul><p>Vue.component(‘Datepicker’, Datepicker)</p><pre><code>![](https://i.imgur.com/l0kYSwT.png)3、nuxt.config.js 安裝 plugin → 可以設定該套件只在 客戶端 運作* 可以將插件安裝在客戶端或是 server 端```javascript{ src: &#39;~/plugins/datepicker.js&#39;, mode: &#39;client&#39; },</code></pre><ul><li>要使用時，再放入頁面<br><img src="https://i.imgur.com/gNNLJ2O.png" alt=""><h3 id="練習2-安裝一般的-js-套件"><a href="#練習2-安裝一般的-js-套件" class="headerlink" title="練習2 安裝一般的 js 套件"></a>練習2 安裝一般的 js 套件</h3><a href="https://greensock.com/docs/v3/Installation" target="_blank" rel="noopener">GSAP</a></li></ul><ol><li>npm install gsap</li><li>plugins 新增一個檔案：gsap.js → 撰寫套件<pre><code class="javascript">import Vue from &#39;vue&#39;import gsap from &quot;gsap&quot;;</code></pre></li></ol><p>Vue.prototype.$gsap = gsap</p><pre><code>![](https://i.imgur.com/t3G7UGN.png)3. nuxt.config.js 安裝 plugin```javascript plugins: [    { src: &#39;~/plugins/gsap.js&#39;, mode: &#39;client&#39; },  ],</code></pre><ul><li><code>create()</code> 會在前端執行\後端執行</li></ul><h3 id="練習3-nuxt-安裝"><a href="#練習3-nuxt-安裝" class="headerlink" title="練習3 nuxt 安裝"></a>練習3 nuxt 安裝</h3><p><a href="https://axios.nuxtjs.org/" target="_blank" rel="noopener">axios modules</a></p><ol><li>npm install @nuxtjs/axios</li><li>plugins 新增一個檔案：axios.js </li></ol><ul><li><p>如同前面的練習，到  nuxt.config.js</p><pre><code class="javascript">modules: [  &#39;@nuxtjs/axios&#39;,],</code></pre></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/4LE0BUW.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在使用 Nuxt.js 開啟專案後，會自動生成不少文件檔案，今天就來介紹幾樣基礎設定以及檔案的運用吧！&lt;/p&gt;
&lt;h2 id=&quot;了解-Nuxt-路徑引用規則&quot;</summary>
      
    
    
    
    
    <category term="Nuxt" scheme="https://github.com/Eva813/Eva813.github.io.git/tags/Nuxt/"/>
    
  </entry>
  
  <entry>
    <title>為何要學習 Nuxt.js ？</title>
    <link href="https://github.com/Eva813/Eva813.github.io.git/2021/11/10/Nuxt-1/"/>
    <id>https://github.com/Eva813/Eva813.github.io.git/2021/11/10/Nuxt-1/</id>
    <published>2021-11-10T01:30:01.000Z</published>
    <updated>2021-11-14T01:59:20.651Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/4LE0BUW.png" alt=""></p><p>製作網站，都會希望自己的網站可以被搜尋引擎找得到，並且可以在使用者輸入關鍵字後，可以在頭幾個項目中就能關注到自己的網站！<br>而在使用 Vue.js 框架，因為是使用 SPA 架構無法做到 SEO (search engine optimization) 的效果，別人無法輕易的找到我們所製作的網站。<br>今天要介紹的 Nuxt.js 是一個基於 Vue.js、用來處理伺服器渲染（Server-side rendering(SSR)）的框架。透過 SSR 我們可以做到更好的 SEO 效果。</p><p>本文首要任務： 認識 SPA 與 SSR 的差異</p><h2 id="SPA-Single-Page-Application-架構"><a href="#SPA-Single-Page-Application-架構" class="headerlink" title="SPA (Single Page Application) 架構"></a>SPA (Single Page Application) 架構</h2><ul><li>讓一些後端的工作，分擔到前端 (如： router 設定)</li><li>流程為：使用者開了瀏覽器 -&gt; 向後端server要資料，因為改為SPA 架構，所以提供的會是SPA 首頁（會載入JS\編譯好的CSS\一頁空殼的HTML網頁），此空殼經過 Vue 編譯產出 DOM 物件，讓瀏覽器印出。</li><li>讓回應速度更快，使用者在轉換頁面時得到更好的體驗。<ul><li>SPA（Single Page Application）意思是僅有一個頁面的應用程式，也就是說網頁不需跳轉頁面就可以達到基本的建立、讀取、修改、刪除資料功能。</li></ul></li><li>後端負責調整API 邏輯\架構<h3 id="SPA-缺點"><a href="#SPA-缺點" class="headerlink" title="SPA 缺點"></a>SPA 缺點</h3></li><li>SEO差(SPA 一開始吐的是空殼)，GOOGLE 爬不到頁面資訊</li><li>SMO差，FB爬不到頁面資訊</li><li>首屏速度慢，一開始畫面會空白或閃爍<ul><li>發出請求資訊到實際上呈現完整頁面時間</li></ul></li></ul><h2 id="SSR-Server-Side-Rendering"><a href="#SSR-Server-Side-Rendering" class="headerlink" title="SSR (Server Side Rendering)"></a>SSR (Server Side Rendering)</h2><p>流程為：使用者開了瀏覽器 -&gt; 向後端server要資料，因為改為SSR，所以會提供一整個頁面(不會是畫面空白閃爍)</p><ul><li>希望頁面可以將網頁整個東西呈現，並讓搜尋引擎查得到</li><li>處理 SEO(針對搜尋引擎)</li></ul><ul><li>title</li><li>meta tag<ul><li>全域 <code>&lt;head&gt;</code> 設定</li><li>單頁 <code>&lt;head&gt;</code> 設定 </li></ul></li><li>description</li></ul><ul><li>處理 SMO (針對 Social media)<ul><li>twitter\youtube\Line…<h3 id="有更多的彈性設定"><a href="#有更多的彈性設定" class="headerlink" title="有更多的彈性設定"></a>有更多的彈性設定</h3><h4 id="Nuxt-有三種模式，可以幫你解決問題"><a href="#Nuxt-有三種模式，可以幫你解決問題" class="headerlink" title="Nuxt 有三種模式，可以幫你解決問題"></a>Nuxt 有三種模式，可以幫你解決問題</h4></li></ul></li></ul><ol><li>Universal: SSR + CSR </li></ol><ul><li>全域設定 mode: ‘Universal’</li></ul><ol start="2"><li>SPA: 不跑SSR </li></ol><ul><li>全域設定 mode: ‘spa’ 或執行 nuxt-spa</li></ul><ol start="3"><li>Static Generated (Pre Rendering): 產生靜態頁面</li></ol><ul><li>nuxt run generate<ul><li>預先將頁面轉成靜態頁面</li><li>如要拉10樣商品，就先拉10個頁面</li></ul></li></ul><p>希望本篇的扼要介紹能夠讓讀者快速知道其中的差異。</p><p>參考資料：<br><a href="https://medium.com/@jackercleaninglab/ssr-nuxt-js-%E8%B6%85%E5%85%A5%E9%96%80-84a0823b45ed" target="_blank" rel="noopener">SSR — Nuxt.js 超入門</a><br><a href="https://www.youtube.com/watch?v=szrRDJBFmvQ" target="_blank" rel="noopener">Vue Nuxt 介紹與實作範例</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/4LE0BUW.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;製作網站，都會希望自己的網站可以被搜尋引擎找得到，並且可以在使用者輸入關鍵字後，可以在頭幾個項目中就能關注到自己的網站！&lt;br&gt;而在使用 Vue.js 框架，</summary>
      
    
    
    
    
    <category term="Nuxt" scheme="https://github.com/Eva813/Eva813.github.io.git/tags/Nuxt/"/>
    
  </entry>
  
  <entry>
    <title>實作 Vuex - Todo List</title>
    <link href="https://github.com/Eva813/Eva813.github.io.git/2021/10/20/vuex-todo/"/>
    <id>https://github.com/Eva813/Eva813.github.io.git/2021/10/20/vuex-todo/</id>
    <published>2021-10-20T06:32:01.000Z</published>
    <updated>2021-10-20T09:00:00.871Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/RPoUnyd.png" alt=""></p><p>之前的實作練習都沒有機會使用到 Vuex，總是覺得它的資料存取、取得或是管理，對於剛接觸Vue 的我來說還是相對複雜，而且剛開始接觸 Vue 總要先練習下 props \ emit 資料傳遞才行啊～<br>既然已經會使用基礎的資料傳遞後，那就要近一步實作 Vuex 狀態管理</p><h2 id="實作功能說明"><a href="#實作功能說明" class="headerlink" title="實作功能說明"></a>實作功能說明</h2><ul><li>資料的取得來自 JSONPlaceholder<ul><li>從Vuex來實作資料的取得、刪除、更新</li></ul></li><li>針對目前取得的資料進行筆數的篩選</li><li>區分未完成事項、以及完成事項</li><li>可透過點擊方塊改變色塊</li><li>接下來～會製作 3個 component ，將元件放到 App.vue</li></ul><p><a href="https://eva813.github.io/Vuex-Todo/index.html" target="_blank" rel="noopener">成品</a></p><h4 id="開始前別忘了先建立-module"><a href="#開始前別忘了先建立-module" class="headerlink" title="開始前別忘了先建立 module"></a>開始前別忘了先建立 module</h4><h2 id="Vuex-檔案的處理"><a href="#Vuex-檔案的處理" class="headerlink" title="Vuex 檔案的處理"></a>Vuex 檔案的處理</h2><ul><li>這裡開專案直接有建立 vuex</li><li>進入 store &gt; index.js</li></ul><pre><code class="javascript">import { createStore } from &#39;vuex&#39;;import todos from &#39;./modules/todos&#39;;export default createStore({  state: {  },  mutations: {  },  actions: {  },  modules: {    todos,  }})</code></pre><h2 id="建立-modules-資料夾"><a href="#建立-modules-資料夾" class="headerlink" title="建立 modules 資料夾"></a>建立 modules 資料夾</h2><ul><li>store &gt; modules &gt; todo.js<ul><li>從這裡的資料取得並傳遞到 Todos.vue<pre><code class="javascript">import axios from &#39;axios&#39;;</code></pre></li></ul></li></ul><p>const state = {};<br>const getters = {};<br>const actions = {};<br>const mutations = {};</p><p>export default {<br>  state,<br>  getters,<br>  actions,<br>  mutations<br>}</p><pre><code>#### 接下來要嘗試來串取資料* 取得假資料[jsonplaceholder-todo](https://jsonplaceholder.typicode.com/todos)## 在 todo.js 來製作資料的串接* 首先state這裡要先建立空陣列，getters 則是建立資料取得的函式* 在action 來發出請求，取得回應，並傳給 mutations    * mutations 是改變資料的地方* 引入axios，使用 Asyc await 使用 get 來串接資料   * 將串到的資料 commit 到 mutations，改變原本todos資料內容```javascriptimport axios from &#39;axios&#39;;const state = {  todos: []};const getters = {  getTodos: (state) =&gt; state.todos,};const actions = {  async fetchTodos({ commit }) {    const res = await axios.get(&quot;https://jsonplaceholder.typicode.com/todos&quot;);    // console.log(res.data);    commit(&#39;setTodos&#39;, res.data);  }};const mutations = {  setTodos: (state, todos) =&gt; {    state.todos = todos;  }};export default {  state,  getters,  actions,  mutations}</code></pre><p><img src="https://i.imgur.com/4wmzRwy.png" alt=""></p><h2 id="建立-Todos-vue"><a href="#建立-Todos-vue" class="headerlink" title="建立 Todos.vue"></a>建立 Todos.vue</h2><ul><li><p>此元件主要是呈現所有的 Todo list</p><h3 id="取得-vuex-中的資料"><a href="#取得-vuex-中的資料" class="headerlink" title="取得 vuex 中的資料"></a>取得 vuex 中的資料</h3></li><li><p>引入 mapGetters, mapActions</p></li><li><p>將要從 getters 拿到的陣列，放到computed做資料的取得</p><ul><li>將該陣列<code>getTodos</code> 放到 v-for</li></ul></li><li><p>串接的 action 使用 mapActions，於 methods中執行，而此函式要在<code>created</code>階段運行</p></li><li><p>如此一來就可以，從 Vuex 中得到資料</p></li></ul><pre><code class="javascript">&lt;template&gt;  &lt;h3&gt;Todos&lt;/h3&gt;  &lt;div class=&quot;todos&quot;&gt;    &lt;div class=&quot;todo&quot; v-for=&quot;todo in getTodos&quot; :key=&quot;todo.id&quot;&gt;      {{ todo.title }}    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import { mapGetters, mapActions } from &quot;vuex&quot;;export default {  name: &quot;Todos&quot;,  methods:{    ...mapActions([&quot;fetchTodos&quot;])  },  computed: mapGetters([&quot;getTodos&quot;]),  created() {    this.fetchTodos();  },};&lt;/script&gt;</code></pre><p><img src="https://i.imgur.com/4RKUMtJ.png" alt=""></p><p><img src="https://i.imgur.com/IiWla0A.png" alt=""></p><h2 id="製作加入新-todo-功能"><a href="#製作加入新-todo-功能" class="headerlink" title="製作加入新 todo 功能"></a>製作加入新 todo 功能</h2><ul><li>建立一個新的 component =&gt; AddTodo.vue</li><li>在 AddTodo 這個元件，製作 輸入框<pre><code class="javascript">&lt;template&gt;&lt;div&gt;  &lt;h3&gt;Add Todo&lt;/h3&gt;  &lt;div class=&quot;add&quot;&gt;    &lt;form&gt;    &lt;input type=&quot;text&quot; placeholder=&quot;Add Todo...&quot; v-model=&quot;title&quot; /&gt;    &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;    &lt;/form&gt;  &lt;/div&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {name: &quot;AddTodo&quot;,};&lt;/script&gt;</code></pre><h3 id="到-module-gt-todo-js"><a href="#到-module-gt-todo-js" class="headerlink" title="到 module &gt; todo.js"></a>到 module &gt; todo.js</h3></li><li>使用 async 與 axios 傳入資料<ul><li>第二個參數為 title</li><li>post 的網址一樣，後面接的參數為title, complete: false (any new todo that it’s not going to completed)</li></ul></li></ul><pre><code class="javascript">const actions = {  async fetchTodos({ commit }) {    const res = await axios.get(&quot;https://jsonplaceholder.typicode.com/todos&quot;);    // console.log(res.data);    commit(&#39;setTodos&#39;, res.data);  },  async addTodo({ commit }, title) {    const res = await axios.post(&quot;https://jsonplaceholder.typicode.com/todos&quot;, { title, completed: false });    commit(&#39;addNewTodo&#39;, res.data);  }};</code></pre><ul><li>而在action 中使用axios 來新增資料，要將這必新資料 push 到 todo的陣列中<ul><li>存入的該資料要放在，陣列的最前面所以使用 unshift<pre><code class="javascript">const mutations = {setTodos: (state, todos) =&gt; {state.todos = todos;},addNewTodo: (state, todo) =&gt; {state.todos.unshift(todo);}};</code></pre></li></ul></li></ul><h3 id="到-AddTodo-vue-來呼叫此-action"><a href="#到-AddTodo-vue-來呼叫此-action" class="headerlink" title="到 AddTodo.vue 來呼叫此 action"></a>到 AddTodo.vue 來呼叫此 action</h3><ul><li>import <code>mapActions</code></li></ul><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;h3&gt;Add Todo&lt;/h3&gt;    &lt;div class=&quot;add&quot;&gt;      &lt;form @submit=&quot;onSubmit&quot;&gt;        &lt;input type=&quot;text&quot; placeholder=&quot;Add Todo...&quot; v-model=&quot;title&quot; /&gt;        &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;      &lt;/form&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><pre><code class="javascript">&lt;script&gt;import { mapActions } from &quot;vuex&quot;;export default {  name: &quot;AddTodo&quot;,  data() {    return {      title: &quot;&quot;,    };  },  method: {    ...mapActions([&quot;addTodo&quot;]),    onSubmit(e) {      e.preventDefault();      //點擊後呼叫action中的加入todo函式，並傳入title資料      this.addTodo(this.title);    },  },};&lt;/script&gt;</code></pre><p><img src="https://i.imgur.com/57j3S5m.png" alt=""></p><h3 id="這裡要特別提出說明"><a href="#這裡要特別提出說明" class="headerlink" title="這裡要特別提出說明"></a>這裡要特別提出說明</h3><p>因為是使用線上的虛擬資料，他不允許我們可以存入新資料到他的API裡面<br>所以可以看到下方的錯誤顯示(重複 id)<br>而此在重新整理之後，存入的資料會消失</p><p><img src="https://i.imgur.com/nNh6AXL.png" alt=""></p><p><img src="https://i.imgur.com/0IZlhhL.png" alt=""></p><hr><h2 id="製作刪除功能"><a href="#製作刪除功能" class="headerlink" title="製作刪除功能"></a>製作刪除功能</h2><ul><li>以id作為參數，來依此刪除</li><li>不用儲存response資料<ul><li>在 async deleteTodo ，製作 by id 刪除</li><li>到 mutations =&gt; 使用 filter 存下資料</li></ul></li></ul><pre><code class="javascript">import axios from &#39;axios&#39;;const state = {  todos: []};const getters = {  getTodos: (state) =&gt; state.todos,};const actions = {  async fetchTodos({ commit }) {    const res = await axios.get(&quot;https://jsonplaceholder.typicode.com/todos&quot;);    // console.log(res.data);    commit(&#39;setTodos&#39;, res.data);  },  async addTodo({ commit }, title) {    const res = await axios.post(&quot;https://jsonplaceholder.typicode.com/todos&quot;, { title, completed: false });    commit(&#39;addNewTodo&#39;, res.data);  },  async deleteTodo({ commit }, id) {    await axios.delete(`https://jsonplaceholder.typicode.com/todos/${id}`);    commit(&#39;removeTodo&#39;, id)  }};const mutations = {  setTodos: (state, todos) =&gt; {    state.todos = todos;  },  addNewTodo: (state, todo) =&gt; {    state.todos.unshift(todo);  },  removeTodo: (state, id) =&gt; {    state.todos = state.todos.filter((todo) =&gt; todo.id !== id);    //使用filter 將，不是id的篩選出來  }};export default {  state,  getters,  actions,  mutations}</code></pre><ul><li>回到 Todos.vue</li><li>在 template 放入垃圾桶的 icon<ul><li>執行刪除的功能，在 icon 綁定刪除事件<code>deleteTodo()</code></li><li><code>deleteTodo()</code>就是來自於 methods 取得的事件<pre><code class="html">&lt;template&gt;&lt;h3&gt;Todos&lt;/h3&gt;&lt;div class=&quot;todos&quot;&gt;&lt;div class=&quot;todo&quot; v-for=&quot;todo in getTodos&quot; :key=&quot;todo.id&quot;&gt;{{ todo.title }}&lt;i class=&quot;fas fa-trash-alt&quot; @click=&quot;deleteTodo(todo.id)&quot;&gt;&lt;/i&gt;&lt;/div&gt;&lt;/div&gt;&lt;/template&gt;</code></pre><pre><code class="javascript">&lt;script&gt;import { mapGetters, mapActions } from &quot;vuex&quot;;export default {name: &quot;Todos&quot;,methods: {...mapActions([&quot;fetchTodos&quot;, &quot;deleteTodo&quot;]),},computed: mapGetters([&quot;getTodos&quot;]),created() {this.fetchTodos();},};&lt;/script&gt;</code></pre></li></ul></li></ul><pre><code>---## 製作篩選器功能* 當 FilterTodo.vue 這裡的篩選器執行的時候，會執行 action中的函式，進行篩選```html&lt;style scoped&gt;select {  margin-top: 20px;  padding: 6px;  border: #ef9a9a 1px solid;}&lt;/style&gt;&lt;template&gt;  &lt;div&gt;    Filter todos:    &lt;select&gt;      &lt;option value=&quot;200&quot;&gt;200&lt;/option&gt;      &lt;option value=&quot;100&quot;&gt;100&lt;/option&gt;      &lt;option value=&quot;50&quot;&gt;50&lt;/option&gt;      &lt;option value=&quot;30&quot;&gt;30&lt;/option&gt;      &lt;option value=&quot;20&quot;&gt;20&lt;/option&gt;      &lt;option value=&quot;10&quot;&gt;10&lt;/option&gt;    &lt;/select&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><pre><code class="javascript">&lt;script&gt;export default {  name: &quot;FilterTodos&quot;,};&lt;/script&gt;</code></pre><p>將該元件綁到 App.vue</p><pre><code class="javascript">&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;div class=&quot;container&quot;&gt;      &lt;AddTodo /&gt;      &lt;FilterTodos /&gt;      &lt;Todos /&gt;    &lt;/div&gt;  &lt;/div&gt;  &lt;!-- &lt;router-view /&gt; --&gt;&lt;/template&gt;&lt;script&gt;import Todos from &quot;@/components/Todos.vue&quot;;import AddTodo from &quot;@/components/AddTodo.vue&quot;;import FilterTodos from &quot;@/components/FilterTodos.vue&quot;;export default {  name: &quot;app&quot;,  components: {    Todos,    AddTodo,    FilterTodos,  },};&lt;/script&gt;</code></pre><h3 id="到-module-gt-todo-js-來製作-actions"><a href="#到-module-gt-todo-js-來製作-actions" class="headerlink" title="到 module &gt; todo.js 來製作 actions"></a>到 module &gt; todo.js 來製作 actions</h3><ul><li>要傳入 option 的 value<ul><li>第二個參數為事件</li><li>在 axios 的 get 放入 url，接上取得的參數</li><li>commit 直接傳到 setTodos ，將串接到的資料透過 mutations 存到 todos<pre><code class="javascript">import axios from &#39;axios&#39;;</code></pre></li></ul></li></ul><p>const state = {<br>  todos: []<br>};<br>const getters = {<br>  getTodos: (state) =&gt; state.todos,<br>};<br>const actions = {</p><p>  async filterTodos({ commit }, e) {<br>    //取得下拉選單的值<br>    //console.log(e.target.value);<br>    let selected = parseInt(e.target.value);<br>    const res = await axios.get(<code>https://jsonplaceholder.typicode.com/todos?_limit=${selected}</code>);<br>    commit(‘setTodos’, res.data);<br>  }</p><p>};<br>const mutations = {<br>  setTodos: (state, todos) =&gt; {<br>    state.todos = todos;<br>  },<br>  addNewTodo: (state, todo) =&gt; {<br>    state.todos.unshift(todo);<br>  },<br>  removeTodo: (state, id) =&gt; {<br>    state.todos = state.todos.filter((todo) =&gt; todo.id !== id);<br>    //使用filter 將，不是id的篩選出來<br>  }<br>};</p><p>export default {<br>  state,<br>  getters,<br>  actions,<br>  mutations<br>}</p><pre><code>* 將ａction 綁到 FilterTodos.vue```javascript&lt;template&gt;  &lt;div&gt;    Filter todos:    &lt;select @change=&quot;filterTodos($event)&quot;&gt;      &lt;option value=&quot;200&quot;&gt;200&lt;/option&gt;      &lt;option value=&quot;100&quot;&gt;100&lt;/option&gt;      &lt;option value=&quot;50&quot;&gt;50&lt;/option&gt;      &lt;option value=&quot;30&quot;&gt;30&lt;/option&gt;      &lt;option value=&quot;20&quot;&gt;20&lt;/option&gt;      &lt;option value=&quot;10&quot;&gt;10&lt;/option&gt;    &lt;/select&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import { mapActions } from &quot;vuex&quot;;export default {  name: &quot;FilterTodos&quot;,  methods: {    ...mapActions([&quot;filterTodos&quot;]),  },};&lt;/script&gt;</code></pre><hr><h2 id="todos-完成與否，狀態的改變"><a href="#todos-完成與否，狀態的改變" class="headerlink" title="todos 完成與否，狀態的改變"></a>todos 完成與否，狀態的改變</h2><ul><li>點擊兩下來更改狀態<ul><li>當要更新資料，要使用put，傳入updTodo物件資料<ul><li>將該資料傳到mutation</li></ul></li><li>接著到 mutation 製作更新的動作</li><li>要取得目前的index</li></ul></li></ul><pre><code class="javascript">import axios from &#39;axios&#39;;const state = {  todos: []};const getters = {  getTodos: (state) =&gt; state.todos,};const actions = {  async updataTodo({ commit }, updTodo) {    const res = await axios.put(`https://jsonplaceholder.typicode.com/todos/${updTodo.id}`,updTodo);    commit(&#39;renewTodo&#39;, res.data);  },};const mutations = {  renewTodo: (state, updTodo) =&gt; {    console.log(updTodo);    //我們是要在同一筆資料上更新    const index = state.todos.findIndex(todo =&gt; todo.id === updTodo.id);    //以下簡單確認 indx 是否有存在    if (index !== -1) {      state.todos.splice(index, 1, updTodo);    }  }};export default {  state,  getters,  actions,  mutations}</code></pre><h3 id="回到-Todos-vue"><a href="#回到-Todos-vue" class="headerlink" title="回到 Todos.vue"></a>回到 Todos.vue</h3><ul><li>template 插入legend</li><li>引入 <code>updataTodo</code>到 methods</li><li><code>onDblclick()</code>建立一個變數，它包含的物件內容為id、title、completed，其中我只要要改變的值是 complete true\false<ul><li>這裡的 id,title 都一樣。complete 則設定狀態的改變</li><li>最後在呼叫一次 <code>updataTodo()</code>  傳入新的物件<pre><code class="html">&lt;template&gt;&lt;h3&gt;Todos&lt;/h3&gt;&lt;div class=&quot;legend&quot;&gt;&lt;span&gt;雙重點擊來標示已完成的事項&lt;/span&gt;&lt;span&gt; &lt;span class=&quot;incomplete-box&quot;&gt;&lt;/span&gt; = 未完成 &lt;/span&gt;&lt;span&gt; &lt;span class=&quot;complete-box&quot;&gt;&lt;/span&gt; = 已完成 &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;todos&quot;&gt;&lt;div @dblclick=&quot;onDblclick(todo)&quot; class=&quot;todo&quot; v-for=&quot;todo in getTodos&quot; :key=&quot;todo.id&quot; :class=&quot;{ &#39;is-complete&#39;: todo.completed }&quot;&gt; {{ todo.title }} &lt;i class=&quot;fas fa-trash-alt&quot; @click=&quot;deleteTodo(todo.id)&quot;&gt;&lt;/i&gt;&lt;/div&gt;&lt;/div&gt;&lt;/template&gt;</code></pre></li></ul></li></ul><pre><code>```javascript&lt;script&gt;import { mapGetters, mapActions } from &quot;vuex&quot;;export default {  name: &quot;Todos&quot;,  methods: {    ...mapActions([&quot;fetchTodos&quot;, &quot;deleteTodo&quot;, &quot;updataTodo&quot;]),    onDblclick(todo) {      const updTodo = {        id: todo.id,        title: todo.title,        completed: !todo.completed,      };      this.updataTodo(updTodo);    },  },  computed: mapGetters([&quot;getTodos&quot;]),  created() {    this.fetchTodos();  },};&lt;/script&gt;</code></pre><p>參考資料：<br><a href="https://ithelp.ithome.com.tw/articles/10191225" target="_blank" rel="noopener">[Vue.js] Vuex 學習筆記 (5) - getters 的核心概念</a><br><a href="https://vuex.vuejs.org/zh/guide/getters.html#%E9%80%9A%E8%BF%87%E5%B1%9E%E6%80%A7%E8%AE%BF%E9%97%AE" target="_blank" rel="noopener">Vuex</a><br><a href="https://forum.vuejs.org/t/using-this-store-dispatch-vs-using-mapactions/2186/2" target="_blank" rel="noopener">Using <code>this.$store.dispatch</code> vs using mapActions</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/RPoUnyd.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;之前的實作練習都沒有機會使用到 Vuex，總是覺得它的資料存取、取得或是管理，對於剛接觸Vue 的我來說還是相對複雜，而且剛開始接觸 Vue 總要先練習下 p</summary>
      
    
    
    
    
    <category term="Vue" scheme="https://github.com/Eva813/Eva813.github.io.git/tags/Vue/"/>
    
    <category term="Vuex" scheme="https://github.com/Eva813/Eva813.github.io.git/tags/Vuex/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js 3 -  組件的拆分</title>
    <link href="https://github.com/Eva813/Eva813.github.io.git/2021/10/19/Vue-setComponent/"/>
    <id>https://github.com/Eva813/Eva813.github.io.git/2021/10/19/Vue-setComponent/</id>
    <published>2021-10-19T08:36:10.000Z</published>
    <updated>2021-11-28T08:50:18.258Z</updated>
    
    <content type="html"><![CDATA[<p>試想今天有一個網頁，上方的導覽列有不同的分類，帶領你到該項目的分頁中<br>那我們該如何實現，將各個項目的內容一一呈現<br><img src="https://i.imgur.com/7LUqd5I.png" alt=""></p><h2 id="簡單分別製作-component"><a href="#簡單分別製作-component" class="headerlink" title="簡單分別製作 component"></a>簡單分別製作 component</h2><p>首先：component的命名要用大寫<br><img src="https://i.imgur.com/fAOtmM8.png" alt=""></p><ul><li>在 component 中<br><img src="https://i.imgur.com/dgWnvii.png" alt=""></li></ul><h3 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h3><ul><li>在 App.vue<br>讓vue知道有個component可以被使用，透過ES6的解構放入<br><img src="https://i.imgur.com/4yAMVNw.png" alt=""><br>將引入的component放到template<br><img src="https://i.imgur.com/PO4LhRv.png" alt=""><br><img src="https://i.imgur.com/K0UmvdI.png" alt=""></li></ul><h2 id="將其他組件引入"><a href="#將其他組件引入" class="headerlink" title="將其他組件引入"></a>將其他組件引入</h2><p><img src="https://i.imgur.com/EgWUGfG.png" alt=""></p><p><img src="https://i.imgur.com/qIvkq2l.png" alt=""></p><h2 id="補充說明："><a href="#補充說明：" class="headerlink" title="補充說明："></a>補充說明：</h2><p>修改路徑:<br>用~@來指定圖片路徑：@在vuecli是代表特殊意義，就會直接從src這個資料夾底下開始查找;而波浪符號，代表現在在css之中使用這個功能<br><img src="https://i.imgur.com/NefWOd8.png" alt=""></p><ul><li>也就是在專案中，即便路徑複雜，只要在路徑最前面加上<code>@</code>就會直接進去src<br><img src="https://i.imgur.com/sPhH1rs.png" alt=""></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;試想今天有一個網頁，上方的導覽列有不同的分類，帶領你到該項目的分頁中&lt;br&gt;那我們該如何實現，將各個項目的內容一一呈現&lt;br&gt;&lt;img src=&quot;https://i.imgur.com/7LUqd5I.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;簡單分別製作-comp</summary>
      
    
    
    
    
    <category term="Vue" scheme="https://github.com/Eva813/Eva813.github.io.git/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>JS基本觀念 - 認識 pass by value、pass by reference 、 pass by sharing，Javascript 又是哪一個？</title>
    <link href="https://github.com/Eva813/Eva813.github.io.git/2021/10/09/js-pass/"/>
    <id>https://github.com/Eva813/Eva813.github.io.git/2021/10/09/js-pass/</id>
    <published>2021-10-09T04:18:41.000Z</published>
    <updated>2021-10-09T09:24:30.373Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/zT0UU5c.jpg" alt=""></p><p>之所以會撰寫這篇文，是因為面試過程被考倒的觀念，才發現自己過去從沒注意到這部分啊，那就來寫篇文章來認識它們之中的傳遞方式。</p><h2 id="首先，先從型別的認識開始"><a href="#首先，先從型別的認識開始" class="headerlink" title="首先，先從型別的認識開始"></a>首先，先從型別的認識開始</h2><p>在Javascript分兩大類，一種是基本型別(primitive type)，另一種是物件(Object)。</p><ul><li>Primitive type （以純值的形式存在）<br>Boolean<br>Null<br>Undefined<br>Number<br>BigInt<br>String<br>Symbol（於 ECMAScript 6 新定義）</li><li>Object<br>物件型別指的是可能由零或多種不同型別 (包括純值與物件) 所組合成，例如object,array, function, map</li></ul><p>知道型別後，可以簡易的分類：</p><ul><li>primitive type會是 pass by value，</li><li>object 是 pass by reference。</li></ul><h2 id="接下來來觀察，它們之間不同"><a href="#接下來來觀察，它們之間不同" class="headerlink" title="接下來來觀察，它們之間不同"></a>接下來來觀察，它們之間不同</h2><h3 id="pass-by-value"><a href="#pass-by-value" class="headerlink" title="pass by value"></a>pass by value</h3><p>範例1：</p><pre><code class="javascript">let x=10;let y=x;x=20;console.log(x); //20console.log(y); //10</code></pre><ul><li>注意：x和y是兩個獨立變數 （先記著這點）<ul><li>值會存入該變數<br><code>var y = x;</code> 看起來會像是y的內容要複製x，但可以的話要理解為，變數 y 是去建立了一個新的值，然後將變數 x 的內容複製了一份過來。</li></ul></li><li>因為兩的變數，各自獨立，所以當變數 x 的內容後來經過更新變成 20 之後，變數 y 的內容依舊保持原來的 10 而不受影響。</li></ul><p>範例2</p><pre><code class="javascript">var num=3;console.log(&quot;num start:&quot;,num);function passByValue(func_num){  func_num=5;}passByValue(num);console.log(&quot;num end:&quot;, num);</code></pre><h4 id="結果："><a href="#結果：" class="headerlink" title="結果："></a>結果：</h4><pre><code class="javascript">num start:3num end: 3</code></pre><ul><li>先是宣告新變數</li><li>隨後建立<code>passByValue()</code> 函式</li><li>呼叫<code>passByValue(num)</code> 複製變數num的值，3傳入<code>passByValue(func_num)</code>。<ul><li>一開始 值會是3</li><li>遇到<code>func_num=5;</code> =&gt; 將值改為 5</li></ul></li><li>但因為出去了函式範圍(scope)，最終的值 <code>num end:3</code></li></ul><h3 id="pass-by-refrence"><a href="#pass-by-refrence" class="headerlink" title="pass by refrence"></a>pass by refrence</h3><p>範例</p><pre><code class="javascript">let x={value:10};let y=x;x.value=20;console.log(x); //{value:20}console.log(y); //{value:20}console.log( x === y );  //true</code></pre><h3 id="拆解說明一下"><a href="#拆解說明一下" class="headerlink" title="拆解說明一下"></a>拆解說明一下</h3><ul><li>當宣告一個物件</li><li>JavaScript 會在記憶體的某處建立起一個物件 (圖右側)，然後再將這個 <code>x</code>變數指向新生成的物件</li></ul><p><img src="https://i.imgur.com/LPwkZAg.png" alt=""></p><ul><li>接著，當我們宣告了第二個變數 y ，並且透過 = 將y 指向 x 的位置。</li><li>接著當我們更新了 x.value 的內容後， y.value 的內容也被更新了。</li></ul><p><img src="https://i.imgur.com/vFUhP6X.png" alt=""></p><p>範例2</p><pre><code class="javascript">var obj1={item:&quot;unchanged&quot;};console.log(&quot;obj1 start:&quot;,obj1);function passByReference(ref){  ref.item= &quot;changed&quot;;}passByReference(obj1);console.log(&quot;obj end&quot;, obj1);</code></pre><h4 id="結果"><a href="#結果" class="headerlink" title="結果"></a>結果</h4><pre><code class="javascript">obj1 start:{item: &quot;unchanged&quot;}obj1 end:{item:&quot;changed&quot;}</code></pre><ul><li>當執行passByReference(obj1) 。想像他是個地址(0x0016)，進入函式中將地址複製，傳入。<ul><li>此時他的value 是個地址(0x0016)</li></ul></li><li>進入函式，遇到<code>ref.item</code><ul><li>de-reference ，進入原本的記憶體位置，找到item，並改變他的值</li></ul></li></ul><p><img src="https://i.imgur.com/3Ytn7bk.png" alt=""></p><h4 id="在不一般情況下，基本型別是-pass-by-value，而物件型別是-pass-by-reference的方式，但總有例外的時候。"><a href="#在不一般情況下，基本型別是-pass-by-value，而物件型別是-pass-by-reference的方式，但總有例外的時候。" class="headerlink" title="在不一般情況下，基本型別是 pass by value，而物件型別是 pass by reference的方式，但總有例外的時候。"></a>在不一般情況下，基本型別是 pass by value，而物件型別是 pass by reference的方式，但總有例外的時候。</h4><h3 id="pass-by-sharing"><a href="#pass-by-sharing" class="headerlink" title="pass by  sharing"></a>pass by  sharing</h3><pre><code class="javascript">var obj1={item:&quot;unchanged&quot;};console.log(&quot;obj1 start:&quot;,obj1);function passBySharing(ref){  ref={ item: &quot;changed&quot;};}passBySharing(obj1);console.log(&quot;obj end&quot;, obj1);</code></pre><pre><code class="javascript">obj1 start:{item: &quot;unchanged&quot;}obj1 end:{item:&quot;unchanged&quot;}</code></pre><ul><li>傳入之前start 沒有改變</li><li>呼叫函式，並進入<code>passBySharing()</code>，還是複製地址，傳入</li><li>遇到<code>ref={ item: &quot;changed&quot;};</code>，會直接覆蓋地址(有點類似pass by value)<ul><li>這並不是直接更改物件特性</li></ul></li></ul><p><img src="https://i.imgur.com/Kst3565.png" alt=""></p><h2 id="最後，來說說-JavaScript-屬於？"><a href="#最後，來說說-JavaScript-屬於？" class="headerlink" title="最後，來說說 JavaScript 屬於？"></a>最後，來說說 JavaScript 屬於？</h2><p>看了多篇文章，實在也是有點混亂，該認為三種形式都有呢？還是就是Pass by sharing、Pass by reference呢？ 那例外情形又該如何解釋？</p><p>所以這邊的結尾，直接引用Kuro、Huli老師文章的資訊，供給大家參考。</p><p>從Kuro Hsu 的<a href="https://ithelp.ithome.com.tw/articles/10191057" target="_blank" rel="noopener">文章</a>、<a href="https://www.tenlong.com.tw/products/9789864344130" target="_blank" rel="noopener">書</a><br>提及認為 JavaScript 應該更屬於 Pass by sharing 的形式。</p><ul><li>JavaScript 不屬於單純的傳值或傳址。</li></ul><p>參考 ECMA-262-3 in detail. Chapter 8. Evaluation strategy</p><blockquote><p>Regardless of usage concept of reference in this case, this strategy should not be confused with the “call by reference” discussed above. The value of the argument is not a direct alias, but the copy of the address.<br>由於在 JavaScript 的物件類型是可變的 (mutable)，當物件更新時，會影響到所有引用這個物件的變數與其副本，修改時會變動到原本的參考，但當賦與新值時，會產生新的實體參考。</p></blockquote><p>另外在 Huli 的文章中：</p><blockquote><p>依據細分程度的不同，下面幾句話都是正確的：<br>JavaScript 裡面只有 pass by value<br>JavaScript 的 primitive type 是 pass by value，object 是 pass by sharing</p></blockquote><hr><h2 id="最終來個綜合練習："><a href="#最終來個綜合練習：" class="headerlink" title="最終來個綜合練習："></a>最終來個綜合練習：</h2><p>相信在最後的這個練習，可以更清楚，pass by value，pass by reference，pass by sharing</p><pre><code class="javascript">function changeStuff(num,obj,obj2){  num=num*10;  obj.item=&quot;changed&quot;;  obj={item:&quot;changed&quot;};}var num=10;var obj={item: &quot;unchanged&quot;};var obj2= {item: &quot;unchanged&quot;};changeStuff(num, obj, obj2);console.log(num);console.log(obj.item);console.log(obj.item);</code></pre><pre><code>console=&gt; 10 &quot;changed&quot; &quot;unchanged&quot;</code></pre><p>參考資料：<br><a href="https://medium.com/@mengchiang000/js%E5%9F%BA%E6%9C%AC%E8%A7%80%E5%BF%B5-call-by-value-%E9%82%84%E6%98%AFreference-%E5%8F%88%E6%88%96%E6%98%AF-sharing-22a87ca478fc" target="_blank" rel="noopener">JS基本觀念：call by value 還是reference 又或是 sharing?</a><br><a href="https://ithelp.ithome.com.tw/articles/10191057" target="_blank" rel="noopener">重新認識 JavaScript: Day 05 JavaScript 是「傳值」或「傳址」？</a><br><a href="https://www.youtube.com/watch?v=1YFss_4B_o4&t=302s" target="_blank" rel="noopener">Tech Talk: Pass By Sharing with Javascript</a><br><a href="https://blog.techbridge.cc/2018/06/23/javascript-call-by-value-or-reference/" target="_blank" rel="noopener">深入探討 JavaScript 中的參數傳遞：call by value 還是 reference？</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/zT0UU5c.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;之所以會撰寫這篇文，是因為面試過程被考倒的觀念，才發現自己過去從沒注意到這部分啊，那就來寫篇文章來認識它們之中的傳遞方式。&lt;/p&gt;
&lt;h2 id=&quot;首先，先從</summary>
      
    
    
    
    
    <category term="JS" scheme="https://github.com/Eva813/Eva813.github.io.git/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>演算法入門 - Sorting-Algorithms</title>
    <link href="https://github.com/Eva813/Eva813.github.io.git/2021/10/08/Sorting-Algorithms/"/>
    <id>https://github.com/Eva813/Eva813.github.io.git/2021/10/08/Sorting-Algorithms/</id>
    <published>2021-10-08T06:08:05.000Z</published>
    <updated>2021-10-12T08:06:52.414Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/glzKE9I.png" alt=""></p><p>延續 Wilson Ren<a href="https://www.udemy.com/course/algorithm-data-structure/?course_id=3819536&fbclid=IwAR3ugnEJMsniBCvoMHthf31EqEQeG9hCL3BQb2gWS7eAFZ4lcixmWOiwNAo" target="_blank" rel="noopener">課程</a>來認識常見的排列方法！</p><h2 id="排列的演算法介紹"><a href="#排列的演算法介紹" class="headerlink" title="排列的演算法介紹"></a>排列的演算法介紹</h2><p><img src="https://i.imgur.com/zeRjPef.png" alt=""></p><ul><li>在JS中，就有內建 <code>array.sort()</code><ul><li>同樣在其他程式語言，都會有內建的 sorting function</li><li>但還是需要知道他們是如何運作</li></ul></li><li>總共有 6 種 sorting</li><li>此篇文章會以前面兩種為主</li></ul><h2 id="Bubble-Sort"><a href="#Bubble-Sort" class="headerlink" title="Bubble Sort"></a>Bubble Sort</h2><ul><li>冒泡排序</li><li>會比較相鄰的元素，如果順序不對會互換element</li><li>是相當簡單的演算法，在現實世界很少拿來使用，最常用在教學</li><li>而像在python、java 他們內建的排序演算法，都不是用冒泡排序，多是用 quicksort,merge sort（比較複雜、但有效率）<h3 id="範例說明"><a href="#範例說明" class="headerlink" title="範例說明"></a>範例說明</h3><img src="https://i.imgur.com/pDdBK9i.png" alt=""></li><li>比較array的最後兩個數字 =&gt; 發現順序不對就對調<br><img src="https://i.imgur.com/ElpC2qh.png" alt=""></li><li>對調之後，再往下兩個元素<ul><li>發現順序正確，不需更動<br><img src="https://i.imgur.com/mQuFUvU.png" alt=""></li></ul></li><li>不更動之後，再往下兩個<br><img src="https://i.imgur.com/Qk1T9c3.png" alt=""><br>以此類推…</li><li>小結：將找到的最小值，推到最左邊</li></ul><h3 id="要如何做-Bubble-Sort"><a href="#要如何做-Bubble-Sort" class="headerlink" title="要如何做 Bubble Sort"></a>要如何做 Bubble Sort</h3><ul><li><p>先從一個陣列中2個數值比較開始思考</p><pre><code>for j from A.length-1 to 1; if A[j] &lt; A[j-i] ; swap A[j] and A[j-i]</code></pre></li><li><p>虛擬碼<br><img src="https://i.imgur.com/2VFPI3E.png" alt=""></p></li><li><p>i =&gt; sorted elements</p></li><li><p>j =&gt; adjacent elements(j是相對i而來)</p><pre><code class="javascript">function bubbleSort(arr){  for(let i=0;i&lt;arr.length-2;i++){    for(let j=arr.length-1;j&gt;=i+1;j--){      if (arr[j]&lt;arr[j-1]){        //swap arr[j] and arr[j-1]        let temp=arr[j];        arr[j] = arr[j-1];        arr[j-1] = temp;      }    }  }  console.log(arr);}bubbleSort([4,1,5,2,7]);</code></pre></li><li><p>加入隨機的數字，組成新的陣列</p><pre><code class="javascript">function bubbleSort(arr) {let step = 0;for (let i = 0; i &lt;= arr.length - 2; i++) {  for (let j = arr.length - 1; j &gt;= i + 1; j--) {    if (arr[j] &lt; arr[j - 1]) {      // swap arr[j] and arr[j - 1]      let temp = arr[j];      arr[j] = arr[j - 1];      arr[j - 1] = temp;      step++;    }  }}console.log(&quot;It takes &quot; + step + &quot; steps to complete.&quot;);console.log(arr);}</code></pre></li></ul><p>let test = [];</p><p>for (let i = 0; i &lt; 100; i++) {<br>  test.push(Math.floor(Math.random() * 100));<br>}</p><p>bubbleSort(test);</p><pre><code>## Big O of Bubble Sort![](https://i.imgur.com/NSg6FSC.png)* 最糟情況下： 由大到小，要排成 由小到大 =&gt; 他交換的次數會是 (n-1)+(n-2)+(n-3)+...+(n-n)次* 最好的情況： 本身的arr就接近 小到大    * 優化語法    * 發現沒有任何elements被交換，就可以停止迴圈```javascriptfunction bubbleSort(arr){    for(let i=0;i&lt;arr.length-2;i++){      let swapping=false;      for(let j=arr.length-1;j&gt;=i+1;j--){        if (arr[j]&lt;arr[j-1]){          //swap arr[j] and arr[j-1]          let temp=arr[j];          arr[j] = arr[j-1];          arr[j-1] = temp;          swapping=true;        }      }    }    if (swapping==false){      break;    }  }</code></pre><ul><li>平均情況還是用到 nested for loop<ul><li>O(n^2)</li></ul></li></ul><h2 id="Insertion-Sort"><a href="#Insertion-Sort" class="headerlink" title="Insertion Sort"></a>Insertion Sort</h2><p><img src="https://i.imgur.com/NwAm9cW.png" alt=""></p><ul><li>效率比 bubble sort 好一些</li><li>理論上， 都是 O(n^2)</li><li>不斷做插入的動作<h3 id="範例說明-1"><a href="#範例說明-1" class="headerlink" title="範例說明"></a>範例說明</h3><img src="https://i.imgur.com/HtfgFYG.png" alt=""></li><li>先認為這條arr長度是1</li><li>從陣列最前面開始，要將1插入4這個arr上</li></ul><p><img src="https://i.imgur.com/CrYGinm.png" alt=""></p><ul><li><p>數字2，要和左邊的數字作比較<br><img src="https://i.imgur.com/lb7mYhc.png" alt=""></p></li><li><p>數字3去比較<br><img src="https://i.imgur.com/gqnhQYA.png" alt=""></p></li></ul><h3 id="虛擬碼"><a href="#虛擬碼" class="headerlink" title="虛擬碼"></a>虛擬碼</h3><p><img src="https://i.imgur.com/lNSbpjL.png" alt=""></p><pre><code>index 0,1,2,3,4value 1,2,3,4,0</code></pre><ul><li>檢查這條arr的 index=1</li><li>設定<code>key=A[j]</code>，並將key插入 sorted sequence <ul><li>j 的前一格為 i</li></ul></li><li>確認 i 有沒有大於key =&gt; 也就是對於key而言，要不斷地和它左邊的值比較<ul><li>如果左邊的值比key大，就要讓他們互換</li></ul></li></ul><pre><code>index 0,1,2,3,4value 1,2,3,4 (i),0 (j key)while i&gt;0 &amp;&amp; A[i] &gt; key  A[i+1] = A[i]  i -= 1</code></pre><ul><li>語法</li></ul><pre><code class="javascript">let unsorted = [14, -4, 17, 6, 22, 1, -5];insertionSort(unsorted);function insertionSort(arr) {  for (let j = 1; j &lt;= arr.length - 1; j++) {    let key = arr[j];    i = j - 1;    while (i &gt;= 0 &amp;&amp; arr[i] &gt; key) {      arr[i + 1] = arr[i];      i -= 1;    }    arr[i + 1] = key;  }  console.log(arr);  return arr;}</code></pre><p><img src="https://i.imgur.com/E8xWtkL.png" alt=""></p><h2 id="Big-O"><a href="#Big-O" class="headerlink" title="Big O"></a>Big O</h2><p><img src="https://i.imgur.com/OVF4VRl.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/glzKE9I.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;延續 Wilson Ren&lt;a href=&quot;https://www.udemy.com/course/algorithm-data-structure/?co</summary>
      
    
    
    
    
    <category term="Algorithm" scheme="https://github.com/Eva813/Eva813.github.io.git/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>演算法入門</title>
    <link href="https://github.com/Eva813/Eva813.github.io.git/2021/10/02/Algorithm/"/>
    <id>https://github.com/Eva813/Eva813.github.io.git/2021/10/02/Algorithm/</id>
    <published>2021-10-02T05:17:40.000Z</published>
    <updated>2021-10-12T06:29:45.095Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/LHDcmBI.png" alt=""></p><p>常常看到 YouTube 演算法造成頻道經營的難度、或是facebook演算法而使得行銷曝光度的改變，但始終對演算法這個名詞沒有認識。<br>藉由 Wilson Ren<a href="https://www.udemy.com/course/algorithm-data-structure/?course_id=3819536&fbclid=IwAR3ugnEJMsniBCvoMHthf31EqEQeG9hCL3BQb2gWS7eAFZ4lcixmWOiwNAo" target="_blank" rel="noopener">課程</a></p><h2 id="什麼是演算法？"><a href="#什麼是演算法？" class="headerlink" title="什麼是演算法？"></a>什麼是演算法？</h2><p>用以解決問題而可以逐步執行的步驟或程序。</p><h4 id="來看看現實生活中的演算法"><a href="#來看看現實生活中的演算法" class="headerlink" title="來看看現實生活中的演算法"></a>來看看現實生活中的演算法</h4><ul><li>Google Map 如何找到最短路徑</li><li>YouTube 推薦給你，認為你有興趣的影片</li><li>FB\IG 的加好友、追蹤推薦</li></ul><h2 id="演算法比較"><a href="#演算法比較" class="headerlink" title="演算法比較"></a>演算法比較</h2><p>有兩個演算法都可以完成目標任務，那我們會如何取決誰比較好？</p><ul><li>哪個演算法執行速度快？</li><li>所佔用電腦的記憶體資源少？<h3 id="時間"><a href="#時間" class="headerlink" title="時間?"></a>時間?</h3>首先，在計時演算法所耗時的部分：</li><li>幫演算法做計時，是不實際的事情<ul><li>同一台電腦在執行同一任務，所執行的時間會不同</li><li>不同電腦、CPU處理速度不一樣<h4 id="應該考慮，複雜度-Complexity"><a href="#應該考慮，複雜度-Complexity" class="headerlink" title="應該考慮，複雜度 Complexity"></a>應該考慮，複雜度 Complexity</h4></li></ul></li><li>複雜度分為兩種：時間複雜度、空間複雜度 （在本文多是討論時間複雜度）</li><li>要如何計算時間複雜度?<ul><li>加、減、乘、除、comparison ，這些每一個都可以被算作一個 operation</li><li>Complexity: 在所寫的演算法中，總共用到多少 operations(運算子)</li><li>使用 function 來顯示 Complexity 和 input size 的關係。</li></ul></li></ul><h2 id="Big-O-Notation"><a href="#Big-O-Notation" class="headerlink" title="Big O Notation"></a>Big O Notation</h2><ol><li>是一個工具，用來描述當你的值不斷擴大時，f(n)值會去哪裡</li><li>為最壞情況的打算。他會展示一個演算法複雜度的趨勢</li></ol><h3 id="計算-Big-O-的值"><a href="#計算-Big-O-的值" class="headerlink" title="計算 Big O 的值"></a>計算 Big O 的值</h3><ol><li>Constant doesn’t matter : 常數它並不重要<ul><li>f(n)=3n ：3為常數、n為變數</li></ul></li><li>Small Terms don’t matter<ul><li>fn= 3n^2 + 6n + 4 =&gt; 只需保留到fn= 3n^2</li></ul></li><li>Logarithm Base doesn’t matter<br><img src="https://i.imgur.com/dNM08rx.png" alt=""><h2 id="範例："><a href="#範例：" class="headerlink" title="範例："></a>範例：</h2></li><li>f(n)=3n<br>答案：O(n)</li><li>f(n)=13n^3 + 6n +7<br>答案：O(n^3)</li><li>f(n)=4log₂n<br>答案：O(logn)</li><li>f(n)=5<br>答案：O(1)</li></ol><h2 id="演算法常見-Big-O-的值"><a href="#演算法常見-Big-O-的值" class="headerlink" title="演算法常見 Big O 的值"></a>演算法常見 Big O 的值</h2><p>由好至差</p><ol><li>O(1)</li><li>O(logn)</li><li>O(n)</li><li>O(nlogn)</li><li>O(n^2)</li><li>O(n^3)</li></ol><ul><li>很多sorting值會是 O(nlogn)</li><li>盡量讓演算法可以達到3、4的值</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/LHDcmBI.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;常常看到 YouTube 演算法造成頻道經營的難度、或是facebook演算法而使得行銷曝光度的改變，但始終對演算法這個名詞沒有認識。&lt;br&gt;藉由 Wilso</summary>
      
    
    
    
    
    <category term="Algorithm" scheme="https://github.com/Eva813/Eva813.github.io.git/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js 3 -  資料傳遞 emit</title>
    <link href="https://github.com/Eva813/Eva813.github.io.git/2021/09/21/vue-emit/"/>
    <id>https://github.com/Eva813/Eva813.github.io.git/2021/09/21/vue-emit/</id>
    <published>2021-09-21T04:42:48.000Z</published>
    <updated>2021-10-25T05:22:15.348Z</updated>
    
    <content type="html"><![CDATA[<p>圖示：<br><img src="https://i.imgur.com/PxIIobu.png" alt=""></p><h2 id="emit-實作練習"><a href="#emit-實作練習" class="headerlink" title="emit 實作練習"></a>emit 實作練習</h2><p><img src="https://i.imgur.com/7guYdVb.png" alt=""></p><ul><li>透過點擊add按鈕，觸發外層元件數值的改變<ul><li>先定義外層接收資料方式</li><li>定義內層的 $emit 觸發方法</li><li>使用 v-on 的方式觸發外層方法（口訣：前內、後外）</li></ul></li></ul><h3 id="外層元件"><a href="#外層元件" class="headerlink" title="外層元件"></a>外層元件</h3><ul><li><p>定義接收方法：當內層傳給你的時候，要做什麼事</p><ul><li><p><code>addNumber()</code>使num 增加1</p><pre><code class="javascript">const app = Vue.createApp({      data() {        return {          num: 0,          text: &#39;&#39;        };      },      methods: {        addNumber() {          console.log(&#39;addnumber&#39;);          this.num++;        },      }    });</code></pre></li></ul></li></ul><h3 id="內層元件"><a href="#內層元件" class="headerlink" title="內層元件"></a>內層元件</h3><ul><li>在方法內建立函式，來觸發資料傳遞</li><li>並將<code>click</code>綁到內部元件的按鈕上。使點擊時候，會觸發$emit<ul><li>emit 名稱<code>emit-num</code><pre><code class="javascript">app.component(&#39;button-counter&#39;, {      methods: {        click() {          console.log(&#39;inner,click&#39;);          this.$emit(&#39;emit-num&#39;);        }      },      template: `&lt;button type=&quot;button&quot; @click=&quot;click&quot;&gt;add&lt;/button&gt;`    });</code></pre></li></ul></li></ul><p><img src="https://i.imgur.com/W1s9mhp.png" alt=""></p><h2 id="建立內外層元件的溝通橋樑"><a href="#建立內外層元件的溝通橋樑" class="headerlink" title="建立內外層元件的溝通橋樑"></a>建立內外層元件的溝通橋樑</h2><ul><li>使用 v-on 的方式觸發外層方法（口訣：前內、後外）<ul><li>在 div內放入子元件<code>button-counter</code></li><li><code>:emit-num=&quot;addNumber&quot;</code></li></ul></li></ul><pre><code class="javascript">&lt;div id=&quot;app&quot;&gt;          {{ num }}    &lt;button-counter v-on:emit-num=&quot;addNumber&quot;&gt;&lt;/button-counter&gt;     &lt;/div&gt;</code></pre><h2 id="練習二，資料接收"><a href="#練習二，資料接收" class="headerlink" title="練習二，資料接收"></a>練習二，資料接收</h2><h3 id="外層元件-1"><a href="#外層元件-1" class="headerlink" title="外層元件"></a>外層元件</h3><ul><li><p>接收方法為 <code>getData</code> 接收 text</p><pre><code class="javascript">const app = Vue.createApp({          data() {            return {              text: &#39;&#39;            };          },          methods: {            getData(value) {              console.log(&#39;getData&#39;, text);              this.text = value;            }          }        });</code></pre></li></ul><h3 id="內層元件-1"><a href="#內層元件-1" class="headerlink" title="內層元件"></a>內層元件</h3><ul><li>建立觸發傳遞的方式<ul><li>將內層元件<code>text: &#39;內部資料&#39;</code> 傳遞到外層<pre><code class="javascript">app.component(&#39;button-text&#39;, {data() {  return {  text: &#39;內部資料&#39;,   }},methods: {emitText() {this.emit(&#39;emit-text&#39;, this.text)   }},template: `&lt;button type=&quot;button&quot; @click=&quot;emitText&quot;&gt;emit data&lt;/button&gt;`});</code></pre><h3 id="建立內外橋樑"><a href="#建立內外橋樑" class="headerlink" title="建立內外橋樑"></a>建立內外橋樑</h3><pre><code class="javascript">&lt;h3&gt;傳遞資料狀態&lt;/h3&gt;內部傳來的文字：{{ text }}&lt;br&gt;&lt;button-text @emit-text=&quot;getData&quot;&gt;&lt;/button-text&gt;</code></pre><img src="https://i.imgur.com/avhMirS.png" alt=""></li></ul></li></ul><h2 id="emit-命名"><a href="#emit-命名" class="headerlink" title="emit 命名"></a>emit 命名</h2><p>與 props 命名一樣需要注意：</p><ul><li>在內層若以駝峰命名 <code>emitText</code><ul><li>也可以一開始內層就是用<code>-</code> 來命名即可，如<code>emit-text</code><pre><code class="javascript">emitText() { this.emit(&#39;emitText&#39;, this.text)}</code></pre></li></ul></li><li>到了要綁定的 template 上，<code>emit-text</code><pre><code class="javascript">&lt;button-text @emit-text=&quot;getData&quot;&gt;&lt;/button-text&gt;</code></pre></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;圖示：&lt;br&gt;&lt;img src=&quot;https://i.imgur.com/PxIIobu.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;emit-實作練習&quot;&gt;&lt;a href=&quot;#emit-實作練習&quot; class=&quot;headerlink&quot; title=&quot;emit 實作練習</summary>
      
    
    
    
    
    <category term="Vue" scheme="https://github.com/Eva813/Eva813.github.io.git/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js 3 -  資料傳遞 props</title>
    <link href="https://github.com/Eva813/Eva813.github.io.git/2021/09/21/vue-props/"/>
    <id>https://github.com/Eva813/Eva813.github.io.git/2021/09/21/vue-props/</id>
    <published>2021-09-21T03:42:48.000Z</published>
    <updated>2021-10-25T05:22:10.673Z</updated>
    
    <content type="html"><![CDATA[<p>因為Vue每個元件都是各自獨立，所以我們無法在各自元件去調整資料，而直接修改另一個元件的資料。<br>所以，要使元件之間可以相互溝通，就需要使用資料傳遞方式。<br>在傳遞方式：</p><ul><li>外層傳遞內層 : props</li><li>內層向外傳遞 : emit<br>當外層元件，要將資料往內層元件丟時，此過程就是使用props。</li></ul><p><img src="https://i.imgur.com/FTbHDPk.png" alt=""></p><h2 id="傳遞資料的方式："><a href="#傳遞資料的方式：" class="headerlink" title="傳遞資料的方式："></a>傳遞資料的方式：</h2><h3 id="靜態資料傳入"><a href="#靜態資料傳入" class="headerlink" title="靜態資料傳入"></a>靜態資料傳入</h3><ul><li>預期將外層傳入一個url的變數，傳進給內層使用<ul><li>photo為內部元件，在template 我希望能夠取得外層傳入的圖片(urlimg)</li><li>故在 props 以此命名，並將它綁到 template<pre><code class="javascript">app.component(&#39;photo&#39;, {  props: [&#39;url&#39;],  template: `&lt;img :src=&quot;url&quot; class=&quot;img-thumbnail&quot; alt&gt;`});</code></pre></li></ul></li><li>將上方的元件資料，加到外層元件：像是加入html屬性一樣<pre><code class="javascript">&lt;photo  url=&quot;https://images.unsplash.com/photo-1605784401368-5af1d9d6c4dc?ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&amp;ixlib=rb-1.2.1&amp;auto=format&amp;fit=crop&amp;w=600&amp;q=80&quot;&gt;&lt;/photo&gt;</code></pre></li></ul><p><img src="https://i.imgur.com/f079ziY.png" alt=""></p><h3 id="動態資源"><a href="#動態資源" class="headerlink" title="動態資源"></a>動態資源</h3><ul><li>使用 <code>v-bind</code>，綁定內部元件的props ，使資料可以跟外層元件連動</li><li>記得使用口訣： 前內、後外 =&gt;前面就是props內的名稱，後面就是外層元件的名稱<br><img src="https://i.imgur.com/BMVZtkn.png" alt=""><pre><code class="htmlembedded">&lt;h3&gt;動態資源&lt;/h3&gt;&lt;p&gt;技巧：前內、後外&lt;/p&gt;&lt;photo v-bind:urlimg=&quot;imgUrl&quot;&gt;&lt;/photo&gt;</code></pre></li></ul><h2 id="資料傳遞為-單向數據流"><a href="#資料傳遞為-單向數據流" class="headerlink" title="資料傳遞為 單向數據流"></a>資料傳遞為 單向數據流</h2><ul><li>外部所定義的資料，當往內層傳遞，是單向性</li><li>不能試圖使用v-model或各種方式，來改變props傳入的內容<ul><li>以下範例：在子元件 <code>photo2</code> 放入 <code>input</code>綁定 <code>v-model</code></li><li>當嘗試在輸入框修改網址，會出現錯誤</li></ul></li></ul><pre><code class="javascript">//外層元件綁定 url&lt;photo2 :url=&quot;imgUrl&quot;&gt;&lt;/photo2&gt;</code></pre><pre><code class="javascript">const app = Vue.createApp({    data() {    return {      imgUrl: &#39;https://images.unsplash.com/photo-1605784401368-5af1d9d6c4dc?ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&amp;ixlib=rb-1.2.1&amp;auto=format&amp;fit=crop&amp;w=600&amp;q=80&#39;,         };     },}); app.component(&#39;photo2&#39;, {    props: [&#39;url&#39;],    template: `&lt;img :src=&quot;url&quot; class=&quot;img-thumbnail&quot; alt&gt;&lt;br&gt;    &lt;input type=&quot;text&quot; v-model=&quot;url&quot;&gt; {{ url }}`     })</code></pre><p><img src="https://i.imgur.com/OmmIxpi.png" alt=""></p><p><img src="https://i.imgur.com/2BqCNTp.png" alt=""></p><h2 id="在內部元件，要為props來命名"><a href="#在內部元件，要為props來命名" class="headerlink" title="在內部元件，要為props來命名"></a>在內部元件，要為props來命名</h2><p>在命名上有些要注意的地方</p><ul><li>首字母大寫: PostData、SetItems</li><li>駝峰命名法: postData、setItems<br>要注意：在 HTML 中使用時必須使用 kebab-case (短橫線分隔)且應該為小寫。</li></ul><pre><code class="javascript">&lt;div id=&quot;app&quot;&gt; &lt;photo3 :super-url=&quot;imgUrl&quot; &gt;&lt;/photo3&gt;&lt;/div&gt;&lt;script&gt;Vue.component(&quot;photo3&quot;, {  props: [&quot;superUrl&quot;],  template: `&lt;img :src=&quot;superUrl&quot; class=&quot;img-thumbnail alt &gt;&quot;`});&lt;/script&gt;</code></pre><p><img src="https://i.imgur.com/57P1JDW.png" alt=""></p><h2 id="定義-Props-型別驗證"><a href="#定義-Props-型別驗證" class="headerlink" title="定義 Props 型別驗證"></a>定義 Props 型別驗證</h2><ul><li><p>使用型別驗證，會改用大括號，裡面放入props名稱，並用物件形式加入設定的內容</p><ul><li><code>props:{  propC: {  type: String,  required: true,  }}</code></li></ul></li><li><p>其中，可以針對該props 來設定：</p><ul><li><p><code>type</code>型別 ： 可以是 String、Number、Boolean、Array、Object、Date、Function、Symbol</p></li><li><p><code>default</code> ：如果該 prop 沒有接收到傳入的值，就會使用 default 的值作為預設值。</p></li><li><p><code>required</code> ： 是否為必填項，如果設為 true 則表示必須要有值傳入，若沒有，就會出現錯誤提示。</p><pre><code class="javascript">app.component(&#39;props-validation&#39;, {props: {// 單一型別檢查，可接受的型別 String, Number, Object, Boolean, Function(在 Vue 中可使用 Function 驗證型別)// null, undefined 會直接通過驗證propA: Function,// 多個型別檢查propB: [String, Number],// 必要值propC: {  type: String,  required: true,},// 預設值propD: {  type: Number,  default: 300},// 自訂函式propE: {  type: Object,  default() {    return {      money: 300    }  }},// 自訂驗證propF: {  validator(value) {    return value &gt; 1000  }}, },</code></pre><p><a href="https://www.hexschool.com/courses/vue3.html" target="_blank" rel="noopener">六角學院</a><br><a href="https://ithelp.ithome.com.tw/articles/10254050" target="_blank" rel="noopener">[DAY12]跟 Vue.js 認識的30天 - Vue 模組資料傳遞(<code>props</code>)</a></p></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;因為Vue每個元件都是各自獨立，所以我們無法在各自元件去調整資料，而直接修改另一個元件的資料。&lt;br&gt;所以，要使元件之間可以相互溝通，就需要使用資料傳遞方式。&lt;br&gt;在傳遞方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;外層傳遞內層 : props&lt;/li&gt;
&lt;li&gt;內層向外傳遞 : e</summary>
      
    
    
    
    
    <category term="Vue" scheme="https://github.com/Eva813/Eva813.github.io.git/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js 3 - v-on 修飾符</title>
    <link href="https://github.com/Eva813/Eva813.github.io.git/2021/09/20/Vue-modify/"/>
    <id>https://github.com/Eva813/Eva813.github.io.git/2021/09/20/Vue-modify/</id>
    <published>2021-09-20T07:06:46.000Z</published>
    <updated>2021-10-05T08:38:42.809Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/NBBY8vo.png" alt=""></p><p>修飾符有分為：<br>1.按件修飾符<br>2.滑鼠修飾符<br>3.事件修飾符</p><p><a href="https://codepen.io/Eva-go/pen/RwgMXGN" target="_blank" rel="noopener">codepen</a></p><h2 id="按鍵修飾符"><a href="#按鍵修飾符" class="headerlink" title="按鍵修飾符"></a>按鍵修飾符</h2><h3 id="1-1-別名修飾"><a href="#1-1-別名修飾" class="headerlink" title="1-1. 別名修飾"></a>1-1. 別名修飾</h3><ul><li>在特定按鍵，按下去的時候觸發<ul><li><code>.enter</code>, <code>.tab</code>, <code>.delete</code>, <code>.esc</code>, <code>.space</code>, <code>.up</code>, <code>.down</code>, <code>.left</code>, <code>.righ</code></li></ul></li><li>使用<code>.enter</code>只有再按下 enter 鍵才會觸發</li></ul><pre><code class="html">  &lt;div id=&quot;app&quot;&gt;   &lt;h6 class=&quot;mt-3&quot;&gt;別名修飾&lt;/h6&gt;  &lt;input type=&quot;text&quot; class=&quot;form-control&quot; v-model=&quot;text&quot; @keyup.enter=&quot;trigger(&#39;enter&#39;)&quot;&gt;  &lt;/div&gt;</code></pre><pre><code class="javascript">Vue.createApp({  data(){     return {    }  },  methods: {   trigger: function(name) {      console.log(name, &#39;此事件被觸發了&#39;)    },  }}).mount(&#39;#app&#39;)</code></pre><h3 id="1-2-相應按鍵時才觸發的監聽器"><a href="#1-2-相應按鍵時才觸發的監聽器" class="headerlink" title="1-2. 相應按鍵時才觸發的監聽器"></a>1-2. 相應按鍵時才觸發的監聽器</h3><ul><li>僅在按下相應按鍵時才觸發鼠標或鍵盤事件的監聽器</li><li><code>.ctrl</code>, <code>.alt</code>, <code>.shift</code>, <code>.meta</code></li><li>此範例為 <code>@keyup.shift.enter</code><pre><code class="html">&lt;h6 class=&quot;mt-3&quot;&gt;相應按鍵時才觸發的監聽器&lt;/h6&gt;&lt;input type=&quot;text&quot; class=&quot;form-control&quot; v-model=&quot;text&quot; @keyup.shift.enter=&quot;trigger(&#39;shift + Enter&#39;)&quot;&gt;</code></pre><img src="https://i.imgur.com/gQjWYVy.png" alt=""></li></ul><ol start="2"><li>滑鼠修飾符<br><code>.left</code> 只當點擊鼠標左鍵時觸發。<br><code>.right</code> 只當點擊鼠標右鍵時觸發。<br><code>.middle</code> 只當點擊鼠標中鍵時觸發。</li></ol><ul><li>按下滑鼠右鍵<br><code>&lt;span class=&quot;box&quot; @click.right=&quot;trigger(&#39;right button&#39;)&quot;&gt;</code></li></ul><pre><code class="html">          &lt;h4&gt;滑鼠修飾符&lt;/h4&gt;          &lt;h6 class=&quot;mt-3&quot;&gt;滑鼠修飾符&lt;/h6&gt;          &lt;div class=&quot;p-3 bg-primary&quot;&gt;            &lt;span class=&quot;box&quot; @click.right=&quot;trigger(&#39;right button&#39;)&quot;&gt;            &lt;/span&gt;          &lt;/div&gt;</code></pre><p><img src="https://i.imgur.com/lddG6zT.png" alt=""></p><ol start="3"><li>事件修飾符</li></ol><ul><li>不會限定，是使用滑鼠還是鍵盤，是針對事件本身來進行修飾<br><code>.stop</code> - 調用 <code>event.stopPropagation()</code>。<br><code>.prevent</code> - 調用 <code>event.preventDefault()</code>。<br><code>.capture</code> - 添加事件偵聽器時使用 capture 模式。<br><code>.self</code> - 只當事件是從偵聽器綁定的元素本身觸發時才觸發回調。<br><code>.once</code> - 只觸發一次回調。</li><li>常用的是 <code>&lt;a&gt;</code>外部連結：移除預設事件<pre><code class="html">     &lt;h4&gt;事件修飾符&lt;/h4&gt;        &lt;ul&gt;          &lt;li&gt;.stop - 調用 event.stopPropagation()。&lt;/li&gt;          &lt;li&gt;&lt;strong&gt;.prevent - 調用 event.preventDefault()。&lt;/strong&gt;&lt;/li&gt;          &lt;li&gt;.capture - 添加事件偵聽器時使用 capture 模式。&lt;/li&gt;          &lt;li&gt;.self - 只當事件是從偵聽器綁定的元素本身觸發時才觸發回調。&lt;/li&gt;          &lt;li&gt;.once - 只觸發一次回調。&lt;/li&gt;        &lt;/ul&gt;        &lt;a href=&quot;https://www.google.com/&quot; @click.prevent=&quot;trigger(&#39;prevent&#39;)&quot;&gt;加入 Prevent&lt;/a&gt;</code></pre></li></ul><p>資料來源：<br>六角學院 - Vue 3.js</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/NBBY8vo.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;修飾符有分為：&lt;br&gt;1.按件修飾符&lt;br&gt;2.滑鼠修飾符&lt;br&gt;3.事件修飾符&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://codepen.io/Eva</summary>
      
    
    
    
    
    <category term="Vue" scheme="https://github.com/Eva813/Eva813.github.io.git/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>認識 Node.js</title>
    <link href="https://github.com/Eva813/Eva813.github.io.git/2021/06/11/node-1/"/>
    <id>https://github.com/Eva813/Eva813.github.io.git/2021/06/11/node-1/</id>
    <published>2021-06-11T06:28:30.000Z</published>
    <updated>2021-10-11T06:33:48.093Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>  之前在安裝套件時，就有先安裝過 Node.js 但從沒有特別去注意，它是應用在哪一塊、可以做什麼？就找了之前 udemy 全端課程，特意拉此部分來認識一下。</p><p>Node.js，讓我們可以將js檔案拿出瀏覽器，並直接和電腦硬件互動</p><ul><li>js: 進行網頁中的實作、函式、行為的建立。動畫的執行、下拉選單</li><li>Node.js: 允許我們用JS 直接與電腦的硬體互動。例如建立桌面應用程式</li><li>此外，還能在別人的電腦或server用Node.js來用行JS。例如：使用者登入 google 並輸入詢問，而你的瀏覽器會發出請求給google servers，而在這些servers 可以真的執行JS程式碼來執行發出的請求</li></ul><p><img src="https://i.imgur.com/49D3LbW.png" alt=""></p><h2 id="如何使用Node"><a href="#如何使用Node" class="headerlink" title="如何使用Node"></a>如何使用Node</h2><ol><li>首先，建立一個資料夾 <code>intro-to-node</code>，在資料夾內建立檔案<code>index.js</code></li><li>在該資料夾位置，運行<code>node index.js</code></li></ol><p><img src="https://i.imgur.com/fsgHKd8.png" alt=""></p><ul><li>印出檔案內的console<br><img src="https://i.imgur.com/bptXcfu.png" alt=""><br><img src="https://i.imgur.com/QQ1BXXI.png" alt=""></li></ul><h2 id="node-REPL"><a href="#node-REPL" class="headerlink" title="node REPL"></a>node REPL</h2><ul><li>Read Evaluation Print Loop</li><li>要進入：就是在終端機下node<br><img src="https://i.imgur.com/gomqsjQ.png" alt=""></li><li>和google 的console有點類似<br><img src="https://i.imgur.com/hOMWtn5.png" alt=""></li><li>取得些提示 con+ tab 會列出相關的可能性<br><img src="https://i.imgur.com/ijg4eJg.png" alt=""><br><img src="https://i.imgur.com/36ZOTYu.png" alt=""><h3 id="離開"><a href="#離開" class="headerlink" title="離開"></a>離開</h3></li><li><code>.exit</code></li><li>control+c 兩次</li><li><code>clear</code> 可以清除終端機的資料<h2 id="native-node-module"><a href="#native-node-module" class="headerlink" title="native node module"></a>native node module</h2></li><li>當安裝node，他就會包含許多建立好的模組<h3 id="使用node-js-進入電腦本地端的資料"><a href="#使用node-js-進入電腦本地端的資料" class="headerlink" title="使用node.js 進入電腦本地端的資料"></a>使用node.js 進入電腦本地端的資料</h3></li><li>nodejs.org/api 可以查到所有native node module，以及使用方式說明的文件</li><li>當要使用 modual<br><img src="https://i.imgur.com/eIDZjer.png" alt=""></li></ul><p><img src="https://i.imgur.com/DDWBxTn.png" alt=""></p><ul><li>警告 jshint esversion:6<br><img src="https://i.imgur.com/zdRpkQ4.png" alt=""></li></ul><h3 id="實際應用練習：複製檔案"><a href="#實際應用練習：複製檔案" class="headerlink" title="實際應用練習：複製檔案"></a>實際應用練習：複製檔案</h3><ul><li>在原本的資料夾內建立新的檔案<br><img src="https://i.imgur.com/ndvRf3A.png" alt=""><br><img src="https://i.imgur.com/24EYw4k.png" alt=""></li><li>在index.jd 輸入該語法<br><img src="https://i.imgur.com/0oGOWsV.png" alt=""></li><li>輸入後要運行 <code>node index.js</code><br><img src="https://i.imgur.com/hCsZbOF.png" alt=""><ul><li>運行之後會看到 <code>file2</code> 建立完成<br><img src="https://i.imgur.com/YR3MLWP.png" alt=""></li></ul></li><li>若是已經建立好的檔案</li><li>在檔案內輸入資訊<code>I am file2</code><br><img src="https://i.imgur.com/9ODoKY5.png" alt=""></li><li>執行 <code>copyFileSync</code><br><img src="https://i.imgur.com/Jae1spC.png" alt=""></li></ul><hr><h2 id="NPM-package-manager"><a href="#NPM-package-manager" class="headerlink" title="NPM package manager"></a>NPM package manager</h2><ul><li>即為 Node Package Manager 的縮寫，他是套件管理工具</li><li>在安裝node 的同時，就已經裝有 NPM<br><a href="https://tw.alphacamp.co/blog/npm-node-package-manager" target="_blank" rel="noopener">NPM是什麼？了解Node Package Manager套件管理機制</a></li><li>npm init<br><img src="https://i.imgur.com/75YtfQR.png" alt=""></li><li>建立一個 package.json<br><img src="https://i.imgur.com/HdtTW6p.png" alt=""><br><img src="https://i.imgur.com/eHkTGKZ.png" alt=""></li></ul><h2 id="如何使用真實npm"><a href="#如何使用真實npm" class="headerlink" title="如何使用真實npm"></a>如何使用真實npm</h2><p><img src="https://i.imgur.com/OQ0764J.png" alt=""></p><ul><li>在要進行安裝的資料夾內，<code>npm install superheroes</code><br><img src="https://i.imgur.com/05qxzDJ.png" alt=""><br><img src="https://i.imgur.com/XOlgK2J.png" alt=""></li><li>參考文件的說明<br><img src="https://i.imgur.com/6xrdtZG.png" alt=""><ul><li>在js檔案中輸入<br><img src="https://i.imgur.com/87emqhz.png" alt=""></li><li>運行 <code>node index.js</code><br><img src="https://i.imgur.com/F9f6Qzj.png" alt=""></li></ul></li></ul><p><a href="https://blog.hiskio.com/what-is-node-js/" target="_blank" rel="noopener">什麼是 Node.js？Node.js 完整介紹懶人包！</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;  之前在安裝套件時，就有先安裝過 Node.js 但從沒有特別去注意，它是應用在哪一塊、可以做什麼？就找了之前 udemy 全端課程，特意</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Vue.js 3 -  多筆資料渲染 v-for</title>
    <link href="https://github.com/Eva813/Eva813.github.io.git/2021/05/17/Vue-v-for/"/>
    <id>https://github.com/Eva813/Eva813.github.io.git/2021/05/17/Vue-v-for/</id>
    <published>2021-05-17T08:20:22.000Z</published>
    <updated>2021-10-05T08:38:36.440Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/NBBY8vo.png" alt=""></p><h2 id="v-for-呈現多筆陣列"><a href="#v-for-呈現多筆陣列" class="headerlink" title="v-for 呈現多筆陣列"></a><code>v-for</code> 呈現多筆陣列</h2><ul><li><code>v-for= item in peopleArr</code> ， item 為 自定義名稱，後面(peopleArr)填入要迴圈的資料<ul><li>item是表示 peopleArr 陣列中每個單一物件</li></ul></li><li>key ：為帶入陣列的 key 值</li></ul><pre><code class="html">  &lt;div id=&quot;app&quot;&gt;   &lt;h3&gt;v-for 與 key&lt;/h3&gt;  &lt;p&gt; 人員介紹&lt;/p&gt;  &lt;ul&gt;    &lt;li v-for=&quot;(item, key) in peopleArr&quot;&gt;      {{ key }} - {{ item.name}} / {{ item.age }} 歲    &lt;/li&gt;  &lt;/ul&gt;  &lt;/div&gt;</code></pre><pre><code class="javascript">Vue.createApp({  data(){     return {     peopleArr: [        {          name: &#39;Ken&#39;,          age: 30,          vegan: false        },        {          name: &#39;Wong&#39;,          page: 35,          vegan: false        },        {          name: &#39;Merry&#39;,          age: 60,          vegan: false        },        {          name: &#39;Tom&#39;,          age: 30,          vegan: true        },      ],    }  },}).mount(&#39;#app&#39;)</code></pre><p><a href="https://codepen.io/Eva-go/pen/powVYmN" target="_blank" rel="noopener">codepen</a><br><img src="https://i.imgur.com/TebHrmC.png" alt=""></p><h2 id="物件迴圈"><a href="#物件迴圈" class="headerlink" title="物件迴圈"></a>物件迴圈</h2><ul><li>每個item 就是每個物件的資料</li><li>key值為物件的屬性名稱</li></ul><pre><code class="html">  &lt;div id=&quot;app&quot;&gt;   &lt;h3&gt;v-for 與 key&lt;/h3&gt;  &lt;p&gt; 人員介紹&lt;/p&gt;  &lt;ul&gt;    &lt;li v-for=&quot;(item, key) in peopleObj&quot;&gt;      {{ key }} - {{ item.name}} / {{ item.age }} 歲    &lt;/li&gt;  &lt;/ul&gt;  &lt;/div&gt;</code></pre><pre><code class="javascript">Vue.createApp({  data(){     return {     peopleObj:{        Salse: {           name: &#39;Ken&#39;,          age: 30,          vegan: false        },        Manager: {          name: &#39;Wong&#39;,          page: 35,          vegan: false        },        HumanResource: {          name: &#39;Merry&#39;,          age: 60,          vegan: false        },        Crew: {           name: &#39;Tom&#39;,          age: 30,          vegan: true        }      },    }  },}).mount(&#39;#app&#39;)</code></pre><p><img src="https://i.imgur.com/tzjh6Ah.png" alt=""></p><h2 id="v-for-與-key"><a href="#v-for-與-key" class="headerlink" title="v-for 與 key"></a>v-for 與 key</h2><h3 id="v-for-可以使用-index-當作-key-嗎？"><a href="#v-for-可以使用-index-當作-key-嗎？" class="headerlink" title="v-for 可以使用 index 當作 key 嗎？"></a>v-for 可以使用 index 當作 key 嗎？</h3><p>以六角課程為範例說明</p><pre><code class="html">&lt;h3&gt;v-for 與 key &lt;/h3&gt;  &lt;p&gt;菜單&lt;/p&gt;  &lt;ul&gt;    &lt;li v-for=&quot;(item, key) in products&quot;&gt;      {{ key }} - {{ item.name}} / {{ item.price }} 元      &lt;input type=&quot;text&quot;&gt;    &lt;/li&gt;  &lt;/ul&gt;</code></pre><pre><code class="javascript">Vue.createApp({  data(){    return {     products: [        {          name: &#39;蛋餅&#39;,          price: 30,          vegan: false        },        {          name: &#39;飯糰&#39;,          price: 35,          vegan: false        },        {          name: &#39;小籠包&#39;,          price: 60,          vegan: false        },        {          name: &#39;蘿蔔糕&#39;,          price: 30,          vegan: true        },      ],    },  method:{    reverseArray: function () {      this.products.reverse();    },  }  }}).mount(&#39;#app&#39;)</code></pre><p><img src="https://i.imgur.com/GKjdBGd.png" alt=""></p><ul><li><p>反轉之後，並沒有跟著<br><img src="https://i.imgur.com/ALe8vst.png" alt=""></p></li><li><p>綁定key之後</p><pre><code class="html">&lt;li v-for=&quot;(item, key) in products&quot; v-bind:key=&#39;item.name&#39;&gt;</code></pre></li></ul><p><img src="https://i.imgur.com/kbtUwy1.png" alt=""></p><h3 id="v-for-可以使用-index-當作-key-嗎？-1"><a href="#v-for-可以使用-index-當作-key-嗎？-1" class="headerlink" title="v-for 可以使用 index 當作 key 嗎？"></a><code>v-for</code> 可以使用 index 當作 key 嗎？</h3><p>索引是依照位置來判定，所以當資料的位置修改，索引值也會跟著變動，導致後續的渲染錯誤。<br>如果key是會變動的話，可能會導致資料的渲染錯誤</p><h3 id="如果後端提供的資料，沒有唯一索引要如何處理？"><a href="#如果後端提供的資料，沒有唯一索引要如何處理？" class="headerlink" title="如果後端提供的資料，沒有唯一索引要如何處理？"></a>如果後端提供的資料，沒有唯一索引要如何處理？</h3><p>  1.與後端溝通，為何前端要用到key的值<br>  2.拿到資料後，自己產生key，並放入該物件資料中</p><pre><code>使用v-for時，一定要用key 使用v-for時，不要拿索引當作key請使用唯一的值當作key的值</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/NBBY8vo.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;v-for-呈現多筆陣列&quot;&gt;&lt;a href=&quot;#v-for-呈現多筆陣列&quot; class=&quot;headerlink&quot; title=&quot;v-for 呈現多筆</summary>
      
    
    
    
    
    <category term="Vue" scheme="https://github.com/Eva813/Eva813.github.io.git/tags/Vue/"/>
    
    <category term="v-for" scheme="https://github.com/Eva813/Eva813.github.io.git/tags/v-for/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js 3 -  資料雙向綁定 v-model</title>
    <link href="https://github.com/Eva813/Eva813.github.io.git/2021/05/17/Vue-v-model/"/>
    <id>https://github.com/Eva813/Eva813.github.io.git/2021/05/17/Vue-v-model/</id>
    <published>2021-05-17T08:16:22.000Z</published>
    <updated>2021-10-05T08:38:31.980Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/NBBY8vo.png" alt=""></p><p>使用<code>v-model</code>來進行資料的「雙向」綁定， v-model 會根據不同的表單類別來更新元素的內容。<br>主要應用在表單類型進行綁定，常見的表單元素像是 <code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code> 以及 <code>&lt;select&gt;</code> 等。</p><h2 id="v-model-可以與-input-、textarea-綁定"><a href="#v-model-可以與-input-、textarea-綁定" class="headerlink" title="v-model 可以與 input 、textarea 綁定"></a>v-model 可以與 input 、textarea 綁定</h2><pre><code class="html">  &lt;h3&gt;input&lt;/h3&gt;     &lt;input type=&quot;text&quot; class=&quot;form-control&quot; v-model=&quot;name&quot;&gt;          {{ name }}</code></pre><pre><code class="javascript">Vue.createApp({  data(){     return {      name: &quot;小明&quot;    }  },}).mount(&#39;#app&#39;)</code></pre><p><img src="https://i.imgur.com/fuPfWXo.png" alt=""></p><p><img src="https://i.imgur.com/Vyon4w6.png" alt=""></p><pre><code class="html">&lt;h3&gt;textarea&lt;/h3&gt;          &lt;textarea cols=&quot;30&quot; rows=&quot;3&quot; class=&quot;form-control&quot; v-model=&quot;text&quot;&gt;&lt;/textarea&gt;          {{ text }}</code></pre><pre><code class="javascript">Vue.createApp({  data(){     return {      text: &quot;一段文字敘述&quot;    }  },}).mount(&#39;#app&#39;)</code></pre><p><img src="https://i.imgur.com/T7AMqwY.png" alt=""></p><p><img src="https://i.imgur.com/fxYLTcU.png" alt=""></p><h2 id="checkbox-單選框"><a href="#checkbox-單選框" class="headerlink" title="checkbox 單選框"></a>checkbox 單選框</h2><ol><li>checkbox與p段落連動</li></ol><ul><li>在input加入<code>v-model=&quot;checkAnswer&quot;</code></li><li>P段洛，放入三元運算：用來判斷當checkAnswer為true，顯示’吃飽了’;反之，’還沒’<ul><li>透過選單的勾選，來顯示 checkAnswer 是 true \ false</li></ul></li></ul><pre><code class="html">     &lt;h3&gt;checkbox 單選框&lt;/h3&gt;     &lt;p&gt;小明，你是吃飽沒？&lt;/p&gt;     &lt;p&gt;{{ checkAnswer ? '吃飽了' : '還沒'}}&lt;/p&gt;     &lt;div class=&quot;form-check&quot;&gt;     &lt;input type=&quot;checkbox&quot; class=&quot;form-check-input&quot; id=&quot;check1&quot; v-model=&quot;checkAnswer&quot;&gt;    &lt;label class=&quot;form-check-label&quot; for=&quot;check1&quot;&gt;小明回覆&lt;/label&gt;          &lt;/div&gt;</code></pre><pre><code class="javascript">Vue.createApp({  data(){     return {      checkAnswer: false,    }  },}).mount(&#39;#app&#39;)</code></pre><p><img src="https://i.imgur.com/wBR8ESD.png" alt=""></p><p><img src="https://i.imgur.com/cRDgctR.gif" alt=""></p><ol start="2"><li>checkbox 單選延伸</li></ol><ul><li>回傳單一的值，相對使用三元運算比較直觀</li><li><code>checkAnswer2</code> 是空字串，在 input 綁定後，設定false-value、true-value</li><li>將文字綁入：<code>true-value=&quot;吃飽了&quot; false-value=&quot;還沒&quot;</code>，就可以放入資料欄位上</li></ul><pre><code class="html"> &lt;h3&gt;checkbox 單選延伸&lt;/h3&gt;     &lt;p&gt;小明，你是吃飽沒？&lt;/p&gt;     &lt;p&gt;{{ checkAnswer2 }}&lt;/p&gt;     &lt;div class=&quot;form-check&quot;&gt;     &lt;input type=&quot;checkbox&quot; v-model=&quot;checkAnswer2&quot; true-value=&quot;吃飽了&quot; false-value=&quot;還沒&quot; class=&quot;form-check-input&quot;              id=&quot;check2&quot;&gt;     &lt;label class=&quot;form-check-label&quot; for=&quot;check2&quot;&gt;小明回覆&lt;/label&gt;     &lt;/div&gt;</code></pre><pre><code class="javascript">Vue.createApp({  data(){     return {      checkAnswer2: &#39;&#39;,    }  },}).mount(&#39;#app&#39;)</code></pre><p><img src="https://i.imgur.com/x4aeut8.png" alt=""></p><p><img src="https://i.imgur.com/qvyj7dH.png" alt=""></p><h2 id="checkbox-複選框"><a href="#checkbox-複選框" class="headerlink" title="checkbox 複選框"></a>checkbox 複選框</h2><ul><li><p>資料格式為陣列</p></li><li><p>覆選框的input裡面要有value</p></li><li><p>當綁定v-model，於畫面點選該項目時，會將 input 中的 value，放入的陣列中</p><ul><li>最後將資料渲染於畫面<pre><code class="html">&lt;h3&gt;checkbox 複選框&lt;/h3&gt;&lt;p&gt;你還要吃什麼？&lt;/p&gt;&lt;p&gt;{{ checkAnswer3.join('') }}&lt;/p&gt;&lt;div class=&quot;form-check&quot;&gt;   &lt;input type=&quot;checkbox&quot; class=&quot;form-check-input&quot; id=&quot;check3&quot; value=&quot;蛋餅&quot; v-model=&quot;checkAnswer3&quot;&gt;   &lt;label class=&quot;form-check-label&quot; for=&quot;check3&quot;&gt;蛋餅&lt;/label&gt;         &lt;/div&gt;&lt;div class=&quot;form-check&quot;&gt;    &lt;input type=&quot;checkbox&quot; class=&quot;form-check-input&quot; id=&quot;check4&quot; value=&quot;蘿蔔糕&quot; v-model=&quot;checkAnswer3&quot;&gt;    &lt;label class=&quot;form-check-label&quot; for=&quot;check4&quot;&gt;蘿蔔糕&lt;/label&gt;&lt;/div&gt;&lt;div class=&quot;form-check&quot;&gt;  &lt;input type=&quot;checkbox&quot; class=&quot;form-check-input&quot; id=&quot;check5&quot; value=&quot;豆漿&quot; v-model=&quot;checkAnswer3&quot;&gt;  &lt;label class=&quot;form-check-label&quot; for=&quot;check5&quot;&gt;豆漿&lt;/label&gt; &lt;/div&gt;</code></pre><pre><code class="javascript">Vue.createApp({</code></pre></li></ul><p>data(){<br>   return {</p><pre><code>checkAnswer3: [],</code></pre><p>  }<br>},</p></li></ul><p>}).mount(‘#app’)</p><pre><code>![](https://i.imgur.com/V6RUoEF.png)## v-model 修飾符修飾符為畫面上，v-model的資料和實際data中的資料在綁定之間，額外處理的小方法。1. 延遲 Lazy* 輸入文字後，要點擊外面或是按下enter，才會出現* 綁定到html的change事件：當完成輸入框的事件之後，才會綁定到資料集```html   &lt;h3&gt;修飾符&lt;/h3&gt;   &lt;h4 class=&quot;mt-3&quot;&gt;延遲 Lazy&lt;/h4&gt;     {{ lazyMsg }}   &lt;input type=&quot;text&quot; class=&quot;form-control&quot; v-model.lazy=&quot;lazyMsg&quot;&gt;</code></pre><p><img src="https://i.imgur.com/1Jp0XWl.png" alt=""></p><h2 id="純數值-Number"><a href="#純數值-Number" class="headerlink" title="純數值 Number"></a>純數值 Number</h2><p>需要用戶輸入數值，可先將type改為number,並加入修飾符</p><ul><li><code>&lt;input type=&quot;number&quot;&gt;</code>:輸入框無法輸入文字，只能輸入數字，但型別依然是string</li></ul><pre><code class="html">   &lt;h4 class=&quot;mt-3&quot;&gt;純數值 Number&lt;/h4&gt;     {{ numberMsg }}{{ typeof numberMsg }}   &lt;input type=&quot;number&quot; class=&quot;form-control&quot; v-model=&quot;numberMsg&quot;&gt;</code></pre><p><img src="https://i.imgur.com/48WNFq2.png" alt=""></p><ul><li>要確保輸入的內容為純數字型別：要加修飾符</li></ul><pre><code class="html">   &lt;h4 class=&quot;mt-3&quot;&gt;純數值 Number&lt;/h4&gt;       {{ numberMsg }}{{ typeof numberMsg }}   &lt;input type=&quot;number&quot; class=&quot;form-control&quot; v-model.number=&quot;numberMsg&quot;&gt;</code></pre><p><img src="https://i.imgur.com/ANESock.png" alt=""></p><h2 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h2><p>將資料內容的前後空白鍵，刪除</p><ul><li>應用於要輸入e-mail帳號，避免用戶不小心在前後加入空白，而造成資料錯誤<pre><code class="html"> &lt;h4 class=&quot;mt-3&quot;&gt;修剪 Trim&lt;/h4&gt;        這是一段{{ trimMsg }}緊黏的文字 &lt;input type=&quot;text&quot; class=&quot;form-control&quot; v-model.trim=&quot;trimMsg&quot;&gt;</code></pre><img src="https://i.imgur.com/SCJddsn.png" alt=""></li></ul><p>參考資料：<br><a href="https://book.vue.tw/CH1/1-4-directive.html" target="_blank" rel="noopener">重新認識 Vue.js | Kuro Hsu</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/NBBY8vo.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;v-model&lt;/code&gt;來進行資料的「雙向」綁定， v-model 會根據不同的表單類別來更新元素的內容。&lt;br&gt;主要應用在表單類型進行綁</summary>
      
    
    
    
    
    <category term="Vue" scheme="https://github.com/Eva813/Eva813.github.io.git/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js 3 - 綁定方式多變化</title>
    <link href="https://github.com/Eva813/Eva813.github.io.git/2021/05/16/Vue-bind2/"/>
    <id>https://github.com/Eva813/Eva813.github.io.git/2021/05/16/Vue-bind2/</id>
    <published>2021-05-16T08:17:30.000Z</published>
    <updated>2021-10-05T08:38:07.644Z</updated>
    
    <content type="html"><![CDATA[<h2 id="動態屬性綁定-注意大小寫"><a href="#動態屬性綁定-注意大小寫" class="headerlink" title="動態屬性綁定(注意大小寫)"></a>動態屬性綁定(注意大小寫)</h2><ul><li>宣告變數dynamic，將 dynamic 綁定於點擊事件上 <code>:click=&quot;dynamic = dynamic === &#39;disabled&#39; ? &#39;readonly&#39;:&#39;disabled&#39;&quot;</code><ul><li>如果變數結果是 disable 的話就會切換成 readonly，反之，就會切換為 disabled</li></ul></li><li>接著可以將值動態地加入 HTML 屬性上 <code>:[dynamic]</code><ul><li>綁定後，就會發現輸入框隨著切換，有不同效果<pre><code class="html">&lt;h3&gt;動態屬性綁定(注意大小寫)&lt;/h3&gt;&lt;button type=&quot;button&quot;v-on:click=&quot;dynamic = dynamic === &#39;disabled&#39; ? &#39;readonly&#39;:&#39;disabled&#39;&quot;&gt;切換為 {{ dynamic }}&lt;/button&gt;&lt;br&gt;&lt;input type=&quot;text&quot; :[dynamic] :value=&quot;name&quot;&gt;</code></pre><pre><code class="javascript">//JS</code></pre></li></ul></li></ul><p>Vue.createApp({</p><p>  data(){<br>     return {<br>      dynamic: ‘disabled’,<br>      breakfastShop: {<br>      name: ‘奇蹟早餐’,<br>        imgUrl: ‘<a href="https://images.unsplash.com/photo-1600182610361-4b4d664e07b9?ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&amp;ixlib=rb-1.2.1&amp;auto=format&amp;fit=crop&amp;w=200&amp;q=80&#39;" target="_blank" rel="noopener">https://images.unsplash.com/photo-1600182610361-4b4d664e07b9?ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&amp;ixlib=rb-1.2.1&amp;auto=format&amp;fit=crop&amp;w=200&amp;q=80&#39;</a>,<br>        resizeImg: ‘<a href="https://images.unsplash.com/photo-1600182610361-4b4d664e07b9?ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&amp;ixlib=rb-1.2.1&amp;auto=format&amp;fit=crop&amp;q=80&#39;" target="_blank" rel="noopener">https://images.unsplash.com/photo-1600182610361-4b4d664e07b9?ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&amp;ixlib=rb-1.2.1&amp;auto=format&amp;fit=crop&amp;q=80&#39;</a><br>      },<br>    }<br>  }<br>}).mount(‘#app’)</p><pre><code>`readony`:可以選擇輸入框，但無法輸入值`disabled`:無法點選輸入框![](https://i.imgur.com/GfAhQJk.png)![](https://i.imgur.com/YUf3XZk.png)</code></pre><p>再次補充說明：<br>    1. dynamic = 【這邊是最前面的變數，用來存放後面回傳回來的值】<br>    2. dynamic === ‘disabled’ ? 【這邊就是中間判斷式的部分，判斷 dynamic 變數是否為 ‘disabled’】<br>    3. ‘readonly’:’disabled’ 【這邊就是最後面的值，會依照前方的判斷式來決定回傳 ‘readonly’ 還是 ‘disabled’，如果判斷式結果為 True 則回傳 ‘readonly’ ，反之回傳 ‘disabled’】</p><pre><code>## HTML 樣式綁定樣式綁定是時常使用到的效果，能透過此方式，使顏色改變、增加一點簡易動畫的效果。## 範例解說* 替 box 增加旋轉效果* 綁定class可以用陣列方式、或物件方式來添加，以下範例為物件方式  * 物件key值對應 className，物件的值是對應 true\false(判斷式)  * 若className 有 `-` ， 注意要 &quot;bg-danger&quot;* 事件的綁定 `change()` 透過函式來切換 true\false` this[key] = !this[key];`* 切換是否旋轉、切換背景色 ```html&lt;style&gt;.box {  background-color: var(--bs-light);  border: 1px solid var(--bs-gray);  width: 80px;  height: 80px;}.box {  transition: all .5s;}.box.rotate {  transform: rotate(45deg)}&lt;/style&gt; &lt;h2&gt;切換 Class&lt;/h2&gt;          &lt;h3&gt;物件寫法&lt;/h3&gt;          &lt;!-- 物件key值對應 className，物件的值是對應 true\false --&gt;          &lt;div class=&quot;box&quot; :class=&quot;{ rotate: isTransform ,&#39;bg-danger&#39;:boxColor}&quot;&gt;&lt;/div&gt;          &lt;hr&gt;          &lt;button class=&quot;btn btn-outline-primary&quot; v-on:click=&quot;change(&#39;isTransform&#39;)&quot;&gt;選轉物件&lt;/button&gt;          &lt;button class=&quot;btn btn-outline-primary ms-1&quot; v-on:click=&quot;change(&#39;boxColor&#39;)&quot;&gt;切換色彩&lt;/button&gt;</code></pre><pre><code class="javascript">const App = {  data() {    return {      isTransform: true,      boxColor: false,    };  },  methods: {    change: function (key) {      this[key] = !this[key];    },    addClass(arr) {      this.arrayClass.push(...arr);    }  },};Vue.createApp(App).mount(&#39;#app&#39;);</code></pre><p><img src="https://i.imgur.com/KFqN9hz.png" alt=""></p><p><img src="https://i.imgur.com/b9OCub3.gif" alt=""></p><h3 id="整合為一個物件"><a href="#整合為一個物件" class="headerlink" title="整合為一個物件"></a>整合為一個物件</h3><p>將上個範例的兩個class樣式，整合成一個物件</p><pre><code class="html"> &lt;hr class=&quot;mt-4&quot;&gt;   &lt;h3&gt;物件寫法 2&lt;/h5&gt;         &lt;div class=&quot;box&quot; :class=&#39;classObj&#39;&gt;&lt;/div&gt;</code></pre><pre><code class="javascript">const App = {  data() {    return {      isTransform: true,      boxColor: false,      classObj:{        rotata: true,        &quot;bg-danger&quot;: true,      }    };  },  methods: {    change: function (key) {      this[key] = !this[key];    },    addClass(arr) {      this.arrayClass.push(...arr);    }  },};Vue.createApp(App).mount(&#39;#app&#39;);</code></pre><p><img src="https://i.imgur.com/41AKFc8.png" alt=""></p><p><img src="https://i.imgur.com/StALtsi.png" alt=""></p><h2 id="綁定樣式，陣列寫法"><a href="#綁定樣式，陣列寫法" class="headerlink" title="綁定樣式，陣列寫法"></a>綁定樣式，陣列寫法</h2><ul><li>針對單一元素，加入多個class<ul><li>此方式就不用 true\false 的判斷動作，只要綁定在陣列之中的樣式，就會套入效果</li><li>像是範例，就是使按鈕背景色彩為紅色(‘btn-danger’)、無法點擊(‘disabled’)<pre><code class="html">&lt;h4&gt;陣列寫法&lt;/h4&gt;        &lt;button class=&quot;btn&quot; :class=&quot;[&#39;disabled&#39;,&#39;btn-danger&#39;]&quot;&gt;請操作本元件&lt;/button&gt;        &lt;button type=&quot;button&quot; class=&quot;btn btn-outline-primary&quot; v-on:click=&quot;addClass([&#39;btn-primary&#39;, &#39;active&#39;])&quot;&gt;為陣列加入          Class&lt;/button&gt;</code></pre><img src="https://i.imgur.com/RZFOrdK.png" alt=""></li></ul></li></ul><ul><li>另一種，製作陣列，並將陣列放入<ul><li>將arrayClass，綁定在標籤的class上</li><li>在點擊按鈕，綁定點擊事件，<code>addClass(arr)</code>，在該函式傳入參數，將陣列內容加入arrayClass，並套入綁定的標籤上</li><li>相對應的方法：<br><img src="https://i.imgur.com/VFfDXPY.png" alt=""></li></ul></li></ul><pre><code class="html">&lt;h4&gt;陣列寫法&lt;/h4&gt;  &lt;button class=&quot;btn&quot; :class=&quot;arrayClass&quot;  &gt;請操作本元件&lt;/button&gt;  &lt;button type=&quot;button&quot;    class=&quot;btn btn-outline-primary&quot;    v-on:click=&quot;addClass([&#39;btn-primary&#39;, &#39;active&#39;])&quot;&gt;為陣列加入 Class&lt;/button&gt;</code></pre><pre><code class="javascript">const App = {  data() {    return {       // Array 操作      arrayClass: [&#39;&#39;],    };  },  methods: {    addClass(arr) {      this.arrayClass.push(...arr);    }  },};Vue.createApp(App).mount(&#39;#app&#39;);</code></pre><p><img src="https://i.imgur.com/PZd0sKO.png" alt=""></p><ul><li><code>btn-primary</code>:背景色為綠色<br><img src="https://i.imgur.com/S0zLJKb.png" alt=""></li></ul><h4 id="補充：混合寫法"><a href="#補充：混合寫法" class="headerlink" title="補充：混合寫法"></a>補充：混合寫法</h4><ul><li>將bootstrap的class放入，且加入arrayClass<ul><li><code>:class=&quot;[arrayClass,&#39;text-danger&#39;]</code>，也就是除了放入 arrayClass 這個變數之外，我們還可以放入新的class給予不同樣式<pre><code class="html">&lt;h4&gt;陣列寫法&lt;/h4&gt;&lt;button class=&quot;btn&quot; :class=&quot;[arrayClass,&#39;text-danger&#39;]&quot;&gt;請操作本元件&lt;/button&gt;  &lt;button type=&quot;button&quot; class=&quot;btn btn-outline-primary&quot; v-on:click=&quot;addClass([&#39;btn-primary&#39;, &#39;active&#39;])&quot;&gt;為陣列加入          Class&lt;/button&gt;</code></pre></li></ul></li></ul><p><img src="https://i.imgur.com/d3dqSTj.png" alt=""></p><h2 id="行內樣式style"><a href="#行內樣式style" class="headerlink" title="行內樣式style"></a>行內樣式style</h2><h4 id="要綁定style的時候"><a href="#要綁定style的時候" class="headerlink" title="要綁定style的時候"></a>要綁定style的時候</h4><ul><li>key會帶入style的屬性(注意要以駝峰式)，如background-color，要改為backgroundColor</li><li>值則是帶入style相對應的值</li></ul><pre><code class="html">&lt;h2&gt;行內樣式&lt;/h2&gt;            &lt;h4&gt;綁定行內樣式&lt;/h4&gt;            &lt;div class=&quot;box&quot; :style=&quot;{backgroundColor:&#39;red&#39;}&quot;&gt;&lt;/div&gt;            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</code></pre><h3 id="加入準備好的資料格式"><a href="#加入準備好的資料格式" class="headerlink" title="加入準備好的資料格式"></a>加入準備好的資料格式</h3><ul><li><p>將設定好的物件，裡面有包含數個樣式，直接綁定至style<br><img src="https://i.imgur.com/z93Jmam.png" alt=""></p></li><li><p>背景色彩，紅色，邊框5px<br><img src="https://i.imgur.com/lWYdxIi.png" alt=""></p></li></ul><h3 id="同時多個樣式"><a href="#同時多個樣式" class="headerlink" title="同時多個樣式"></a>同時多個樣式</h3><ul><li>以陣列裡面包多個物件<pre><code class="html">&lt;div class=&quot;box&quot; :style=&quot;[styleObject,styleObject2]&quot;&gt;&lt;/div&gt;</code></pre><img src="https://i.imgur.com/11h8F7J.png" alt=""></li></ul><p><img src="https://i.imgur.com/62sDl0J.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;動態屬性綁定-注意大小寫&quot;&gt;&lt;a href=&quot;#動態屬性綁定-注意大小寫&quot; class=&quot;headerlink&quot; title=&quot;動態屬性綁定(注意大小寫)&quot;&gt;&lt;/a&gt;動態屬性綁定(注意大小寫)&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;宣告變數dynamic，將 dynamic </summary>
      
    
    
    
    
    <category term="Vue" scheme="https://github.com/Eva813/Eva813.github.io.git/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js 3 - 事件綁定</title>
    <link href="https://github.com/Eva813/Eva813.github.io.git/2021/05/16/Vue-v-on/"/>
    <id>https://github.com/Eva813/Eva813.github.io.git/2021/05/16/Vue-v-on/</id>
    <published>2021-05-16T08:16:30.000Z</published>
    <updated>2021-10-05T08:38:53.199Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/NBBY8vo.png" alt=""></p><ul><li>建立add、minus兩個按鈕<ul><li>點選add增加數字、點選minus減少數字</li></ul></li><li>讓add按鈕綁定<code>addFn</code>函式：<code>v-on:click=&quot;addFn&quot;</code> <code>on</code> <code>click</code>事件，執行<code>addFn</code>函式</li><li>綁定後，在<code>methods</code>撰寫<code>addFn</code>函式內容，要取得 data 中的 num 才能進行運算 =&gt;<code>this.num++</code></li><li>同理，在minus的按鈕，函式內運算<code>this.num++</code>，並將點擊事件放入<code>button</code><ul><li>v-on:Event 事件綁定，有兩種撰寫方式<br><img src="https://i.imgur.com/IUUcznh.png" alt=""></li></ul></li></ul><pre><code class="html"> &lt;div id=&quot;app&quot;&gt;   &lt;h1&gt;{{num}}&lt;/h1&gt;    &lt;button v-on:click=&quot;addFn&quot;&gt;Add&lt;/button&gt;    &lt;!-- v-on 改為@ --&gt;    &lt;button @click=&quot;MinusFun&quot;&gt;Minus&lt;/button&gt;  &lt;/div&gt;</code></pre><pre><code class="javascript">Vue.createApp({  data(){     return {       num: 0    }  },  methods: {    addFn() {       //num.value = num.value + 1;          this.num ++;    },     MinusFun(){        this.num--;     },  }}).mount(&#39;#app&#39;)</code></pre><p><a href="https://codepen.io/Eva-go/pen/bGRLXNW" target="_blank" rel="noopener">codepen</a></p><h2 id="事件與class的綁定"><a href="#事件與class的綁定" class="headerlink" title="事件與class的綁定"></a>事件與class的綁定</h2><ul><li><p>於 box 綁定旋轉的效果 <code>:class=&quot;{ rotate: isTransform }</code></p></li><li><p>在button綁定觸發旋轉的事件</p><pre><code class="html">&lt;style&gt;.box { margin:0 auto;background-color: #fff;border: 1px solid #ccc;width: 80px;height: 80px;}.box {transition: all .5s;}.box.rotate {transform: rotate(45deg)}&lt;/style&gt;&lt;div id=&quot;app&quot;&gt; &lt;h3&gt;觸發事件 與 縮寫*&lt;/h3&gt;&lt;div class=&quot;box&quot; :class=&quot;{ rotate: isTransform }&quot;&gt;&lt;/div&gt;&lt;hr&gt;&lt;button class=&quot;btn btn-outline-primary&quot; @click=&quot;changeClass&quot; &gt;選轉物件&lt;/button&gt;&lt;/div&gt;</code></pre><pre><code class="javascript">Vue.createApp({data() {  return {     isTransform: true,  };},methods: {   changeClass() {    this.isTransform =!this.isTransform;  },}};</code></pre></li></ul><p>}).mount(‘#app’)</p><pre><code>## 帶入參數* 建立 `change()` 函式以帶入參數方式，來變化 isTransform 的 true\false```html&lt;h3&gt;帶入參數*&lt;/h3&gt;  &lt;div class=&quot;box&quot; :class=&quot;{ rotate: isTransform }&quot;&gt;&lt;/div&gt;  &lt;button class=&quot;btn btn-outline-primary&quot; @click=&quot;change(&#39;isTransform&#39;)&quot;&gt;選轉物件&lt;/button&gt;</code></pre><pre><code class="javascript">Vue.createApp({ data() {    return {       isTransform: true,    };  },  methods: {     changeClass() {      this.isTransform =!this.isTransform;    },    change(key) {      this[key] = !this[key];    },  }};}).mount(&#39;#app&#39;)</code></pre><h2 id="動態物件方法"><a href="#動態物件方法" class="headerlink" title="動態物件方法 {}"></a>動態物件方法 {}</h2><ul><li><p>在一個元素上，加入多個事件</p></li><li><p>注意：此方式無法傳入參數</p><pre><code class="html">&lt;h3&gt;動態物件方法 {}&lt;/h3&gt;        &lt;!-- 此方法無法傳入參數 --&gt;&lt;button class=&quot;box&quot; @=&quot;{    mousedown:down,    mouseup:up }&quot;&gt;&lt;/button&gt;</code></pre><pre><code class="javascript">Vue.createApp({data() {  return {     isTransform: true,  };},methods: {   changeClass() {    this.isTransform =!this.isTransform;  },  change(key) {    this[key] = !this[key];  },  down() {    console.log(&quot;按下&quot;);  },  up() {    console.log(&quot;放開&quot;);  }}};</code></pre></li></ul><p>}).mount(‘#app’)</p><pre><code>![](https://i.imgur.com/qO3AcxL.gif)[codepen](https://codepen.io/Eva-go/pen/abwYwPa)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/NBBY8vo.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;建立add、minus兩個按鈕&lt;ul&gt;
&lt;li&gt;點選add增加數字、點選minus減少數字&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;讓add按鈕</summary>
      
    
    
    
    
    <category term="Vue" scheme="https://github.com/Eva813/Eva813.github.io.git/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js 3 - 屬性綁定</title>
    <link href="https://github.com/Eva813/Eva813.github.io.git/2021/05/16/Vue-bind/"/>
    <id>https://github.com/Eva813/Eva813.github.io.git/2021/05/16/Vue-bind/</id>
    <published>2021-05-16T06:56:28.000Z</published>
    <updated>2021-10-05T08:38:00.097Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/NBBY8vo.png" alt=""></p><p>  屬性綁定可以輕鬆的將data中的資料，與HTML的標籤屬性綁定，這樣一來可以動態的變更資料。</p><h2 id="原本-HTML-的樣子"><a href="#原本-HTML-的樣子" class="headerlink" title="原本 HTML 的樣子"></a>原本 HTML 的樣子</h2><ul><li>img中原本有個圖片資料</li><li>v-bind是指令，<code>：</code>後接的是HTML的屬性</li></ul><pre><code class="html">  &lt;h3&gt;綁定屬性 v-bind&lt;/h3&gt;  &lt;p&gt;{{ breakfastShop.name }}&lt;/p&gt;  &lt;img src=&quot;https://images.unsplash.com/photo-1600182610361-4b4d664e07b9?ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&amp;ixlib=rb-1.2.1&amp;auto=format&amp;fit=crop&amp;w=200&amp;q=80&quot; class=&quot;square-img&quot; alt=&quot;&quot;&gt;</code></pre><pre><code class="javascript">//JSVue.createApp({  data(){     return {      breakfastShop: {        name: &#39;奇蹟早餐&#39;,        imgUrl: &#39;https://images.unsplash.com/photo-1600182610361-4b4d664e07b9?ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&amp;ixlib=rb-1.2.1&amp;auto=format&amp;fit=crop&amp;w=200&amp;q=80&#39;,        resizeImg: &#39;https://images.unsplash.com/photo-1600182610361-4b4d664e07b9?ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&amp;ixlib=rb-1.2.1&amp;auto=format&amp;fit=crop&amp;q=80&#39;      },    }  }}).mount(&#39;#app&#39;)</code></pre><h3 id="修改-gt-綁定JS中-breakfastShop-物件資料內容"><a href="#修改-gt-綁定JS中-breakfastShop-物件資料內容" class="headerlink" title="修改 =&gt; 綁定JS中 breakfastShop 物件資料內容"></a>修改 =&gt; 綁定JS中 breakfastShop 物件資料內容</h3><p><img src="https://i.imgur.com/H3UzhrB.png" alt=""></p><ul><li>將原本<code>src</code> =&gt; <code>v-bind:src=&quot;breakfastShop.imgUrl&quot;</code><ul><li>此外title 屬性，也能照樣綁定喔！  <pre><code class="html">&lt;h3&gt;綁定屬性 v-bind&lt;/h3&gt;      &lt;p&gt;{{ breakfastShop.name }}&lt;/p&gt;      &lt;img v-bind:src=&quot;breakfastShop.imgUrl&quot; class=&quot;square-img&quot; v-bind:title=&quot;breakfastShop.name&quot; alt=&quot;&quot;&gt;</code></pre><img src="https://i.imgur.com/Xhtez9s.png" alt=""></li></ul></li></ul><h3 id="縮寫形式"><a href="#縮寫形式" class="headerlink" title="縮寫形式"></a>縮寫形式</h3><ul><li>留下冒號<pre><code class="html">&lt;h3&gt;縮寫形式 &lt;code&gt;:&lt;/code&gt;&lt;/h3&gt;        &lt;img :src=&quot;breakfastShop.imgUrl&quot; class=&quot;square-img&quot; :title=&quot;breakfastShop.name&quot; alt=&quot;&quot;&gt;</code></pre></li></ul><pre><code>## 其他屬性的綁定* 當他是飽的狀態，就無法按下送出    * 預設是false 所以可以送出表單    * 但當點擊狀態切換(isFull: true)，此時就會無法點擊送出按鈕* 由範例可得知，可以透過 true\false 的狀態切換，製造出不同互動效果```html &lt;h3&gt;更多屬性綁定&lt;/h3&gt;          小明還想點餐：          &lt;form action=&quot;&quot;&gt;            &lt;input type=&quot;text&quot; value=&quot;我要吃蘿蔔糕&quot;&gt;            &lt;button type=&quot;submit&quot; :disabled=&quot;isFull&quot;&gt;送出&lt;/button&gt;          &lt;/form&gt;          &lt;button type=&quot;button&quot; v-on:click=&quot;change(&#39;isFull&#39;)&quot;&gt;狀態切換&lt;/button&gt;</code></pre><p><img src="https://i.imgur.com/GVQXr8f.png" alt=""></p><ul><li>預設是false，所以可以點擊送出<br><img src="https://i.imgur.com/4HmkD5f.png" alt=""></li></ul><p><img src="https://i.imgur.com/w91MEBD.png" alt=""></p><p>資料來源：<br>六角學院 - Vue.js 3 課程</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/NBBY8vo.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;  屬性綁定可以輕鬆的將data中的資料，與HTML的標籤屬性綁定，這樣一來可以動態的變更資料。&lt;/p&gt;
&lt;h2 id=&quot;原本-HTML-的樣子&quot;&gt;&lt;a hr</summary>
      
    
    
    
    
    <category term="Vue" scheme="https://github.com/Eva813/Eva813.github.io.git/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js 3 - 起手式</title>
    <link href="https://github.com/Eva813/Eva813.github.io.git/2021/05/16/Vue-basic/"/>
    <id>https://github.com/Eva813/Eva813.github.io.git/2021/05/16/Vue-basic/</id>
    <published>2021-05-16T05:56:28.000Z</published>
    <updated>2021-10-05T08:38:50.375Z</updated>
    
    <content type="html"><![CDATA[<p>今天要介紹的是 Vue.js3 的起手式，主要參考<a href="https://vuejs.org/v2/guide/#Getting-Started" target="_blank" rel="noopener">官方文件</a>來學習</p><h3 id="載入方式"><a href="#載入方式" class="headerlink" title="載入方式"></a>載入方式</h3><pre><code class="javascript">&lt;script src=&quot;https://unpkg.com/vue@next&quot;&gt;&lt;/script&gt;</code></pre><h3 id="引入之後，在index-html檔案"><a href="#引入之後，在index-html檔案" class="headerlink" title="引入之後，在index.html檔案"></a>引入之後，在<code>index.html</code>檔案</h3><pre><code class="html"> &lt;div id=&quot;app&quot;&gt;    &lt;h1&gt;{{message}}&lt;/h1&gt;  &lt;/div&gt;</code></pre><pre><code class="javascript">//JSVue.createApp({  data(){     return {      message: &#39;I am Eva!&#39;    }  }}).mount(&#39;#app&#39;)</code></pre><ul><li>畫面就會出現相應的文字<br><img src="https://i.imgur.com/l7MiTCV.png" alt=""></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天要介紹的是 Vue.js3 的起手式，主要參考&lt;a href=&quot;https://vuejs.org/v2/guide/#Getting-Started&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方文件&lt;/a&gt;來學習&lt;/p&gt;
&lt;h3 id=&quot;載入方</summary>
      
    
    
    
    
    <category term="Vue" scheme="https://github.com/Eva813/Eva813.github.io.git/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>SCSS- ClothesStore</title>
    <link href="https://github.com/Eva813/Eva813.github.io.git/2021/03/05/scss-ClothesStore/"/>
    <id>https://github.com/Eva813/Eva813.github.io.git/2021/03/05/scss-ClothesStore/</id>
    <published>2021-03-05T06:26:19.000Z</published>
    <updated>2021-10-05T08:42:35.152Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/v5qnxzN.png" alt=""></p><p><a href="https://eva813.github.io/Eva_portfolio/sass-ClothesStore/ClothesStore.html" target="_blank" rel="noopener">成品</a></p><h2 id="scss-檔案的建立"><a href="#scss-檔案的建立" class="headerlink" title="scss 檔案的建立"></a>scss 檔案的建立</h2><p>所建立的各分檔，個別會負責不同的區塊，並透過<code>@import</code>放入主要的sass檔</p><ul><li>main.scss 引入其他分檔<br><img src="https://i.imgur.com/PLNNF5k.png" alt=""></li><li>abstracts<ul><li>/_variables.scss：設定常用的變數，如：顏色、字體大小</li><li>/_mixin.scss：設定某些區段中，重複用到的樣式，並於該區段要使用的時候引用</li></ul></li><li>base<ul><li>/_base.scss：為設定大框架，如html、body、container，等主幹的大小、字型的設定</li></ul></li><li>components:放置部分功能元件<ul><li>/_button.scss：按鈕的設定</li><li>/_heading.scss：標題</li><li>/_logo.scss</li><li>/_dropdown.scss</li></ul></li><li>layout （設計網頁版面配置(Layout)）<ul><li>/_header.scss</li><li>/_navigation.scss</li><li>/_products.scss</li><li>/_slidshow.scss</li><li>/_footer.scss</li></ul></li><li>pages 通常是用來放置其他分頁（網頁內會連結到其他相關分頁）</li><li>venders 放置外部套件</li></ul><p><img src="https://i.imgur.com/GmeHZ7w.png" alt=""></p><h3 id="1-基礎設置"><a href="#1-基礎設置" class="headerlink" title="(1)基礎設置"></a>(1)基礎設置</h3><h4 id="1-1-Grid-練習"><a href="#1-1-Grid-練習" class="headerlink" title="(1.1)Grid 練習"></a>(1.1)Grid 練習</h4><p><code>_base.scss</code></p><ul><li>總共要設置10欄</li><li>列的則是設置4區塊</li><li>並設置每個區塊都有1.6rem的gap<pre><code class="scss">.container{  display: grid;  grid-template-columns:minmax(6rem,1fr) repeat(8,minmax(min-content,16 rem))   minmax(6rem,1fr);//10欄  grid-template-rows: repeat(4,min-content);  grid-row-gap:1.6rem ;</code></pre></li></ul><p>}</p><pre><code>![](https://i.imgur.com/QA3NLgt.png)* `minmax(min, max)``minmax(6rem,1fr)`:設定格線最小6rem，最大1frfr 單位就是為了格線布局而生，fraction，中文意思是分數，當使用在網格軌道上時，可以直接想像成 &quot;我的這個空位要佔有總 fr 數量的幾等份&quot;* `repeat(8,minmax(min-content,16rem))`:重複8個，最小：min-content;最大16rem    * repeat() 重複網格線及間距     * max-content/min-content 最小內容尺寸/最大內容尺寸        * max-content：給予網格區域所需的最大尺寸空間，內容盡可能避免折行。        * min-content：給予網格區域所需的最小尺寸空間，內容盡可能的折行，但不會溢出邊界。[[Day19] grid-template 屬性之 rows/columns](https://ithelp.ithome.com.tw/articles/10248418)[Min &amp; Max Content Sizing in CSS Grid — 1/3 Flexibility](https://www.youtube.com/watch?v=lZ2JX_6SGNI)[CSS Layout很難？用這招30秒就讓你輕鬆生出網頁版面！](http://csscoke.com/2013/10/17/css-layout-generator/)---#### (1.2)常用變數* `` _variable.scss``map與function的搭配使用* 設定不同的顏色，並設置函式，以利後續使用```scss$colors:(  primary:#333,  secondary:#ffe,  tertiary:#f2f0f1,  quaternary:#f5b149);//創造函式//函式名稱為color代入參數為$color-name，使用map代入物件，最為回傳的結果@function color($color-name){  @return map-get($map: $colors, $key:$color-name )}$font-size:(  xl:3rem,  lg:2.5rem,  md:2rem,  sm:1.8rem,  xs:1.6rem);@function size($size){  @return map-get($map: $font-size, $key:$size )}</code></pre><hr><h3 id="2-layout-header-scss"><a href="#2-layout-header-scss" class="headerlink" title="(2)layout/_header.scss"></a>(2)<code>layout/_header.scss</code></h3><p>header的版面</p><ul><li><code>grid-column: 1/-1; (1/11) grid-row: 1/2;</code>表示所佔的區隔<br><img src="https://i.imgur.com/C1W2Urq.png" alt=""></li><li>而在header這區，在設置grid劃分區塊<ul><li>有9欄</li><li>列設置3區塊<pre><code class="scss">.header{grid-column: 1/-1; //1/11grid-row: 1/2;display: grid;grid-template-columns: 1fr repeat(7,minmax(min-content,16rem)) 1fr;grid-template-rows: repeat(3,min-content);grid-gap: 2rem;}</code></pre></li></ul></li><li><code>grid-column: 1/-1; //1/11  ; grid-row: 1/2;</code> <a href="https://stackoverflow.com/questions/49005233/whats-the-difference-between-grid-column-value-1-1-and-1-2" target="_blank" rel="noopener">What’s the difference between grid-column value 1/1 and 1/2?</a></li></ul><h3 id="3-logo的大小設置"><a href="#3-logo的大小設置" class="headerlink" title="(3)logo的大小設置"></a>(3)logo的大小設置</h3><p><code>_logo.scss</code></p><ul><li>注意：設立所設定的欄和列的區塊，是在header設置的grid底下<br><img src="https://i.imgur.com/OEkTxyS.png" alt=""></li></ul><pre><code class="scss">.logo{  grid-column: 1/2;  grid-row: 1/2;  padding: 1rem;  //class=&quot;logo-img&quot;  &amp;-img{      width: 10rem;    height: 100%;  }}</code></pre><h3 id="4-heading"><a href="#4-heading" class="headerlink" title="(4)heading"></a>(4)heading</h3><ul><li>標題的位置一樣利用grid來設定</li><li>在文字的字體、大小、間距進行調整<br><code>_heading.scss</code><pre><code class="scss">.heading{grid-column: 4/7;grid-row: 2/3;text-align: center;&amp;-text{  font-family: &#39;Great Vibes&#39;,cursive;  font-size: size(xl)*2; //結果為6rem  font-weight: lighter;  letter-spacing: 0.5rem;}}</code></pre><img src="https://i.imgur.com/JfkrqEb.png" alt=""></li></ul><h3 id="5-heading中的navigation"><a href="#5-heading中的navigation" class="headerlink" title="(5)heading中的navigation"></a>(5)heading中的navigation</h3><p> <code>layout/_navigation.scss</code></p><ul><li><code>.first-nav</code>為放置右上角</li><li><code>.second-nav</code>為放置下方，中間的位置<pre><code class="scss"></code></pre></li></ul><p>.first-nav{<br>  //放在最後三欄<br>  grid-column: 7/10;<br>  grid-row: 1/2;<br>  @include navigation;<br>}<br>.second-nav{<br>  grid-column: 3/8;<br>  grid-row: 3/4;<br>  @include navigation;<br>}<br>.dropdown{<br>  display: none;<br>}</p><pre><code>![](https://i.imgur.com/PWJoEoH.png)* @mixin，創造navigstion共用樣式    * 使navigation的li-list可以橫向分散排列    * 設定hover效果，使游標摸到顏色變淺`lighten()````scss//.first-nav-list@mixin navigation{  &amp;-list{      display: flex;    justify-content: space-around;    align-items: center;    height: 100%;  }  &amp;-item{    list-style: none;  }  &amp;-link{    color: color(primary);    text-decoration: none;    font-size: size(sm);    transition: all .3s;    &amp;:hover{      color: lighten(color(primary),40%);    }  }}</code></pre><p><img src="https://i.imgur.com/t6KdpJ9.png" alt=""></p><h3 id="6-下拉選項：dropdown-list的箭頭符號"><a href="#6-下拉選項：dropdown-list的箭頭符號" class="headerlink" title="(6)下拉選項：dropdown list的箭頭符號"></a>(6)下拉選項：dropdown list的箭頭符號</h3><p><code>components/_dropdown.scss</code></p><ul><li><code>font-family: &#39;Font Awesome 5 Free&#39;</code>：把icon當作字體使用<br><a href="https://yuwensaf.github.io/6110beb1/" target="_blank" rel="noopener">使用 fontAwesome 動態加入連結 icon</a></li></ul><pre><code class="scss">.dropdown-li{  position: relative; //創造下拉選單的箭頭符號 &amp;::after{   font-family: &#39;Font Awesome 5 Free&#39;;   content: &#39;\f078&#39;;   font-weight:bold ; }}</code></pre><p><img src="https://i.imgur.com/4pg8oNR.png" alt=""></p><ul><li><p>製作下拉式選單的三角形</p><ul><li>先利用border製作出上、下、左、右的三角<pre><code class="scss">.dropdown{&amp;::before{content: &#39;&#39;;display: block;position: absolute;top: -1.5rem;left: 7.3rem;border-top: 15px solid red;border-right: 15px solid green;border-bottom: 15px solid orange;border-left: 15px solid blue;</code></pre></li></ul><p>}<br>}</p><pre><code>![](https://i.imgur.com/chq5TM1.png)</code></pre></li><li><p>調整上方各色的三角形，並留下要保留的一個三角形</p></li></ul><pre><code class="scss">  &amp;::before{    content: &#39;&#39;;    display: block;    position: absolute;    top: -1.5rem;    left: 7.3rem;    // border-top: 15px solid red;    border-right: 15px solid transparent;    border-bottom: 15px solid orange;    border-left: 15px solid transparent;  }</code></pre><p><img src="https://i.imgur.com/YhxKI4C.png" alt=""></p><ul><li><code>right: -2.8rem;</code>:條整位置對齊正方形list</li><li><code>border-bottom: 15px solid darken(color(tertiary),5%);</code>：修改三角形的顏色，使整體為灰色</li></ul><pre><code class="scss">.dropdown{  position: absolute;  top: 3rem;  right: -2.8rem; //使整個往右移動  width: 10rem;  background-color:darken(color(tertiary),5%);  @include navigation;  padding: 1rem;  text-align: center;  border-radius: 0.2rem;  &amp;::before{    content: &#39;&#39;;    display: block;    position: absolute;    top: -1.5rem;    left: 7.3rem;    // border-top: 15px solid red;    border-right: 15px solid transparent;    border-bottom: 15px solid darken(color(tertiary),5%);    border-left: 15px solid transparent;  }</code></pre><p><img src="https://i.imgur.com/JMI2Zgc.png" alt=""></p><ul><li><p>hover使下拉選單消失\出現</p><ul><li>建立游標摸到<code>.dropdown-li</code>，會顯示下拉選單</li><li><code>visibility</code>、<code>opacity</code><pre><code class="scss">.dropdown-li{</code></pre></li></ul><p>&amp;:hover .dropdown{<br>visibility: visible;<br>opacity: 1;<br>}<br>}</p></li></ul><p>.dropdown{<br>visibility: hidden;<br>   opacity: 0;<br>  transition: opicity .3s;<br>}</p><pre><code>![](https://i.imgur.com/vY3cbuj.gif)![](https://i.imgur.com/0zOvMTI.png)## 使slideshow可以跳轉(如幻燈片效果)* 使用`@keyframes`做出動畫位置* Animation Duration(動畫整個完成一次的時間): (fade-in + visible) × images = duration.    * 假設你要讓圖片花1秒fade-in，再讓他顯示1秒。而你共有3張圖片，所以總共所需時間為6秒。* Animation Delay:(fade-in + visible) × (ordinal position − 1) = delay.* Keyframes: 100 ÷ animation duration = percentage for 1 second.(100/20=5%)，5％為1秒，所以4秒大約是20％的位置```scss.slideshow{ &amp;-slide{    //使圖片、文字都放在同一個位置  position: absolute;   top: 0;   left: 0;   width: inherit;   height: inherit;//預設先讓slide消失   visibility: hidden;    opacity: 0;   animation: slideshow 20s linear infinite ;   }}@keyframes slideshow{   //主要是0~20時圖片顯示，之後都消失，讓其他圖片得宜顯示  //0~2%創造fade的效果  0%{    visibility: hidden;    opacity: 0;  };  2%{    visibility: visible;    opacity: 1;  }  //2%~18% slide要顯示  18%{    visibility: visible;    opacity: 1;  }  //18~20要消失  20%{    visibility: hidden;    opacity: 0;  }  100%{    visibility: hidden;    opacity: 0;  }}</code></pre><p><a href="https://snook.ca/archives/html_and_css/simplest-css-slideshow" target="_blank" rel="noopener">Simplest CSS Slideshow</a><br><a href="https://www.smashingmagazine.com/2012/04/pure-css3-cycling-slideshow/#4" target="_blank" rel="noopener">CSS3 Keyframes Animation</a><br><a href="https://pjchender.blogspot.com/2015/12/cssanimation-keyframes.html" target="_blank" rel="noopener">[筆記] CSS動畫Animation — @keyframes</a><br><a href="https://www.oxxostudio.tw/articles/201803/css-animation.html" target="_blank" rel="noopener">完整解析 CSS 動畫 ( CSS Animation )</a></p><ul><li>設置延遲時間(4秒)，使每張圖片呈現(css的撰寫方式)<ul><li><code>:nth-child()</code>選擇第幾張圖片<pre><code class="css">/*設置延遲時間，讓每張slide呈現4秒替換*/.slideshow-slide:nth-child(1){animation-delay: 0s;}.slideshow-slide:nth-child(2){animation-delay: 4s;}.slideshow-slide:nth-child(3){animation-delay: 8s;}.slideshow-slide:nth-child(4){animation-delay: 12s;}.slideshow-slide:nth-child(5){animation-delay: 16s;}</code></pre></li></ul></li></ul><ul><li>將上方轉化為<code>@each</code>的寫法<ul><li>先創造一個列表<code>$animlist</code>，在each迴圈時要但進去的項目</li><li>在each迴圈中<code>.slideshow-slide:nth-child</code>放入slide of number(取得列表中第一個值)，後面接著寫下要執行的動作<code>animation-delay: nth($item,2);</code></li></ul></li></ul><pre><code class="scss">///改寫為=&gt;$animlist:第幾個 延遲秒數,//#{nth($item,1)}: 1表示(2 4s)，第一個值=2$animList:1 0s,2 4s,3 8s,4 12s, 5 16s;@each $item in $animList {   .slideshow-slide:nth-child(#{nth($item,1)}){     animation-delay: nth($item,2);     //2就是指秒數   }}</code></pre><p><a href="https://www.youtube.com/watch?v=O4hPOMX8AaU" target="_blank" rel="noopener">Sass Tutorials #9 - Nth Function In Lists</a></p><h2 id="產品區下方see-more按鈕"><a href="#產品區下方see-more按鈕" class="headerlink" title="產品區下方see more按鈕"></a>產品區下方see more按鈕</h2><ul><li>html part<ul><li>有三個<code>arrow-line</code>，於後續在scss中會運用此三個div製作箭頭符號<pre><code class="html">&lt;div class=&quot;products-btn&quot;&gt;  &lt;a href=&quot;#&quot; class=&quot;btn&quot;&gt;    &lt;div class=&quot;btn-bg&quot;&gt;      &lt;div class=&quot;arrow&quot;&gt;        &lt;div class=&quot;arrow-line arrow-line-1&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;arrow-line arrow-line-2&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;arrow-line arrow-line-3&quot;&gt;&lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;    &lt;span class=&quot;btn-text&quot;&gt;      See More    &lt;/span&gt;  &lt;/a&gt;&lt;/div&gt;</code></pre></li></ul></li></ul><ul><li><p>創造arrow<br><code>transform: rotateZ</code> :Z軸 (使其斜向旋轉45度)</p><pre><code class="scss">&amp;-line {    height: .2rem;    background-color: color(secondary);    position: absolute;}  &amp;-line-2 {    width: 1rem;    //透過旋轉線2,線3使其成為交叉    transform: rotateZ(45deg);  }  &amp;-line-3 {    width: 1rem;    transform: rotateZ(-45deg);  }</code></pre><p><img src="https://i.imgur.com/s62AXMY.png" alt=""></p></li></ul><p><code>transform-origin去設定物件變形的起始點</code></p><pre><code class="scss">&amp;-line {      height: .2rem;      background-color: color(secondary);      position: absolute;      //將x變成arrow &gt; ;因預設原點是在center，所以須將原點拉到右邊，形成箭頭      transform-origin:right ;  }</code></pre><p><img src="https://i.imgur.com/wbRTSeb.png" alt=""></p><p><a href="https://juejin.cn/post/6844903780937367565" target="_blank" rel="noopener">CSS 属性篇(三)：transform-origin属性</a></p><ul><li>增加橫向直線</li></ul><pre><code class="scss">&amp;-line-1{      width: 2rem;      transform: translateX(-0.7rem);    }</code></pre><p><img src="https://i.imgur.com/sdIdcZI.png" alt=""></p><ul><li>設置動畫，透過摸到箭頭，會延展<ul><li>bg的的寬度進行延展</li></ul></li></ul><pre><code class="scss">.btn{&amp;:hover .btn-bg{    width: 18rem;  }  &amp;-bg{     width: 4rem;     height: 4rem;    background-color: color(primary) ;    //使其變圓形     border-radius: 5rem ;    position: absolute;    left: 0;    transition: width .2s ;  }   &amp;-line-1{       width: 0;      transform: translateX(-0.7rem);    }    //* line-1預設看不到，透過hover出現  }</code></pre><p><img src="https://i.imgur.com/vQjUp05.gif" alt=""></p><ul><li><p>使see more 出現</p><ul><li>先修改see more的顏色</li><li>即便改變顏色，還是會被bg覆蓋，所以要調整z-index<pre><code class="scss">.btn{</code></pre></li></ul><p>&amp;:hover .btn-text{<br>  color: color(secondary);<br> }</p></li></ul><p>  &amp;-text{<br>    font-size: size(xs);<br>    text-transform: uppercase;<br>    color: color(primary);<br>    z-index: 10;<br>  }</p><p>}</p><pre><code>![](https://i.imgur.com/bo8TJLy.gif)* 將箭頭向右移動，並呈現完整箭頭符號    * 設定`.arrow`右移，並讓line-1得宜呈現並延展```scss.btn{   &amp;:hover .arrow{    transform: translateX(1rem);  }   &amp;:hover .arrow-line-1{    width: 2rem;  } .arrow{    @include flexPosition;    transition: transform .2s ;    &amp;-line-1{      width: 0;      transform: translateX(-0.7rem);      transition: width .2s ;      }    }}</code></pre><p><img src="https://i.imgur.com/9pptj0t.gif" alt=""></p><h2 id="表尾區塊"><a href="#表尾區塊" class="headerlink" title="表尾區塊"></a>表尾區塊</h2><p><img src="https://i.imgur.com/yHeHkU8.png" alt=""></p><h3 id="1-footer區塊的樣式"><a href="#1-footer區塊的樣式" class="headerlink" title="(1)footer區塊的樣式"></a>(1)footer區塊的樣式</h3><p> <code>layout/_footer.scss</code></p><ul><li>footer有三區，中間是表單，左右邊分別為資訊連結<pre><code class="scss">.footer{</code></pre></li></ul><p>  grid-column: 1/-1;<br>  grid-row: 4/5;<br>  @include flexPosition(space-around);<br>  padding:5rem 0 ;<br>  border-top: .1rem solid color(primary);<br>}</p><pre><code>![](https://i.imgur.com/tSWtPTW.png)* 透過`＠mixin`一次修改2區的條例項目（`mixin_scss`）    * 其中包含文字大小、樣式、hover效果```scss@mixin footerList {  &amp;-heading{    font-size: size(lg);    color:color(primary);  }  &amp;-item{    list-style: none;    margin: 1rem 0;  }  &amp;-link{    font-size: size(xs);    text-decoration: none;    color: lighten(color(primary),15%);    transition: color .2s ;    &amp;:hover{      color:lighten(color(primary),35%)    }  }}</code></pre><p><img src="https://i.imgur.com/X9BA5K0.gif" alt=""></p><h3 id="2-社群icon"><a href="#2-社群icon" class="headerlink" title="(2)社群icon"></a>(2)社群icon</h3><pre><code class="scss">.social-icons{    display: flex;    justify-content: space-between;    padding: 1rem;    box-sizing: border-box;    &amp;-item{      list-style: none;    }    &amp;-link{      text-decoration: none;      width: 4rem;      height: 4rem;      border:.1rem solid color(primary);    }</code></pre><p><img src="https://i.imgur.com/IZzM7eK.png" alt=""></p><ul><li><code>border-radius: 100%;</code>調整為圓形外框</li><li>a標籤的前放為i的圖示，所以flex的設置，是針對<code>social-icons-lik</code><br><img src="https://i.imgur.com/kd6jbyV.png" alt=""></li><li>利用<code>@each</code>來套入icon的顏色</li></ul><pre><code class="scss">&amp;-link{      text-decoration: none;      width: 4rem;      height: 4rem;      border:.1rem solid color(primary);      //修改icon成圓形      // display: block;      border-radius: 100%;      @include flexPosition;      i{        font-size: size(md);      }    }$socialMediaColors: 1 #3b5998, 2 #b31217, 3 #dc4e41, 4 #55acee, 5 #517fa4, 6 #0077b5;@each $color in $socialMediaColors {  .social-icons-item:nth-child(#{nth(($color),1)}) .social-icons-link{    color:nth($color,2);    border:.1rem solid nth($color,2);  }}    </code></pre><ul><li>轉為css<pre><code class="css">.social-icons-item:nth-child(1) .social-icons-link {color: #3b5998;border: 0.1rem solid #3b5998; }</code></pre></li></ul><p>.social-icons-item:nth-child(2) .social-icons-link {<br>  color: #b31217;<br>  border: 0.1rem solid #b31217; }</p><p>.social-icons-item:nth-child(3) .social-icons-link {<br>  color: #dc4e41;<br>  border: 0.1rem solid #dc4e41; }</p><p>.social-icons-item:nth-child(4) .social-icons-link {<br>  color: #55acee;<br>  border: 0.1rem solid #55acee; }</p><p>.social-icons-item:nth-child(5) .social-icons-link {<br>  color: #517fa4;<br>  border: 0.1rem solid #517fa4; }</p><p>.social-icons-item:nth-child(6) .social-icons-link {<br>  color: #0077b5;<br>  border: 0.1rem solid #0077b5; }</p><pre><code>![](https://i.imgur.com/8aWeLiw.png)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/v5qnxzN.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://eva813.github.io/Eva_portfolio/sass-ClothesStore/ClothesStore.</summary>
      
    
    
    
    
    <category term="grid" scheme="https://github.com/Eva813/Eva813.github.io.git/tags/grid/"/>
    
    <category term="SCSS" scheme="https://github.com/Eva813/Eva813.github.io.git/tags/SCSS/"/>
    
  </entry>
  
</feed>
